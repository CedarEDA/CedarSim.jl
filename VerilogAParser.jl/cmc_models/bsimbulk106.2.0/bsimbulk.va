// ****************************************************************************
// *  BSIM-BULK 106.2.0 released by Chetan Gupta on 6/30/2017                 *
// *  BSIM Bulk MOSFET Model Equations (Verilog-A)                            *
// ****************************************************************************

// ****************************************************************************
// *  Copyright 2017 Regents of the University of California                  *
// *  All rights reserved.                                                    *
// *                                                                          *
// *  Project director: Prof. Chenming Hu                                     *
// *                                                                          *
// *  Current developers: Chetan Gupta (Ph.D. student, IIT Kanpur)            *
// *                      Prof. Yogesh Chauhan (IIT Kanpur)                   *
// *                      Dr. Harshit Agarwal (Postdoc, UC Berkeley)          *
// *                      Dr. Huan-Lin Chang (Postdoc, UC Berkeley)           *
// *                      Dr. Pragya Kushwaha (Postdoc, UC Berkeley)          *
// *                      Juan Duarte (Ph.D. student, UC Berkeley)            *
// *                      Yen-Kai Lin (Ph.D. student, UC Berkeley)            *
// ****************************************************************************

// ****************************************************************************
// *  Software is distributed as is, completely without warranty or service   *
// *  support. The University of California and its employees are not liable  *
// *  for the condition or performance of the software.                       *
// *                                                                          *
// *  The University of California owns the copyright and grants users a      *
// *  perpetual, irrevocable, worldwide, non-exclusive, royalty-free license  *
// *  with respect to the software as set forth below.                        *
// *                                                                          *
// *  The University of California hereby disclaims all implied warranties.   *
// *                                                                          *
// *  The University of California grants the users the right to modify,      *
// *  copy, and redistribute the software and documentation, both within      *
// *  the user's organization and externally, subject to the following        *
// *  restrictions:                                                           *
// *                                                                          *
// *  1. The users agree not to charge for the University of California code  *
// *     itself but may charge for additions, extensions, or support.         *
// *                                                                          *
// *  2. In any product based on the software, the users agree to             *
// *     acknowledge the University of California that developed the          *
// *     software. This acknowledgment shall appear in the product            *
// *     documentation.                                                       *
// *                                                                          *
// *  3. Redistributions to others of source code and documentation must      *
// *     retain the copyright notice, disclaimer, and list of conditions.     *
// *                                                                          *
// *  4. Redistributions to others in binary form must reproduce the          *
// *     copyright notice, disclaimer, and list of conditions in the          *
// *     documentation and/or other materials provided with the               *
// *     distribution.                                                        *
// *                                                                          *
// *  Agreed to on _________Jun. 30, 2017__________                           *
// *                                                                          *
// *  By: ____University of California, Berkeley___                           *
// *      ____Chenming Hu__________________________                           *
// *      ____Professor in Graduate School ________                           *
// ****************************************************************************

`include "constants.vams"
`include "disciplines.vams"

// Disable strobe for improved performance speed
// To Use DISABLE_STROBE, Activate it here. Used Only at GEOMOD and RGEOMOD
// `define DISABLE_STROBE
`ifdef DISABLE_STROBE
    `define STROBE(X)
    `define STROBE2(X,Y)
`else
    `define STROBE(X) $strobe(X)
    `define STROBE2(X,Y) $strobe(X,Y)
`endif

// Junction capacitance macro between S/D and bulk
`define JunCap(Czbx, Vbx_jct, PBX_t, MJX, czbx_p1, czbx_p2, Qbxj) \
    if (Czbx > 0.0) begin \
        T1 = Vbx_jct / PBX_t; \
        if (T1 < 0.9) begin \
            arg = 1.0 - T1; \
            if (MJX == 0.5) begin \
                sarg = 1.0 / sqrt(arg); \
            end else begin \
                sarg = lexp(-MJX * lln(arg)); \
            end \
            Qbxj = PBX_t * Czbx * (1.0 - arg * sarg) / (1.0 - MJX); \
        end else begin \
            T2  = czbx_p1 * (T1 - 1.0) * (5.0 * MJX * (T1 - 1.0) + (1.0 + MJX)); \
            Qbxj = PBX_t * Czbx * (T2 + czbx_p2); \
        end \
    end else begin \
        Qbxj = 0.0; \
    end \

// Normalized pinch-off voltage including PD
`define PO_psip(vg_vfb, gamma, DPD, phif, psip) \
    T1       = 1.0 + DPD; \
    vgfbPD   = vg_vfb / T1; \
    gammaPD  = gamma / T1; \
    T1       = 0.5 * vgfbPD - 3.0 * (1.0 + gammaPD / `M_SQRT2); \
    T2       = T1 + sqrt(T1 * T1 + 6.0 * vgfbPD); \
    if (vgfbPD < 0.0) begin \
        T3   = (vgfbPD - T2) / gammaPD; \
        psip = -lln(1.0 - T2 + T3 * T3); \
    end else begin \
        T3   = lexp(-T2); \
        T1   = 0.5 * gammaPD; \
        T2   = sqrt(vgfbPD - 1.0 + T3 + T1 * T1) - T1; \
        psip = T2 * T2 + 1.0 - T3; \
    end \

// Normalized charge-voltage relationship
`define BSIM_q(psip, phib, vch, gam, q) \
    T8 = 0.5 * (psip + 1.0 + sqrt((psip - 1.0) * (psip - 1.0) + 0.25 * 2.0 * 2.0)); \
    sqrtpsip = sqrt(T8); \
    T9 = 1.0 + gam / (2.0 * sqrtpsip); \
    T0 = (1.0 + (gam / (2.0 * sqrtpsip))) / gam; \
    T1 = psip - 2.0 * phib - vch; \
    T2 = T1 - lln(4.0 * T0 * sqrtpsip); \
    T8 = 0.5 * (T2 - 0.201491 - sqrt(T2 * (T2 + 0.402982) + 2.446562)); \
    sqrtpsisa = sqrtpsip; \
    if (T8 <= -68.0) begin \
        T4 = -100.0; \
        T5 = 20.0; \
        if (T8 < T4 - 0.5 * T5) \
            T3 = lexp(T4); \
        else begin \
            if (T8 > T4 + 0.5 * T5) \
                T3 = lexp(T8); \
            else begin \
                T2 = (T8 - T4) / T5; \
                T6 = T2 * T2; \
                T3 = lexp(T4 + T5 * ((5.0 / 64.0) + 0.5 * T2 + T6 * ((15.0 / 16.0) - T6 * (1.25 - T6)))); \
            end \
        end \
        q = T3 * (1.0 + T1 - T8 - lln(2.0 * T0 * (T3 * 2.0 * T0 + 2.0 * sqrtpsisa))); \
    end else begin \
        T3 = lexp(T8); \
        sqrtpsisainv = 1.0 / sqrtpsisa; \
        T4 = 2.0 * T3 + lln(T3 * 2.0 * T0 * (T3 *  2.0 * T0 + 2.0 * sqrtpsisa)) - T1; \
        T5 = 2.0 + (1.0 / T3) + (T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa); \
        T3 = T3 - T4 / T5; \
        T4 = 2.0 * T3 + lln(T3 * 2.0 * T0 * (T3 * 2.0 * T0 + 2.0 * sqrtpsisa)) - T1; \
        T5 = 2.0 + (1.0 / T3) + (T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa); \
        T6 = ((T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa)) * ((T0 + sqrtpsisainv) / (T0 * T3 + sqrtpsisa)); \
        T7 = -((1.0 / T3) * (1.0 / T3)) - (1.0 / (sqrtpsisa * sqrtpsisa * sqrtpsisa * (T0 * T3 + sqrtpsisa))) - T6; \
        q  = T3 - (T4 / T5) * (1.0 + T4 * T7 / (2.0 * T5 * T5)); \
    end \

// Smoothing function for (max of x, x0 with deltax)
`define Smooth(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)); \

// Smoothing function for (max of x, x0 with deltax)
`define Smooth1(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)) - 0.25 * deltax; \

// Smoothing function for (min of x, x0 with deltax)
`define Smooth2(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 - sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)) + 0.25 * deltax; \

// Smoothing function for (min of x, x0 with deltax)
`define Min1(x, x0, deltax, xsmooth) \
    xsmooth = 0.5 * (x + x0 - sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax)); \

 // These macros represent the subroutines to process the geometry dependent
 // parasitics for BSIM-BULK, which calculates Ps, Pd, As, Ad, and Rs and Rd
 // for multi-fingers and various GEO and RGEO options.

// Define GEOMOD and RGEOMOD in the modelcard
`define BSIMBULKNumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
    if ((nf % 2) != 0) begin \
        nuEndD = 1.0; \
        nuEndS = 1.0; \
        nuIntD = 2.0 * max((nf - 1.0) / 2.0, 0.0); \
        nuIntS = nuIntD; \
    end else begin \
        if (minSD == 1) begin \
            nuEndD = 2.0; \
            nuIntD = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
            nuEndS = 0.0; \
            nuIntS = nf; \
        end else begin \
            nuEndD = 0.0; \
            nuIntD = nf; \
            nuEndS = 2.0; \
            nuIntS = 2.0 * max((nf / 2.0 - 1.0), 0.0); \
        end \
    end

`define BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, SRCFLAG, Rend) \
    if (SRCFLAG == 1) begin \
        case(rgeo) \
        1, 2, 5: begin \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end else begin \
                Rend = Rsh * DMCG / (Weffcj * nuEnd); \
            end \
        end \
        3, 4, 6: begin \
            if ((DMCG + DMCI) == 0.0) begin \
                `STROBE("(DMCG + DMCI) can not be equal to zero"); \
            end \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end else begin \
                Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
            end \
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified RGEO = %d not matched (BSIMBULKRdsEndIso), Rend is set to zero.", rgeo); \
            Rend = 0.0; \
        end \
        endcase \
    end else begin \
        case(rgeo) \
        1, 3, 7: begin \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end else begin \
                Rend = Rsh * DMCG / (Weffcj * nuEnd); \
            end \
        end \
        2, 4, 8: begin \
            if ((DMCG + DMCI) == 0.0) begin \
                `STROBE("(DMCG + DMCI) can not be equal to zero"); \
            end \
            if (nuEnd == 0.0) begin \
                Rend = 0.0; \
            end \
            else begin \
                Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI)); \
            end \
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified RGEO=%d not matched (BSIMBULKRdsEndIso type 2), Rend is set to zero.", rgeo); \
            Rend = 0.0; \
        end \
        endcase \
    end

`define BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, SRCFLAG, Rend) \
    begin \
        if (SRCFLAG == 1) begin \
            case(rgeo) \
            1, 2, 5: begin \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end else begin \
                    Rend = Rsh * DMCG / (Weffcj * nuEnd); \
                end \
            end \
            3, 4, 6: begin \
                if (DMCG == 0.0) begin \
                    `STROBE("DMCG can not be equal to zero"); \
                end \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end \
                else begin \
                    Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
                end \
            end \
            default: begin \
                `STROBE2("Warning: (instance %M) Specified RGEO = %d not matched (BSIMBULKRdsEndSha), Rend is set to zero.", rgeo); \
                Rend = 0.0; \
            end \
            endcase \
        end else begin \
            case(rgeo) \
            1, 3, 7: begin \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end else begin \
                    Rend = Rsh * DMCG / (Weffcj * nuEnd); \
                end \
            end \
            2, 4, 8: begin \
                if (DMCG == 0.0) begin \
                    `STROBE("DMCG can not be equal to zero"); \
                end \
                if (nuEnd == 0.0) begin \
                    Rend = 0.0; \
                end \
                else begin \
                    Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG); \
                end \
            end \
            default: begin \
                `STROBE2("Warning: (instance %M) Specified RGEO=%d not matched (BSIMBULKRdsEndSha \
                type 2), Rend is set to zero.", rgeo); \
                Rend = 0.0; \
            end \
            endcase \
        end \
    end

`define BSIMBULKRdseffGeo(nf, geo, rgeo, minSD, Weffcj, Rsh, DMCG, DMCI, DMDG, SRCFLAG, Rtot) \
    begin \
        if (geo < 9) begin \
            `BSIMBULKNumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
            if (SRCFLAG == 1) begin \
                if (nuIntS == 0.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / ( Weffcj * nuIntS); \
                end \
            end \
            else begin \
                if (nuIntD == 0.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / ( Weffcj * nuIntD); \
                end \
            end \
        end \
        case(geo) \
        0: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        1: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        2: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        3: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        4: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                Rend = Rsh * DMDG / Weffcj; \
            end \
        end \
        5: begin \
            if (SRCFLAG == 1) begin \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                rgeo, 1, Rend) \
            end else begin \
                    if (nuEndD==0) begin\
                        Rend = 0;\
                    end else begin \
                    Rend = Rsh * DMDG / (Weffcj * nuEndD); \
                    end \
                end\
        end \
        6: begin \
            if (SRCFLAG == 1) begin \
                Rend = Rsh * DMDG / Weffcj; \
            end else begin \
                `BSIMBULKRdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
            end \
        end \
        7:begin \
            if (SRCFLAG == 1) begin \
                    if (nuEndS == 0) begin \
                        Rend = 0; \
                    end else begin \
                        Rend = Rsh * DMDG / (Weffcj * nuEndS); \
                    end \
            end else \
                `BSIMBULKRdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                rgeo, 0, Rend) \
        end \
        8: begin \
            Rend = Rsh * DMDG / Weffcj; \
        end \
        9: begin /* all wide contacts assumed for geo = 9 and 10 */\
            if (SRCFLAG == 1) begin \
                Rend = 0.5 * Rsh * DMCG / Weffcj; \
                if (nf == 2.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
                end \
            end \
            else begin \
                Rend = 0.0; \
                Rint = Rsh * DMCG / (Weffcj * nf); \
            end \
        end \
        10: begin \
            if (SRCFLAG == 1) begin \
                Rend = 0.0; \
                Rint = Rsh * DMCG / (Weffcj * nf); \
            end \
            else begin \
                Rend = 0.5 * Rsh * DMCG / Weffcj; \
                if (nf == 2.0) begin \
                    Rint = 0.0; \
                end else begin \
                    Rint = Rsh * DMCG / (Weffcj * (nf - 2.0)); \
                end \
            end \
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified GEO=%d not matched (BSIMBULKRdseffGeo), Rint is set to zero.", geo); \
            Rint = 0.0; \
        end \
        endcase \
        if (Rint <= 0.0) begin \
            Rtot = Rend; \
        end else if (Rend <= 0.0) begin \
            Rtot = Rint; \
        end else begin \
            Rtot = Rint * Rend / (Rint + Rend); \
        end \
        if (Rtot==0.0) begin \
            `STROBE("Warning: (instance %M) Zero resistance returned from RdseffGeo"); \
        end \
    end

// Effective PS, PD, AS, AD calculation, Ref: BSIM4
`define BSIMBULKPAeffGeo(nf, geo, minSD,Weffcj, DMCG, DMCI, DMDG, Ps, Pd, As, Ad) \
    begin if (geo < 9) \
    `BSIMBULKNumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
    T0 = DMCG + DMCI;\
    T1 = DMCG + DMCG;\
    T2 = DMDG + DMDG;\
    PSiso = T0 + T0 + Weffcj;\
    PDiso = T0 + T0 + Weffcj;\
    PSsha = T1;\
    PDsha = T1;\
    PSmer = T2;\
    PDmer = T2;\
    ASiso = T0 * Weffcj;\
    ADiso = T0 * Weffcj;\
    ASsha = DMCG * Weffcj;\
    ADsha = DMCG * Weffcj;\
    ASmer = DMDG * Weffcj;  \
    ADmer = DMDG * Weffcj;  \
        case(geo) \
        0: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha;\
            Pd = nuEndD * PDiso + nuIntD * PDsha;\
            As = nuEndS * ASiso + nuIntS * ASsha;\
            Ad = nuEndD * ADiso + nuIntD * ADsha;\
        end \
        1: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha;\
            Pd = (nuEndD + nuIntD) * PDsha;\
            As = nuEndS * ASiso + nuIntS * ASsha;\
            Ad = (nuEndD + nuIntD) * ADsha;\
        end \
        2: begin \
            Ps = (nuEndS + nuIntS) * PSsha;\
            Pd = nuEndD * PDiso + nuIntD * PDsha;\
            As = (nuEndS + nuIntS) * ASsha;\
            Ad = nuEndD * ADiso + nuIntD * ADsha;\
        end \
        3: begin \
            Ps = (nuEndS + nuIntS) * PSsha;\
            Pd = (nuEndD + nuIntD) * PDsha;\
            As = (nuEndS + nuIntS) * ASsha;\
            Ad = (nuEndD + nuIntD) * ADsha;\
        end \
        4: begin \
            Ps = nuEndS * PSiso + nuIntS * PSsha;\
            Pd = nuEndD * PDmer + nuIntD * PDsha;\
            As = nuEndS * ASiso + nuIntS * ASsha;\
            Ad = nuEndD * ADmer + nuIntD * ADsha;\
        end \
        5: begin \
            Ps = (nuEndS + nuIntS) * PSsha;\
            Pd = nuEndD * PDmer + nuIntD * PDsha;\
            As = (nuEndS + nuIntS) * ASsha;\
            Ad = nuEndD * ADmer + nuIntD * ADsha;\
        end \
        6: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha;\
            Pd = nuEndD * PDiso + nuIntD * PDsha;\
            As = nuEndS * ASmer + nuIntS * ASsha;\
            Ad = nuEndD * ADiso + nuIntD * ADsha;\
        end \
        7: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha;\
            Pd = (nuEndD + nuIntD) * PDsha;\
            As = nuEndS * ASmer + nuIntS * ASsha;\
                    Ad = (nuEndD + nuIntD) * ADsha;\
        end \
        8: begin \
            Ps = nuEndS * PSmer + nuIntS * PSsha;\
        Pd = nuEndD * PDmer + nuIntD * PDsha;\
            As = nuEndS * ASmer + nuIntS * ASsha;\
            Ad = nuEndD * ADmer + nuIntD * ADsha;\
        end \
        9: begin \
            Ps = PSiso + (nf - 1.0) * PSsha;\
            Pd = nf * PDsha;\
            As = ASiso + (nf - 1.0) * ASsha;\
            Ad = nf * ADsha;\
        end \
        10: begin \
            Ps = nf * PSsha;\
            Pd = PDiso + (nf - 1.0) * PDsha;\
            As = nf * ASsha;\
            Ad = ADiso + (nf - 1.0) * ADsha;\
        end \
        default: begin \
            `STROBE2("Warning: (instance %M) Specified GEO=%d not matched (BSIMBULKPAeffGeo \
            ), PS,PD,AS,AD set to zero.", geo); \
            Ps = 0;\
            Pd = 0;\
            As = 0;\
            Ad = 0;\
        end \
        endcase \
    end \

// Numerical Constants
`define EXPL_THRESHOLD  80.0
`define MAX_EXPL        5.540622384e34
`define MIN_EXPL        1.804851387e-35
`define N_MINLOG        1.0e-38
`define DELTA_1         0.02
`define Oneby3          0.33333333333333333
`define REFTEMP         300.15   // 27 degrees C

// Physical Constants
`define ntype       1
`define ptype       -1
`define q           1.60219e-19
`define EPS0        8.85418e-12
`define KboQ        8.617087e-5      // Joule/degree

//  Macros for the model/instance parameters
//
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//     ||
//     cc    closed lower bound, closed upper bound
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     cz    closed lower bound=0, open upper bound=inf
//     oz    open   lower bound=0, open upper bound=inf
//     nb    no bounds
//     ex    no bounds with exclude
//     sw    switch(integer only, values  0=false  and  1=true)
//     ty    switch(integer only, values -1=p-type and +1=n-type)
//
//  IPM   instance parameter mFactor(multiplicity, implicit for LRM 2.2)
//  OPP   operating point parameter, includes units and description for printing

`define OPP(nam,uni,des)               (* units=uni, desc=des *)           real    nam;
`define OPM(nam,uni,des)               (* units=uni, desc=des, multiplicity="multiply" *)  real    nam;
`define OPD(nam,uni,des)               (* units=uni, desc=des, multiplicity="divide"   *)  real    nam;

`define MPRnb(nam,def,uni,        des) (* units=uni, desc=des *) parameter real    nam=def;
`define MPRex(nam,def,uni,exc,    des) (* units=uni, desc=des *) parameter real    nam=def exclude exc;
`define MPRcc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from[lwr:upr];
`define MPRoo(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from(lwr:upr);
`define MPRco(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from[lwr:upr);
`define MPRoc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter real    nam=def from(lwr:upr];
`define MPRcz(nam,def,uni,        des) (* units=uni, desc=des *) parameter real    nam=def from[  0:inf);
`define MPRoz(nam,def,uni,        des) (* units=uni, desc=des *) parameter real    nam=def from(  0:inf);

`define MPInb(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def;
`define MPIex(nam,def,uni,exc,    des) (* units=uni, desc=des *) parameter integer nam=def exclude exc;
`define MPIcc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from[lwr:upr];
`define MPIoo(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from(lwr:upr);
`define MPIco(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from[lwr:upr);
`define MPIoc(nam,def,uni,lwr,upr,des) (* units=uni, desc=des *) parameter integer nam=def from(lwr:upr];
`define MPIcz(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from[  0:inf);
`define MPIoz(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from(  0:inf);
`define MPIsw(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from[  0:  1];
`define MPIty(nam,def,uni,        des) (* units=uni, desc=des *) parameter integer nam=def from[ -1:  1] exclude 0;
`define IPRnb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def;
`define IPRex(nam,def,uni,exc,    des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def exclude exc;
`define IPRcc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from[lwr:upr];
`define IPRoo(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from(lwr:upr);
`define IPRco(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from[lwr:upr);
`define IPRoc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from(lwr:upr];
`define IPRcz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from[  0:inf);
`define IPRoz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real    nam=def from(  0:inf);
`define IPInb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def;
`define IPIex(nam,def,uni,exc,    des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def exclude exc;
`define IPIcc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from[lwr:upr];
`define IPIoo(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from(lwr:upr);
`define IPIco(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from[lwr:upr);
`define IPIoc(nam,def,uni,lwr,upr,des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from(lwr:upr];
`define IPIcz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from[  0:inf);
`define IPIoz(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def from(  0:inf);
`define BPRco(nam, def, uni, lwr, upr, des) (* units = uni, type = "instance", desc = des *) parameter real    nam = def from[lwr : upr);
`define BPRoz(nam, def, uni,           des) (* units = uni, type = "instance", desc = des *) parameter real    nam = def from(0.0 : inf);
`define BPRcz(nam, def, uni,           des) (* units = uni, type = "instance", desc = des *) parameter real    nam = def from[0.0 : inf);
`define BPIcc(nam, def, uni, lwr, upr, des) (* units = uni, type = "instance", desc = des *) parameter integer nam = def from[lwr : upr];
`define BPInb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter integer nam=def;
`define BPRnb(nam,def,uni,        des) (* units=uni, type = "instance", desc=des *) parameter real nam=def;


module bsimbulk(d, g, s, b, t);
inout d, g, s, b, t;
electrical d, g, s, b, di, si, gi, gm, bi, sbulk, dbulk;
thermal t;

// Extra internal nodes and branches (TNOIMOD=1) for correlated drain and gate noise
electrical N1, N2;
branch (N1) NI;
branch (N1) NR;
branch (N1) NC;

// Clamped exponential function
analog function real lexp;
    input x;
    real x;
    begin
        if (x > `EXPL_THRESHOLD) begin
            lexp = `MAX_EXPL * (1.0 + x - `EXPL_THRESHOLD);
        end else if (x < -`EXPL_THRESHOLD) begin
            lexp = `MIN_EXPL;
        end else begin
            lexp = exp(x);
        end
    end
endfunction

// Clamped log function
analog function real lln;
    input x;
    real x;
    begin
        lln = ln(max(x, `N_MINLOG));
    end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
    input x, c;
    real x, c;
    begin
        hypsmooth = 0.5 * (x + sqrt(x * x + 4.0 * c * c));
    end
endfunction

// Pure instance parameters
`IPRoz( L                 ,1.0e-5                                   ,"m"                                     ,"Length" )
`IPRoz( W                 ,1.0e-5                                   ,"m"                                     ,"Total width including fingers" )
`IPIco( NF                ,1                                        ,""            ,1           ,inf         ,"Number of fingers" )
`IPRcz( NRS               ,1.0                                      ,""                                      ,"Number of squares in source" )
`IPRcz( NRD               ,1.0                                      ,""                                      ,"Number of squares in drain" )
`IPRnb( VFBSDOFF          ,0.0                                      ,"V"                                     ,"Flat-band Voltage Offset Parameter" )
`IPIcc( MINZ              ,0                                        ,""            ,0           ,1           ,"Minimize either D or S" )
`IPRnb( XGW               ,0.0                                      ,"m"                                     ,"Distance from gate contact centre to dev edge" )
`IPIcc( NGCON             ,1                                        ,""            ,1           ,2           ,"Number of gate contacts" )
`IPIcc( RGATEMOD          ,0                                        ,""            ,0           ,3           ,"Gate resistance model selector" )
`IPIcc( RBODYMOD          ,0                                        ,""            ,0           ,2           ,"Distributed body R model" )
`IPIcc( GEOMOD            ,0                                        ,""            ,0           ,10          ,"Geometry-dependent parasitics model" )
`IPIcc( RGEOMOD           ,0                                        ,""            ,0           ,8           ,"Geometry-dependent source/drain resistance,  0: RSH-based, 1: Holistic" )
`IPIcc( EDGEFET           ,0                                        ,""            ,0           ,1           ,"0: Edge FET Model Off, 1: Edge FET Model ON" )
`IPIcc( SSLMOD            ,0                                        ,""            ,0           ,1           ,"Sub-Surface Leakage Drain Current, 0: Turn off  1: Turn on" )
`IPRcz( RBPB              ,50.0                                     ,"ohm"                                   ,"Resistance between bNodePrime and bNode" )
`IPRcz( RBPD              ,50.0                                     ,"ohm"                                   ,"Resistance between bNodePrime and bNode " )
`IPRcz( RBPS              ,50.0                                     ,"ohm"                                   ,"Resistance between bNodePrime and sbNode " )
`IPRcz( RBDB              ,50.0                                     ,"ohm"                                   ,"Resistance between bNode and dbNode " )
`IPRcz( RBSB              ,50.0                                     ,"ohm"                                   ,"Resistance between bNode and sbNode" )
`IPRnb( SA                ,0.0                                      ,"m"                                     ,"Distance between OD edge from Poly from one side" )
`IPRnb( SB                ,0.0                                      ,"m"                                     ,"Distance between OD edge from Poly from other side" )
`IPRnb( SD                ,0.0                                      ,"m"                                     ,"Distance between neighbouring fingers" )
`IPRoo( SCA               ,0.0                                      ,""            ,-inf        ,inf         ,"Integral of the first distribution function for scattered well dopant" )
`IPRoo( SCB               ,0.0                                      ,""            ,-inf        ,inf         ,"Integral of second distribution function for scattered well dopant" )
`IPRoo( SCC               ,0.0                                      ,""            ,-inf        ,inf         ,"Integral of third distribution function for scattered well dopant" )
`IPRoo( SC                ,0.0                                      ,"m"           ,-inf        ,inf         ,"Distance to a single well edge if <=0.0, turn off WPE" )
`IPRcz( AS                ,0.0                                      ,"m^2"                                   ,"Source to Substrate Junction Area" )
`IPRcz( AD                ,0.0                                      ,"m^2"                                   ,"Drain to Substrate Junction Area" )
`IPRcz( PS                ,0.0                                      ,"m"                                     ,"Source to Substrate Junction Perimeter" )
`IPRcz( PD                ,0.0                                      ,"m"                                     ,"Drain to Substrate Junction Perimeter" )

// Both model and instance parameters
`BPRnb( DTEMP             ,0.0                                      ,"K"                                     ,"Offset of Device Temperature" )
`BPRnb( MULU0             ,1.0                                      ,"m^2/(V*s)"                             ,"Multiplication factor for low field mobility" )
`BPRnb( DELVTO            ,0.0                                      ,"V"                                     ,"Zero bias threshold voltage variation" )
`BPRcz( IDS0MULT          ,1.0                                      ,""                                      ,"Variability in drain current for miscellaneous reasons" )

// Pure model parameters
`MPIty( TYPE              ,`ntype                                   ,""                                      ,"ntype=1, ptype=-1" )
`MPIcc( CVMOD             ,0                                        ,""            ,0           ,1           ,"0: Consistent IV-CV, 1: Different IV-CV" )
`MPIcc( COVMOD            ,0                                        ,""            ,0           ,1           ,"0: Use Bias-independent Overlap Capacitances,  1: Use Bias-dependent Overlap Capacitances" )
`MPIcc( RDSMOD            ,0                                        ,""            ,0           ,2           ,"0: Internal bias dependent and external bias independent s/d resistance model,  1: External s/d resistance model,  2: Internal s/d resistance model" )
`MPIcc( WPEMOD            ,0                                        ,""            ,0           ,1           ,"Model flag" )
`MPIcc( ASYMMOD           ,0                                        ,""            ,0           ,1           ,"0: Asymmetry Model turned off - forward mode parameters used,  1: Asymmetry Model turned on" )
`MPIcc( GIDLMOD           ,0                                        ,""            ,0           ,1           ,"0: Turn off GIDL Current,  1: Turn on GIDL Current" )
`MPIcc( IGCMOD            ,0                                        ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd,  1: Turn on Igc, Igs and Igd" )
`MPIcc( IGBMOD            ,0                                        ,""            ,0           ,1           ,"0: Turn off Igb,  1: Turn on Igb" )
`MPIcc( TNOIMOD           ,0                                        ,""            ,0           ,1           ,"Thermal noise model selector" )
`MPIcc( SHMOD             ,0                                        ,""            ,0           ,1           ,"0 : Self heating model OFF,  1 : Self heating model ON" )
`MPIcc( MOBSCALE          ,0                                        ,""            ,0           ,1           ,"Mobility scaling model, 0: Old Model,  1: New Model" )

// Device parameters
`MPRoz( LLONG             ,10u                                      ,"m"                                     ,"L of extracted Long channel device" )
`MPRoz( LMLT              ,1.0                                      ,""                                      ,"Length Shrinking Parameter" )
`MPRoz( WMLT              ,1.0                                      ,""                                      ,"Width Shrinking Parameter" )
`MPRnb( XL                ,0.0                                      ,"m"                                     ,"L offset for channel length due to mask/etch effect" )
`MPRoz( WWIDE             ,10u                                      ,"m"                                     ,"W of extracted Wide channel device" )
`MPRnb( XW                ,0.0                                      ,"m"                                     ,"W offset for channel width due to mask/etch effect" )
`MPRnb( LINT              ,0.0                                      ,"m"                                     ,"Delta L for IV" )
`MPRnb( LL                ,0.0                                      ,"m^(1+LLN)"                             ,"Length reduction parameter" )
`MPRnb( LW                ,0.0                                      ,"m^(1+LWN)"                             ,"Length reduction parameter" )
`MPRnb( LWL               ,0.0                                      ,"m^(1+LLN+LWN)"                         ,"Length reduction parameter" )
`MPRnb( LLN               ,1.0                                      ,""                                      ,"Length reduction parameter" )
`MPRnb( LWN               ,1.0                                      ,""                                      ,"Length reduction parameter" )
`MPRnb( WINT              ,0.0                                      ,"m"                                     ,"Delta W for IV" )
`MPRnb( WL                ,0.0                                      ,"m^(1+WLN)"                             ,"Width reduction parameter" )
`MPRnb( WW                ,0.0                                      ,"m^(1+WWN)"                             ,"Width reduction parameter" )
`MPRnb( WWL               ,0.0                                      ,"m^(1+WWN+WLN)"                         ,"Width reduction parameter" )
`MPRnb( WLN               ,1.0                                      ,""                                      ,"Width reduction parameter" )
`MPRnb( WWN               ,1.0                                      ,""                                      ,"Width reduction parameter" )
`MPRnb( DLC               ,0.0                                      ,"m"                                     ,"Delta L for CV" )
`MPRnb( LLC               ,0.0                                      ,"m^(1+LLN)"                             ,"Length reduction parameter" )
`MPRnb( LWC               ,0.0                                      ,"m^(1+LWN)"                             ,"Length reduction parameter" )
`MPRnb( LWLC              ,0.0                                      ,"m^(1+LWN+LLN)"                         ,"Length reduction parameter" )
`MPRnb( DWC               ,0.0                                      ,"m"                                     ,"Delta W for CV" )
`MPRnb( WLC               ,0.0                                      ,"m^(1+WLN)"                             ,"Width reduction parameter" )
`MPRnb( WWC               ,0.0                                      ,"m^(1+WWN)"                             ,"Width reduction parameter" )
`MPRnb( WWLC              ,0.0                                      ,"m^(1+WWN+WLN)"                         ,"Width reduction parameter" )
`MPRoo( TOXE              ,3.0e-9                                   ,"m"          ,0            ,inf         ,"Effective gate dielectric thickness relative to SiO2" )
`MPRoo( TOXP              ,TOXE                                     ,"m"          ,0            ,inf         ,"Physical gate dielectric thickness. If not given, TOXP is calculated from TOXE and DTOX" )
`MPRnb( DTOX              ,0.0                                      ,"m"                                     ,"Difference between effective dielectric thickness" )
`MPRnb( NDEP              ,1e24                                     ,"1/m^3"                                 ,"Channel Doping Concentration for IV" )
`MPRnb( NDEPL1            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of NDEP" )
`MPRoz( NDEPLEXP1         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of NDEP" )
`MPRnb( NDEPL2            ,0.0                                      ,"m"                                     ,"Length dependence of NDEP - For Short Channel Devices" )
`MPRoz( NDEPLEXP2         ,2.0                                      ,""                                      ,"Length dependence exponent coefficient of NDEP" )
`MPRnb( NDEPW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of NDEP" )
`MPRoz( NDEPWEXP          ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of NDEP" )
`MPRnb( NDEPWL            ,0.0                                      ,"m^2"                                   ,"Width-Length dependence coefficient of NDEP" )
`MPRoz( NDEPWLEXP         ,1.0                                      ,""                                      ,"Width-Length dependence exponent coefficient of NDEP" )
`MPRnb( LNDEP             ,0.0                                      ,"1/m^2"                                 ,"Length dependence  of NDEP" )
`MPRnb( WNDEP             ,0.0                                      ,"1/m^2"                                 ,"Width dependence  of NDEP" )
`MPRnb( PNDEP             ,0.0                                      ,"1/m"                                   ,"Area dependence  of NDEP " )
`MPRnb( NDEPCV            ,NDEP                                     ,"1/m^3"                                 ,"Channel Doping Concentration for CV" )
`MPRnb( NDEPCVL1          ,NDEPL1                                   ,"m"                                     ,"Length dependence coefficient of NDEPCV" )
`MPRoz( NDEPCVLEXP1       ,NDEPLEXP1                                ,""                                      ,"Length dependence exponent coefficient of NDEPCV" )
`MPRnb( NDEPCVL2          ,NDEPL2                                   ,"m"                                     ,"Length dependence coefficient of NDEPCV - For Short Channel Devices" )
`MPRoz( NDEPCVLEXP2       ,NDEPLEXP2                                ,""                                      ,"Length dependence exponent coefficient of NDEPCV" )
`MPRnb( NDEPCVW           ,NDEPW                                    ,"m"                                     ,"Width dependence coefficient of NDEPCV" )
`MPRoz( NDEPCVWEXP        ,NDEPWEXP                                 ,""                                      ,"Width dependence exponent coefficient of NDEPCV" )
`MPRnb( NDEPCVWL          ,NDEPWL                                   ,"m^2"                                   ,"Width-Length dependence coefficient of NDEPCV" )
`MPRoz( NDEPCVWLEXP       ,NDEPWLEXP                                ,""                                      ,"Width-Length dependence exponent coefficient of NDEPCV" )
`MPRnb( LNDEPCV           ,LNDEP                                    ,"1/m^2"                                 ,"Length dependence  of NDEP for CV" )
`MPRnb( WNDEPCV           ,WNDEP                                    ,"1/m^2"                                 ,"Width dependence of NDEP for CV" )
`MPRnb( PNDEPCV           ,PNDEP                                    ,"1/m"                                   ,"Area dependence of NDEP for CV" )
`MPRnb( NGATE             ,5e25                                     ,"1/m^3"                                 ,"Gate Doping Concentration" )
`MPRnb( LNGATE            ,0.0                                      ,"1/m^2"                                 ,"Length dependence of NGATE" )
`MPRnb( WNGATE            ,0.0                                      ,"1/m^2"                                 ,"Width dependence of NGATE" )
`MPRnb( PNGATE            ,0.0                                      ,"1/m"                                   ,"Area dependence of NGATE" )
`MPRnb( EASUB             ,4.05                                     ,"eV"                                    ,"Electron affinity of substrate" )
`MPRoz( NI0SUB            ,1.1e16                                   ,"1/m^3"                                 ,"Intrinsic carrier concentration of the substrate at 300.15K" )
`MPRoo( BG0SUB            ,1.17                                     ,"eV"         ,0            ,inf         ,"Band gap of substrate at 300.15K" )
`MPRoo( EPSRSUB           ,11.9                                     ,""           ,0            ,inf         ,"Relative dielectric constant of the channel material" )
`MPRoo( EPSROX            ,3.9                                      ,""           ,0            ,inf         ,"Relative dielectric constant of the gate dielectric" )
`MPRnb( XJ                ,1.5e-7                                   ,"m"                                     ,"S/D junction depth" )
`MPRnb( LXJ               ,0.0                                      ,"m^2"                                   ,"Length dependence of XJ " )
`MPRnb( WXJ               ,0.0                                      ,"m^2"                                   ,"Width dependence of XJ" )
`MPRnb( PXJ               ,0.0                                      ,"m^3"                                   ,"Area dependence of XJ" )
`MPRnb( VFB               ,-0.5                                     ,"V"                                     ,"Flat band voltage " )
`MPRnb( LVFB              ,0.0                                      ,"V*m"                                   ,"Length dependence of VFB" )
`MPRnb( WVFB              ,0.0                                      ,"V*m"                                   ,"Width dependence of VFB" )
`MPRnb( PVFB              ,0.0                                      ,"V*m^2"                                 ,"Area dependence of VFB" )
`MPRnb( VFBCV             ,VFB                                      ,"V"                                     ,"Flat band voltage for CV" )
`MPRnb( LVFBCV            ,LVFB                                     ,"V*m"                                   ,"Length dependence of VFBCV" )
`MPRnb( WVFBCV            ,WVFB                                     ,"V*m"                                   ,"Width dependence of VFBCV" )
`MPRnb( PVFBCV            ,PVFB                                     ,"V*m^2"                                 ,"Area dependence of VFBCV" )
`MPRnb( VFBCVL            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of VFBCV" )
`MPRoz( VFBCVLEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of VFBCV" )
`MPRnb( VFBCVW            ,0.0                                      ,"m"                                     ,"Width dependence coefficient of VFBCV" )
`MPRoz( VFBCVWEXP         ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of VFBCV" )
`MPRnb( VFBCVWL           ,0.0                                      ,"m^2"                                   ,"Width-Length dependence coefficient of VFBCV" )
`MPRoz( VFBCVWLEXP        ,1.0                                      ,""                                      ,"Width-Length dependence coefficient of VFBCV" )

// Diode parameters
`MPIcc( PERMOD            ,1                                        ,""           ,0            ,1           ,"Whether PS/PD (when given) include gate-edge perimeter" )
`MPRnb( DWJ               ,DWC                                      ,"m"                                     ,"delta W for S/D junctions" )

// Short channel effects
`MPRnb( NSD               ,1e26                                     ,"1/m^3"                                 ,"S/D Doping Concentration" )
`MPRnb( LNSD              ,0.0                                      ,"1/m^2"                                 ,"Length dependence of NSD" )
`MPRnb( WNSD              ,0.0                                      ,"1/m^2"                                 ,"Width dependence of NSD" )
`MPRnb( PNSD              ,0.0                                      ,"1/m"                                   ,"Area dependence of NSD" )
`MPRnb( DVTP0             ,0.0                                      ,"m"                                     ,"DITS" )
`MPRnb( LDVTP0            ,0                                        ,"m^2"                                   ,"Length dependence of DVTP0" )
`MPRnb( WDVTP0            ,0                                        ,"m^2"                                   ,"Width dependence of DVTP0" )
`MPRnb( PDVTP0            ,0                                        ,"m^3"                                   ,"Area dependence of DVTP0" )
`MPRnb( DVTP1             ,0.0                                      ,"1/V"                                   ,"DITS" )
`MPRnb( LDVTP1            ,0                                        ,"m/V"                                   ,"Length dependence of DVTP1" )
`MPRnb( WDVTP1            ,0                                        ,"m/V"                                   ,"Width dependence of DVTP1" )
`MPRnb( PDVTP1            ,0                                        ,"m^2/V"                                 ,"Area dependence of DVTP1" )
`MPRnb( DVTP2             ,0.0                                      ,"m*V"                                    ,"DITS" )
`MPRnb( LDVTP2            ,0                                        ,"m^2/V"                                 ,"Length dependence of DVTP2" )
`MPRnb( WDVTP2            ,0                                        ,"m^2/V"                                 ,"Width dependence of DVTP2" )
`MPRnb( PDVTP2            ,0                                        ,"m^3/V"                                 ,"Area dependence of DVTP2" )
`MPRnb( DVTP3             ,0.0                                      ,""                                      ,"DITS" )
`MPRnb( LDVTP3            ,0                                        ,"m"                                     ,"Length dependence of DVTP3" )
`MPRnb( WDVTP3            ,0                                        ,"m"                                     ,"Width dependence of DVTP3" )
`MPRnb( PDVTP3            ,0                                        ,"m^2"                                   ,"Area dependence of DVTP3" )
`MPRnb( DVTP4             ,0.0                                      ,"1/V"                                   ,"DITS" )
`MPRnb( LDVTP4            ,0                                        ,"m/V"                                   ,"Length dependence of DVTP4" )
`MPRnb( WDVTP4            ,0                                        ,"m/V"                                   ,"Width dependence of DVTP4" )
`MPRnb( PDVTP4            ,0                                        ,"m^2/V"                                 ,"Area dependence of DVTP4" )
`MPRnb( DVTP5             ,0.0                                      ,"V"                                     ,"DITS" )
`MPRnb( LDVTP5            ,0                                        ,"m*V"                                   ,"Length dependence of DVTP5" )
`MPRnb( WDVTP5            ,0                                        ,"m*V"                                   ,"Width dependence of DVTP5" )
`MPRnb( PDVTP5            ,0                                        ,"m^2*V"                                 ,"Area dependence of DVTP5" )
`MPRnb( PHIN              ,0.045                                    ,"V"                                     ,"Non-uniform vertical doping effect on surface potential" )
`MPRnb( LPHIN             ,0.0                                      ,"m*V"                                   ,"Length dependence of PHIN" )
`MPRnb( WPHIN             ,0.0                                      ,"m*V"                                   ,"Width dependence of PHIN" )
`MPRnb( PPHIN             ,0.0                                      ,"m^2*V"                                 ,"Area dependence of PHIN" )
`MPRnb( ETA0              ,0.08                                     ,""                                      ,"DIBL coefficient" )
`MPRnb( LETA0             ,0.0                                      ,"m"                                     ,"Length dependence of ETA0" )
`MPRnb( WETA0             ,0.0                                      ,"m"                                     ,"Width dependence of ETA0" )
`MPRnb( PETA0             ,0.0                                      ,"m^2"                                   ,"Area dependence of ETA0" )
`MPRnb( ETA0R             ,ETA0                                     ,""                                      ,"DIBL coefficient" )
`MPRnb( LETA0R            ,LETA0                                    ,"m"                                     ,"Length dependence of ETA0R" )
`MPRnb( WETA0R            ,WETA0                                    ,"m"                                     ,"Width dependence of ETA0R" )
`MPRnb( PETA0R            ,PETA0                                    ,"m^2"                                   ,"Area dependence of ETA0R" )
`MPRnb( DSUB              ,1.0                                      ,""                                      ,"Length scaling exponent for DIBL" )
`MPRnb( ETAB              ,-0.07                                    ,"1/V"                                   ,"Body bias coefficient for sub-threshold DIBL effect" )
`MPRoz( ETABEXP           ,1.0                                      ,""                                      ,"Exponent coefficient of ETAB" )
`MPRnb( LETAB             ,0.0                                      ,"m/V"                                   ,"Length dependence of ETAB" )
`MPRnb( WETAB             ,0.0                                      ,"m/V"                                   ,"Width dependence of ETAB" )
`MPRnb( PETAB             ,0.0                                      ,"m^2/V"                                 ,"Area dependence of ETAB" )
`MPRnb( K1                ,0.0                                      ,"V^0.5"                                 ,"First-order body-bias Vth shift due to Vertical Non-uniform doping" )
`MPRnb( K1L               ,0.0                                      ,""                                      ,"length dependence coefficient of K1" )
`MPRoz( K1LEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of K1" )
`MPRnb( K1W               ,0.0                                      ,""                                      ,"Width dependence coefficient of K1" )
`MPRoz( K1WEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of K1" )
`MPRnb( K1WL              ,0.0                                      ,""                                      ,"Width-Length dependence coefficient of K1" )
`MPRoz( K1WLEXP           ,1.0                                      ,""                                      ,"Width-Length dependence exponent coefficient of K1" )
`MPRnb( LK1               ,0.0                                      ,"m*V^0.5"                               ,"Length dependence of K1" )
`MPRnb( WK1               ,0.0                                      ,"m*V^0.5"                               ,"Width dependence of K1" )
`MPRnb( PK1               ,0.0                                      ,"m^2*V^0.5"                             ,"Area dependence of K1" )
`MPRnb( K2                ,0.0                                      ,"V"                                     ,"Vth shift due to Vertical Non-uniform doping" )
`MPRnb( K2L               ,0.0                                      ,"m^K2LEXP"                              ,"Length dependence coefficient of K2" )
`MPRoz( K2LEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of K2" )
`MPRnb( K2W               ,0.0                                      ,"m^K2WEXP"                              ,"Width dependence coefficient of K2" )
`MPRoz( K2WEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of K2" )
`MPRnb( K2WL              ,0.0                                      ,"m^(2*K2WLEXP)"                         ,"Width-Length dependence coefficient of K2" )
`MPRoz( K2WLEXP           ,1.0                                      ,""                                      ,"Width-Length dependence exponent coefficient of K2" )
`MPRnb( LK2               ,0.0                                      ,"m"                                     ,"Length dependence  of K2" )
`MPRnb( WK2               ,0.0                                      ,"m"                                     ,"Width dependence  of K2" )
`MPRnb( PK2               ,0.0                                      ,"m^2"                                   ,"Area dependence of K2" )

// Quantum mechanical effects
`MPRcz( ADOS              ,0.0                                      ,""                                      ,"Quantum mechanical effect pre-factor cum switch in inversion" )
`MPRcz( BDOS              ,1.0                                      ,""                                      ,"Charge centroid parameter - slope of CV curve under QME in inversion" )
`MPRoz( QM0               ,1.0e-3                                   ,""                                      ,"Charge centroid parameter - starting point for QME in inversion" )
`MPRcz( ETAQM             ,0.54                                     ,""                                      ,"Bulk charge coefficient for charge centroid in inversion" )

// Sub-threshold swing factor
`MPRnb( CIT               ,0.0                                      ,"F/m^2"                                 ,"Parameter for interface trap" )
`MPRnb( LCIT              ,0.0                                      ,"F/m"                                   ,"Length dependence of CIT" )
`MPRnb( WCIT              ,0.0                                      ,"F/m"                                   ,"Width dependence  of CIT" )
`MPRnb( PCIT              ,0.0                                      ,"F"                                     ,"Area dependence  of CIT" )
`MPRnb( NFACTOR           ,0.0                                      ,""                                      ,"Sub-threshold slope factor" )
`MPRnb( NFACTORL          ,0.0                                      ,"m^NFACTORLEXP"                         ,"Length dependence coefficient of NFACTOR" )
`MPRoz( NFACTORLEXP       ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of NFACTOR" )
`MPRnb( NFACTORW          ,0.0                                      ,"m^NFACTORWEXP"                         ,"Width dependence coefficient of NFACTOR" )
`MPRoz( NFACTORWEXP       ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of NFACTOR" )
`MPRnb( NFACTORWL         ,0.0                                      ,"m^(2*NFACTORWLEXP)"                    ,"Width-Length dependence coefficient of NFACTOR" )
`MPRoz( NFACTORWLEXP      ,1.0                                      ,""                                      ,"Width-Length dependence exponent coefficient of NFACTOR" )
`MPRnb( LNFACTOR          ,0.0                                      ,"m"                                     ,"Length dependence of NFACTOR" )
`MPRnb( WNFACTOR          ,0.0                                      ,"m"                                     ,"Width dependence  of NFACTOR" )
`MPRnb( PNFACTOR          ,0.0                                      ,"m^2"                                   ,"Area dependence  of NFACTOR" )
`MPRnb( CDSCD             ,1e-9                                     ,"F/m^2/V"                               ,"Drain-bias sensitivity of sub-threshold slope" )
`MPRnb( CDSCDL            ,0.0                                      ,"m^CDSCDLEXP"                           ,"Length dependence coefficient of CDSCD" )
`MPRoz( CDSCDLEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of CDSCD" )
`MPRnb( LCDSCD            ,0.0                                      ,"F/m/V"                                 ,"Length dependence of CDSCD" )
`MPRnb( WCDSCD            ,0.0                                      ,"F/m/V"                                 ,"Width dependence  of CDSCD" )
`MPRnb( PCDSCD            ,0.0                                      ,"F/V"                                   ,"Area dependence  of CDSCD" )
`MPRnb( CDSCDR            ,CDSCD                                    ,"F/m^2/V"                               ,"Drain-bias sensitivity of sub-threshold slope" )
`MPRnb( CDSCDLR           ,CDSCDL                                   ,"m^CDSCDLEXP"                           ,"Length dependence coefficient of CDSCD" )
`MPRnb( LCDSCDR           ,LCDSCD                                   ,"F/m/V"                                 ,"Length dependence of CDSCDR" )
`MPRnb( WCDSCDR           ,WCDSCD                                   ,"F/m/V"                                 ,"Width dependence  of CDSCDR" )
`MPRnb( PCDSCDR           ,PCDSCD                                   ,"F/V"                                   ,"Area dependence  of CDSCDR" )
`MPRnb( CDSCB             ,0.0                                      ,"F/m^2/V"                               ,"Body-bias sensitivity of sub-threshold slope" )
`MPRnb( CDSCBL            ,0.0                                      ,"m^CDSCBLEXP"                           ,"Length dependence coefficient of CDSCB" )
`MPRoz( CDSCBLEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of CDSCB" )
`MPRnb( LCDSCB            ,0.0                                      ,"F/m/V"                                 ,"Length dependence of CDSCB" )
`MPRnb( WCDSCB            ,0.0                                      ,"F/m/V"                                 ,"Width dependence  of CDSCB" )
`MPRnb( PCDSCB            ,0.0                                      ,"F/V"                                   ,"Area dependence  of CDSCB" )

// Drain saturation voltage
`MPRnb( VSAT              ,1e5                                      ,"m/s"                                   ,"Saturation Velocity" )
`MPRnb( LVSAT             ,0.0                                      ,"m^2/s"                                 ,"Length dependence of VSAT" )
`MPRnb( WVSAT             ,0.0                                      ,"m^2/s"                                 ,"Width dependence  of VSAT" )
`MPRnb( PVSAT             ,0.0                                      ,"m^3/s"                                 ,"Area dependence  of VSAT" )
`MPRnb( VSATL             ,0.0                                      ,"m^VSATLEXP"                            ,"Length dependence coefficient of of VSAT" )
`MPRoz( VSATLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of VSAT" )
`MPRnb( VSATW             ,0.0                                      ,"m^VSATWEXP"                            ,"Width dependence coefficient of of VSAT" )
`MPRoz( VSATWEXP          ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of of VSAT" )
`MPRnb( VSATWL            ,0.0                                      ,"m^(2*VSATWLEXP)"                       ,"Width-Length dependence coefficient of of VSAT" )
`MPRoz( VSATWLEXP         ,1.0                                      ,""                                      ,"Width-Length dependence exponent coefficient of of VSAT" )
`MPRnb( VSATR             ,VSAT                                     ,"m/s"                                   ,"Saturation Velocity" )
`MPRnb( LVSATR            ,LVSAT                                    ,"m^2/s"                                 ,"Length dependence of VSATR" )
`MPRnb( WVSATR            ,WVSAT                                    ,"m^2/s"                                 ,"Width dependence  of VSATR" )
`MPRnb( PVSATR            ,PVSAT                                    ,"m^3/s"                                 ,"Area dependence  of VSATR" )
`MPRnb( DELTA             ,0.125                                    ,""                                      ,"Smoothing function factor for Vdsat" )
`MPRnb( LDELTA            ,0.0                                      ,"m"                                     ,"Length dependence of DELTA" )
`MPRnb( WDELTA            ,0.0                                      ,"m"                                     ,"Width dependence of DELTA" )
`MPRnb( PDELTA            ,0.0                                      ,"m^2"                                   ,"Area dependence  of DELTA" )
`MPRnb( DELTAL            ,0.0                                      ,"m^DELTALEXP"                           ,"Length dependence coefficient of DELTA" )
`MPRoz( DELTALEXP         ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of DELTA" )
`MPRnb( VSATCV            ,VSAT                                     ,"m/s"                                   ,"VSAT parameter for CV" )
`MPRnb( LVSATCV           ,LVSAT                                    ,"m^2/s"                                 ,"Length dependence of VSATCV" )
`MPRnb( WVSATCV           ,WVSAT                                    ,"m^2/s"                                 ,"Width dependence  of VSATCV" )
`MPRnb( PVSATCV           ,PVSAT                                    ,"m^3/s"                                 ,"Area dependence  of VSATCV" )
`MPRnb( VSATCVL           ,VSATL                                    ,"m^VSATCVLEXP"                          ,"Length dependence coefficient of VSATCV" )
`MPRoz( VSATCVLEXP        ,VSATLEXP                                 ,""                                      ,"Length dependence exponent coefficient of VSATCV" )
`MPRnb( VSATCVW           ,VSATW                                    ,"m^VSATCVWEXP"                          ,"Width dependence coefficient of VSATCV" )
`MPRoz( VSATCVWEXP        ,VSATWEXP                                 ,""                                      ,"Width dependence exponent coefficient of VSATCV" )
`MPRnb( VSATCVWL          ,VSATWL                                   ,"m^(2*VSATCVWLEXP)"                     ,"Width-Length dependence coefficient of VSATCV" )
`MPRoz( VSATCVWLEXP       ,VSATWLEXP                                ,""                                      ,"Width-Length dependence exponent coefficient of VSATCV" )

// Mobility degradation
`MPRoo( UP1               ,0.0                                      ,""            ,-inf        ,inf         ,"Mobility channel length coefficient" )
`MPRex( LP1               ,1.0e-8                                   ,"m"            ,0.0                     ,"Mobility channel length exponential coefficient" )
`MPRoo( UP2               ,0.0                                      ,""            ,-inf        ,inf         ,"Mobility channel length coefficient" )
`MPRex( LP2               ,1.0e-8                                   ,"m"            ,0.0                     ,"Mobility channel length exponential coefficient" )
`MPRnb( U0                ,67.0e-3                                  ,"m^2/V/s"                               ,"Low Field mobility." )
`MPRnb( U0L               ,0.0                                      ,"m^U0LEXP"                              ,"Length dependence coefficient of U0L" )
`MPRoz( U0LEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of U0L" )
`MPRnb( LU0               ,0.0                                      ,"m^3/V/s"                               ,"Length dependence of U0" )
`MPRnb( WU0               ,0.0                                      ,"m^3/V/s"                               ,"Width dependence  of U0" )
`MPRnb( PU0               ,0.0                                      ,"m^4/V/s"                               ,"Area dependence  of U0" )
`MPRnb( U0R               ,U0                                       ,"m2/V/s"                                ,"Reverse-mode Low Field mobility." )
`MPRnb( LU0R              ,LU0                                      ,"m^3/V/s"                               ,"Length dependence of U0R" )
`MPRnb( WU0R              ,WU0                                      ,"m^3/V/s"                               ,"Width dependence  of U0R" )
`MPRnb( PU0R              ,PU0                                      ,"m^4/V/s"                               ,"Area dependence  of U0R" )
`MPRnb( ETAMOB            ,1.0                                      ,""                                      ,"Effective field parameter (should be kept close to 1)" )
`MPRnb( UA                ,0.001                                    ,"(m/V)^EU"                              ,"Mobility reduction coefficient" )
`MPRnb( UAL               ,0.0                                      ,"m^UALEXP"                              ,"Length dependence coefficient of  UA" )
`MPRoz( UALEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of  UA" )
`MPRnb( UAW               ,0.0                                      ,"m^UAWEXP"                              ,"Width dependence coefficient of UA" )
`MPRoz( UAWEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of UA" )
`MPRnb( UAWL              ,0.0                                      ,"m^UAWLEXP"                             ,"Width-Length dependence coefficient of UA" )
`MPRoz( UAWLEXP           ,1.0                                      ,""                                      ,"Width-Length dependence coefficient of UA" )
`MPRnb( LUA               ,0.0                                      ,"m*(m/V)^EU"                            ,"Length dependence of UA" )
`MPRnb( WUA               ,0.0                                      ,"m*(m/V)^EU"                            ,"Width dependence  of UA" )
`MPRnb( PUA               ,0.0                                      ,"m^2*(m/V)^EU"                          ,"Area dependence  of UA" )
`MPRnb( UAR               ,UA                                       ,"(m/V)^EU"                              ,"Reverse-mode Mobility reduction coefficient" )
`MPRnb( LUAR              ,LUA                                      ,"m*(m/V)^EU"                            ,"Length dependence of UAR" )
`MPRnb( WUAR              ,WUA                                      ,"m*(m/V)^EU"                            ,"Width dependence  of UAR" )
`MPRnb( PUAR              ,PUA                                      ,"m^2*(m/V)^EU"                          ,"Area dependence  of UAR" )
`MPRnb( EU                ,1.5                                      ,""                                      ,"Mobility reduction exponent" )
`MPRnb( LEU               ,0.0                                      ,"m"                                     ,"Length dependence of EU" )
`MPRnb( WEU               ,0.0                                      ,"m"                                     ,"Width dependence  of EU" )
`MPRnb( PEU               ,0.0                                      ,"m^2"                                   ,"Area dependence  of EU" )
`MPRnb( EUL               ,0.0                                      ,"m^EULEXP"                              ,"Length dependence coefficient of EU" )
`MPRoz( EULEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of EU" )
`MPRnb( EUW               ,0.0                                      ,"m^EUWEXP"                              ,"Width dependence coefficient of EU" )
`MPRoz( EUWEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of EU" )
`MPRnb( EUWL              ,0.0                                      ,"m^EUWLEXP"                             ,"Width-Length dependence coefficient of EU" )
`MPRoz( EUWLEXP           ,1.0                                      ,""                                      ,"Width-Length dependence coefficient of EU" )
`MPRnb( UD                ,0.001                                    ,""                                      ,"Coulomb scattering parameter" )
`MPRnb( UDL               ,0.0                                      ,"m^UDLEXP"                              ,"Length dependence coefficient of UD" )
`MPRoz( UDLEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of UD" )
`MPRnb( LUD               ,0.0                                      ,"m"                                     ,"Length dependence of UD" )
`MPRnb( WUD               ,0.0                                      ,"m"                                     ,"Width dependence  of UD" )
`MPRnb( PUD               ,0.0                                      ,"m^2"                                   ,"Area dependence  of UD" )
`MPRnb( UDR               ,UD                                       ,""                                      ,"Reverse-mode Coulomb scattering parameter" )
`MPRnb( LUDR              ,LUD                                      ,"m"                                     ,"Length dependence of UDR" )
`MPRnb( WUDR              ,WUD                                      ,"m"                                     ,"Width dependence  of UDR" )
`MPRnb( PUDR              ,PUD                                      ,"m^2"                                   ,"Area dependence  of UDR" )
`MPRnb( UCS               ,2.0                                      ,""                                      ,"Coulomb scattering parameter" )
`MPRnb( LUCS              ,0.0                                      ,"m"                                     ,"Length dependence of UCS" )
`MPRnb( WUCS              ,0.0                                      ,"m"                                     ,"Width dependence  of UCS" )
`MPRnb( PUCS              ,0.0                                      ,"m^2"                                   ,"Area dependence  of UCS" )
`MPRnb( UCSR              ,UCS                                      ,""                                      ,"Reverse-mode Coulomb scattering parameter" )
`MPRnb( LUCSR             ,LUCS                                     ,"m"                                     ,"Length dependence of UCSR" )
`MPRnb( WUCSR             ,WUCS                                     ,"m"                                     ,"Width dependence  of UCSR" )
`MPRnb( PUCSR             ,PUCS                                     ,"m^2"                                   ,"Area dependence  of UCSR" )
`MPRnb( UC                ,0.0                                      ,"(m/V)^EU/V"                            ,"Mobility reduction with body bias" )
`MPRnb( UCL               ,0.0                                      ,"m^UCLEXP"                              ,"Length dependence coefficient of UC" )
`MPRoz( UCLEXP            ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of UC" )
`MPRnb( UCW               ,0.0                                      ,"m^UCWEXP"                              ,"Width dependence coefficient of UC" )
`MPRoz( UCWEXP            ,1.0                                      ,""                                      ,"Width dependence exponent coefficient of UC" )
`MPRnb( UCWL              ,0.0                                      ,"m^(2*UCWLEXP)"                         ,"Width-Length dependence coefficient of UC" )
`MPRoz( UCWLEXP           ,1.0                                      ,""                                      ,"Width-Length dependence exponent coefficient of UC" )
`MPRnb( LUC               ,0.0                                      ,"m*(m/V)^EU/V"                          ,"Length dependence of UC" )
`MPRnb( WUC               ,0.0                                      ,"m*(m/V)^EU/V"                          ,"Width dependence  of UC" )
`MPRnb( PUC               ,0.0                                      ,"m^2*(m/V)^EU/V"                        ,"Area dependence  of UC" )
`MPRnb( UCR               ,UC                                       ,"(m/V)^EU/V"                            ,"Reverse-mode Mobility reduction with body bias" )
`MPRnb( LUCR              ,LUC                                      ,"m*(m/V)^EU/V"                          ,"Length dependence of UCR" )
`MPRnb( WUCR              ,WUC                                      ,"m*(m/V)^EU/V"                          ,"Width dependence  of UCR" )
`MPRnb( PUCR              ,PUC                                      ,"m^2*(m/V)^EU/V"                        ,"Area dependence  of UCR" )

// Channel length modulation
`MPRnb( PCLM              ,0.0                                      ,""                                      ,"CLM pre-factor" )
`MPRnb( PCLML             ,0.0                                      ,"m^PCLMLEXP"                            ,"Length dependence coefficient of PCLM" )
`MPRoz( PCLMLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PCLM" )
`MPRnb( LPCLM             ,0.0                                      ,"m"                                     ,"Length dependence of PCLM" )
`MPRnb( WPCLM             ,0.0                                      ,"m"                                     ,"Width dependence  of PCLM" )
`MPRnb( PPCLM             ,0.0                                      ,"m^2"                                   ,"Area dependence  of PCLM" )
`MPRnb( PCLMR             ,PCLM                                     ,""                                      ,"Reverse-mode CLM pre-factor" )
`MPRnb( LPCLMR            ,LPCLM                                    ,"m"                                     ,"Length dependence of PCLMR" )
`MPRnb( WPCLMR            ,WPCLM                                    ,"m"                                     ,"Width dependence  of PCLMR" )
`MPRnb( PPCLMR            ,PPCLM                                    ,"m^2"                                   ,"Area dependence  of PCLMR" )
`MPRnb( PCLMG             ,0.0                                      ,"V"                                     ,"CLM pre-factor gate voltage dependence" )
`MPRnb( PCLMCV            ,PCLM                                     ,""                                      ,"CLM parameter for CV" )
`MPRnb( PCLMCVL           ,PCLML                                    ,"m^PCLMLEXP"                            ,"Length dependence coefficient of PCLMCV" )
`MPRoz( PCLMCVLEXP        ,PCLMLEXP                                 ,""                                      ,"Length dependence exponent coefficient of PCLMCV" )
`MPRnb( LPCLMCV           ,LPCLM                                    ,"m"                                     ,"Length dependence of PCLMCV" )
`MPRnb( WPCLMCV           ,WPCLM                                    ,"m"                                     ,"Width dependence  of PCLMCV" )
`MPRnb( PPCLMCV           ,PPCLM                                    ,"m^2"                                   ,"Area dependence  of PCLMCV" )
`MPRnb( PSCBE1            ,4.24e8                                   ,"V/m"                                   ,"Substrate current body-effect coefficient" )
`MPRnb( LPSCBE1           ,0.0                                      ,"V"                                     ,"Length dependence of PSCBE1" )
`MPRnb( WPSCBE1           ,0.0                                      ,"V"                                     ,"Width dependence  of PSCBE1" )
`MPRnb( PPSCBE1           ,0.0                                      ,"V*m"                                   ,"Area dependence  of PSCBE1" )
`MPRnb( PSCBE2            ,1.0e-8                                   ,"m/V"                                   ,"Substrate current body-effect coefficient" )
`MPRnb( LPSCBE2           ,0.0                                      ,"m^2/V"                                 ,"Length dependence of PSCBE2" )
`MPRnb( WPSCBE2           ,0.0                                      ,"m^2/V"                                 ,"Width dependence  of PSCBE2" )
`MPRnb( PPSCBE2           ,0.0                                      ,"m^3/V"                                 ,"Area dependence  of PSCBE2" )
`MPRnb( PDITS             ,0.0                                      ,"1/V"                                   ,"Coefficient for drain-induced Vth shift" )
`MPRnb( LPDITS            ,0.0                                      ,"m/V"                                   ,"Length dependence of PDITS" )
`MPRnb( WPDITS            ,0.0                                      ,"m/V"                                   ,"Width dependence  of PDITS" )
`MPRnb( PPDITS            ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of PDITS" )
`MPRcz( PDITSL            ,0.0                                      ,"1/m"                                   ,"L dependence of drain-induced Vth shift" )
`MPRnb( PDITSD            ,0.0                                      ,"1/V"                                   ,"Vds dependence of drain-induced Vth shift" )
`MPRnb( LPDITSD           ,0.0                                      ,"m/V"                                   ,"Length dependence of PDITSD" )
`MPRnb( WPDITSD           ,0.0                                      ,"m/V"                                   ,"Width dependence  of PDITSD" )
`MPRnb( PPDITSD           ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of PDITSD" )

// S/D series resistance
`MPRcz( RSH               ,0.0                                      ,"ohm/square"                            ,"Source-drain sheet resistance" )
`MPRnb( PRWG              ,1.0                                      ,"1/V"                                   ,"Gate bias dependence of S/D extension resistance" )
`MPRnb( LPRWG             ,0.0                                      ,"m/V"                                   ,"Length dependence of PRWG" )
`MPRnb( WPRWG             ,0.0                                      ,"m/V"                                   ,"Width dependence  of PRWG" )
`MPRnb( PPRWG             ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of PRWG" )
`MPRnb( PRWB              ,0.0                                      ,"1/V"                                   ,"Body bias dependence of resistance" )
`MPRnb( LPRWB             ,0.0                                      ,"m/V"                                   ,"Length dependence of PRWB" )
`MPRnb( WPRWB             ,0.0                                      ,"m/V"                                   ,"Width dependence  of PRWB" )
`MPRnb( PPRWB             ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of PRWB" )
`MPRnb( PRWBL             ,0.0                                      ,"m^PRWBLEXP"                            ,"Length dependence coefficient of PPRWB" )
`MPRoz( PRWBLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PPRWB" )
`MPRnb( WR                ,1.0                                      ,""                                      ,"W dependence parameter of S/D extension resistance" )
`MPRnb( LWR               ,0.0                                      ,"m"                                     ,"Length dependence of WR" )
`MPRnb( WWR               ,0.0                                      ,"m"                                     ,"Width dependence  of WR" )
`MPRnb( PWR               ,0.0                                      ,"m^2"                                   ,"Area dependence  of WR" )
`MPRnb( RSWMIN            ,0.0                                      ,"ohm*m^WR"                              ,"Source Resistance per unit width at high Vgs (RDSMOD=1)" )
`MPRnb( LRSWMIN           ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RSWMIN" )
`MPRnb( WRSWMIN           ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence  of RSWMIN" )
`MPRnb( PRSWMIN           ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence  of RSWMIN" )
`MPRnb( RSW               ,10.0                                     ,"ohm*m^WR"                              ,"Zero bias Source Resistance (RDSMOD=1)" )
`MPRnb( LRSW              ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RSW" )
`MPRnb( WRSW              ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence  of RSW" )
`MPRnb( PRSW              ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence  of RSW" )
`MPRnb( RSWL              ,0.0                                      ,"m^RSWLEXP"                             ,"Geometrical scaling of RSW (RDSMOD=1)" )
`MPRoz( RSWLEXP           ,1.0                                      ,""                                      ,"Geometrical scaling of RSW (RDSMOD=1)" )
`MPRnb( RDWMIN            ,RSWMIN                                   ,"ohm*m^WR"                              ,"Drain Resistance per unit width at high Vgs (RDSMOD=1)" )
`MPRnb( LRDWMIN           ,LRSWMIN                                  ,"ohm*m^(2*WR)"                          ,"Length dependence of RDWMIN" )
`MPRnb( WRDWMIN           ,WRSWMIN                                  ,"ohm*m^(2*WR)"                          ,"Width dependence  of RDWMIN" )
`MPRnb( PRDWMIN           ,PRSWMIN                                  ,"ohm*m^(3*WR)"                          ,"Area dependence  of RDWMIN" )
`MPRnb( RDW               ,RSW                                      ,"ohm*m^WR"                              ,"zero bias Drain Resistance (RDSMOD=1)" )
`MPRnb( LRDW              ,LRSW                                     ,"ohm*m^(2*WR)"                          ,"Length dependence of RDW" )
`MPRnb( WRDW              ,WRSW                                     ,"ohm*m^(2*WR)"                          ,"Width dependence  of RDW" )
`MPRnb( PRDW              ,PRSW                                     ,"ohm*m^(3*WR)"                          ,"Area dependence  of RDW" )
`MPRnb( RDWL              ,RSWL                                     ,"m^RDWLEXP"                             ,"Geometrical scaling of RDW (RDSMOD=1)" )
`MPRoz( RDWLEXP           ,RSWLEXP                                  ,""                                      ,"Geometrical scaling of RDW (RDSMOD=1)" )
`MPRnb( RDSWMIN           ,0.0                                      ,"ohm*m^WR"                              ,"S/D Resistance per unit width at high Vgs (RDSMOD=0 and RDSMOD=2)" )
`MPRnb( LRDSWMIN          ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RDSWMIN " )
`MPRnb( WRDSWMIN          ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence  of RDSWMIN " )
`MPRnb( PRDSWMIN          ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence  of RDSWMIN " )
`MPRnb( RDSW              ,20.0                                     ,"ohm*um^WR"                             ,"Zero bias Resistance (RDSMOD=0 and RDSMOD=2)" )
`MPRnb( RDSWL             ,0.0                                      ,"m^RDSWLEXP"                            ,"Geometrical scaling of RDSW (RDSMOD=0 and RDSMOD=2)" )
`MPRoz( RDSWLEXP          ,1.0                                      ,""                                      ,"Geometrical scaling of RDSW (RDSMOD=0 and RDSMOD=2)" )
`MPRnb( LRDSW             ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Length dependence of RDSW" )
`MPRnb( WRDSW             ,0.0                                      ,"ohm*m^(2*WR)"                          ,"Width dependence  of RDSW" )
`MPRnb( PRDSW             ,0.0                                      ,"ohm*m^(3*WR)"                          ,"Area dependence  of RDSW " )

// Velocity saturation
`MPRnb( PSAT              ,1.0                                      ,""                                      ,"Gmsat variation with gate bias" )
`MPRnb( LPSAT             ,0.0                                      ,"m"                                     ,"Length dependence of PSAT" )
`MPRnb( WPSAT             ,0.0                                      ,"m"                                     ,"Width dependence  of PSAT" )
`MPRnb( PPSAT             ,0.0                                      ,"m^2"                                   ,"Area dependence  of PSAT" )
`MPRnb( PSATL             ,0.0                                      ,"m^PSATLEXP"                            ,"Length dependence coefficient of PSATL" )
`MPRoz( PSATLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PSATLEXP" )
`MPRnb( PSATB             ,0.0                                      ,"1/V"                                   ,"Body bias effect on Idsat" )
`MPRnb( PSATR             ,PSAT                                     ,""                                      ,"Reverse-mode Gmsat variation with gate bias" )
`MPRnb( LPSATR            ,LPSAT                                    ,"m"                                     ,"Length dependence of PSATR" )
`MPRnb( WPSATR            ,WPSAT                                    ,"m"                                     ,"Width dependence  of PSATR" )
`MPRnb( PPSATR            ,PPSAT                                    ,"m^2"                                   ,"Area dependence  of PSATR" )
`MPRnb( LPSATB            ,0.0                                      ,"m/V"                                   ,"Length dependence of PSATB" )
`MPRnb( WPSATB            ,0.0                                      ,"m/V"                                   ,"Width dependence  of PSATB" )
`MPRnb( PPSATB            ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of PSATB" )
`MPRoz( PSATX             ,1.0                                      ,""                                      ,"Fine tuning of PTWG effect" )
`MPRnb( PTWG              ,0.0                                      ,""                                      ,"Idsat variation with gate bias" )
`MPRnb( LPTWG             ,0.0                                      ,"m"                                     ,"Length dependence of PTWG" )
`MPRnb( WPTWG             ,0.0                                      ,"m"                                     ,"Width dependence  of PTWG" )
`MPRnb( PPTWG             ,0.0                                      ,"m^2"                                   ,"Area dependence  of PTWG" )
`MPRnb( PTWGL             ,0.0                                      ,"m^PTWGLEXP"                            ,"Length dependence coefficient of PTWG" )
`MPRoz( PTWGLEXP          ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PTWG" )
`MPRnb( PTWGR             ,PTWG                                     ,""                                      ,"Reverse-mode Idsat variation with gate bias" )
`MPRnb( LPTWGR            ,LPTWG                                    ,"m"                                     ,"Length dependence of PTWGR" )
`MPRnb( WPTWGR            ,WPTWG                                    ,"m"                                     ,"Width dependence  of PTWGR" )
`MPRnb( PPTWGR            ,PPTWG                                    ,"m^2"                                   ,"Area dependence  of PTWGR" )
`MPRnb( PTWGLR            ,PTWGL                                    ,"m^PTWGLEXPR"                           ,"Length dependence coefficient of PTWG" )
`MPRoz( PTWGLEXPR         ,PTWGLEXP                                 ,""                                      ,"Length dependence exponent coefficient of PTWG" )

// Velocity non-saturation effect
`MPRnb( A1                ,0.0                                      ,"1/V^2"                                 ,"Non-saturation effect parameter for strong inversion region" )
`MPRnb( LA1               ,0.0                                      ,"m/V^2"                                 ,"Length dependence of A1" )
`MPRnb( WA1               ,0.0                                      ,"m/V^2"                                 ,"Width dependence  of A1" )
`MPRnb( PA1               ,0.0                                      ,"m^2/V^2"                               ,"Area dependence  of A1" )
`MPRnb( A11               ,0.0                                      ,""                                      ,"Temperature dependence of A1" )
`MPRnb( LA11              ,0.0                                      ,"m"                                     ,"Length dependence of A11" )
`MPRnb( WA11              ,0.0                                      ,"m"                                     ,"Width dependence  of A11" )
`MPRnb( PA11              ,0.0                                      ,"m^2"                                   ,"Area dependence  of A11" )
`MPRnb( A2                ,0.0                                      ,"1/V"                                   ,"Non-saturation effect parameter for moderate inversion region" )
`MPRnb( LA2               ,0.0                                      ,"m/V"                                   ,"Length dependence of A2" )
`MPRnb( WA2               ,0.0                                      ,"m/V"                                   ,"Width dependence  of A2" )
`MPRnb( PA2               ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of A2" )
`MPRnb( A21               ,0.0                                      ,""                                      ,"Temperature dependence of A2" )
`MPRnb( LA21              ,0.0                                      ,"m"                                     ,"Length dependence of A21" )
`MPRnb( WA21              ,0.0                                      ,"m"                                     ,"Width dependence  of A21" )
`MPRnb( PA21              ,0.0                                      ,"m^2"                                   ,"Area dependence  of A21" )

// Output conductance
`MPRnb( PDIBLC            ,0.0                                      ,""                                      ,"Parameter for DIBL effect on Rout" )
`MPRnb( PDIBLCL           ,0.0                                      ,"m^PDIBLCLEXP"                          ,"Length dependence coefficient of PDIBLC" )
`MPRoz( PDIBLCLEXP        ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of PDIBLC" )
`MPRnb( LPDIBLC           ,0.0                                      ,"m"                                     ,"Length dependence of PDIBLC" )
`MPRnb( WPDIBLC           ,0.0                                      ,"m"                                     ,"Width dependence  of PDIBLC" )
`MPRnb( PPDIBLC           ,0.0                                      ,"m^2"                                   ,"Area dependence  of PDIBLC" )
`MPRnb( PDIBLCR           ,PDIBLC                                   ,""                                      ,"Reverse-mode Parameter for DIBL effect on Rout" )
`MPRnb( PDIBLCLR          ,PDIBLCL                                  ,"m^PDIBLCLEXPR"                         ,"Length dependence coefficient of PDIBLC" )
`MPRoz( PDIBLCLEXPR       ,PDIBLCLEXP                               ,""                                      ,"Length dependence exponent coefficient of PDIBLC" )
`MPRnb( LPDIBLCR          ,LPDIBLC                                  ,"m"                                     ,"Length dependence of PDIBLCR" )
`MPRnb( WPDIBLCR          ,WPDIBLC                                  ,"m"                                     ,"Width dependence  of PDIBLCR" )
`MPRnb( PPDIBLCR          ,PPDIBLC                                  ,"m^2"                                   ,"Area dependence  of PDIBLCR" )
`MPRnb( PDIBLCB           ,0.0                                      ,"1/V"                                   ,"Parameter for DIBL effect on Rout" )
`MPRnb( LPDIBLCB          ,0.0                                      ,"m/V"                                   ,"Length dependence of PDIBLCB" )
`MPRnb( WPDIBLCB          ,0.0                                      ,"m/V"                                   ,"Width dependence  of PDIBLCB" )
`MPRnb( PPDIBLCB          ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of PDIBLCB" )
`MPRnb( PVAG              ,1.0                                      ,""                                      ,"Vg dependence of early voltage" )
`MPRnb( LPVAG             ,0.0                                      ,"m"                                     ,"Length dependence of PVAG" )
`MPRnb( WPVAG             ,0.0                                      ,"m"                                     ,"Width dependence  of PVAG" )
`MPRnb( PPVAG             ,0.0                                      ,"m^2"                                   ,"Area dependence  of PVAG" )
`MPRnb( FPROUT            ,0.0                                      ,"V/m^0.5"                               ,"gds degradation factor due to pocket implant." )
`MPRnb( FPROUTL           ,0.0                                      ,"m^FPROUTLEXP"                          ,"Length dependence coefficient of FPROUT" )
`MPRoz( FPROUTLEXP        ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of FPROUT" )
`MPRnb( LFPROUT           ,0.0                                      ,"V*m^0.5"                               ,"Length dependence of FPROUT" )
`MPRnb( WFPROUT           ,0.0                                      ,"V*m^0.5"                               ,"Width dependence  of FPROUT" )
`MPRnb( PFPROUT           ,0.0                                      ,"V*m^1.5"                               ,"Area dependence  of FPROUT" )

// Impact ionization current
`MPRnb( ALPHA0            ,0.0                                      ,"m/V"                                   ,"First parameter of Iii" )
`MPRnb( ALPHA0L           ,0.0                                      ,"m^ALPHA0LEXP"                          ,"Length dependence coefficient of ALPHA0" )
`MPRoz( ALPHA0LEXP        ,1.0                                      ,""                                      ,"Length dependence exponent coefficient of ALPHA0" )
`MPRnb( LALPHA0           ,0.0                                      ,"m^2/V"                                 ,"Length dependence of ALPHA0" )
`MPRnb( WALPHA0           ,0.0                                      ,"m^2/V"                                 ,"Width dependence  of ALPHA0" )
`MPRnb( PALPHA0           ,0.0                                      ,"m^3/V"                                 ,"Area dependence  of ALPHA0" )
`MPRnb( BETA0             ,0.0                                      ,"1/V"                                   ,"Vds dependent parameter of Iii" )
`MPRnb( LBETA0            ,0.0                                      ,"m/V"                                   ,"Length dependence of BETA0" )
`MPRnb( WBETA0            ,0.0                                      ,"m/V"                                   ,"Width dependence  of BETA0" )
`MPRnb( PBETA0            ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of BETA0" )

// Gate dielectric tunnelling current model parameters
`MPRnb( AIGBACC           ,1.36e-2                                  ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igb" )
`MPRnb( BIGBACC           ,1.71e-3                                  ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igb" )
`MPRnb( CIGBACC           ,0.075                                    ,"1/V"                                   ,"Parameter for Igb" )
`MPRnb( NIGBACC           ,1.0                                      ,""                                      ,"Parameter for Igbacc slope" )
`MPRnb( AIGBINV           ,1.11e-2                                  ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igb" )
`MPRnb( BIGBINV           ,9.49e-4                                  ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igb" )
`MPRnb( CIGBINV           ,0.006                                    ,"1/V"                                   ,"Parameter for Igb" )
`MPRnb( EIGBINV           ,1.1                                      ,"V"                                     ,"Parameter for the Si band-gap for Igbinv" )
`MPRnb( NIGBINV           ,3.0                                      ,""                                      ,"Parameter for Igbinv slope" )
`MPRnb( AIGC              ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)    ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igc" )
`MPRnb( BIGC              ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)   ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igc" )
`MPRnb( CIGC              ,((TYPE == `ntype) ? 0.075 : 0.03)        ,"1/V"                                   ,"Parameter for Igc" )
`MPRnb( AIGS              ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)    ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igs d" )
`MPRnb( BIGS              ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)   ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igs d" )
`MPRnb( CIGS              ,((TYPE == `ntype) ? 0.075 : 0.03)        ,"1/V"                                   ,"Parameter for Igs d" )
`MPRnb( AIGD              ,((TYPE == `ntype) ? 1.36e-2 : 9.8e-3)    ,"(F*s^2/g)^0.5/m"                       ,"Parameter for Igs d" )
`MPRnb( BIGD              ,((TYPE == `ntype) ? 1.71e-3 : 7.59e-4)   ,"(F*s^2/g)^0.5/m/V"                     ,"Parameter for Igs d" )
`MPRnb( CIGD              ,((TYPE == `ntype) ? 0.075 : 0.03)        ,"1/V"                                   ,"Parameter for Igs d" )
`MPRnb( DLCIG             ,LINT                                     ,"m"                                     ,"Delta L for Ig model" )
`MPRnb( DLCIGD            ,DLCIG                                    ,"m"                                     ,"Delta L for Ig model" )
`MPRnb( POXEDGE           ,1.0                                      ,""                                      ,"Factor for the gate edge Tox" )
`MPRnb( NTOX              ,1.0                                      ,""                                      ,"Exponent for Tox ratio" )
`MPRoz( TOXREF            ,3.0e-9                                   ,"m"                                     ,"Target tox value" )
`MPRcc( PIGCD             ,1.0                                      ,""            ,-50         ,50          ,"Igc, S/D partition parameter" )
`MPRnb( AIGCL             ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AIGC" )
`MPRnb( AIGCW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AIGC" )
`MPRnb( AIGSL             ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AIGS" )
`MPRnb( AIGSW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AIGS" )
`MPRnb( AIGDL             ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AIGD" )
`MPRnb( AIGDW             ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AIGD" )
`MPRnb( PIGCDL            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of PIGCD" )
`MPRnb( LAIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGBINV" )
`MPRnb( WAIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence  of AIGBINV" )
`MPRnb( PAIGBINV          ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence  of AIGBINV" )
`MPRnb( LBIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGBINV" )
`MPRnb( WBIGBINV          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence  of BIGBINV" )
`MPRnb( PBIGBINV          ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence  of BIGBINV" )
`MPRnb( LCIGBINV          ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGBINV" )
`MPRnb( WCIGBINV          ,0.0                                      ,"m/V"                                   ,"Width dependence  of CIGBINV" )
`MPRnb( PCIGBINV          ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of CIGBINV" )
`MPRnb( LEIGBINV          ,0.0                                      ,"m*V"                                   ,"Length dependence of EIGBINV" )
`MPRnb( WEIGBINV          ,0.0                                      ,"m*V"                                   ,"Width dependence  of EIGBINV" )
`MPRnb( PEIGBINV          ,0.0                                      ,"m^2*V"                                 ,"Area dependence  of EIGBINV" )
`MPRnb( LNIGBINV          ,0.0                                      ,"m"                                     ,"Length dependence of NIGBINV" )
`MPRnb( WNIGBINV          ,0.0                                      ,"m"                                     ,"Width dependence  of NIGBINV" )
`MPRnb( PNIGBINV          ,0.0                                      ,"m^2"                                   ,"Area dependence  of NIGBINV" )
`MPRnb( LAIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGBACC" )
`MPRnb( WAIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence  of AIGBACC" )
`MPRnb( PAIGBACC          ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence  of AIGBACC" )
`MPRnb( LBIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGBACC" )
`MPRnb( WBIGBACC          ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence  of BIGBACC" )
`MPRnb( PBIGBACC          ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence  of BIGBACC" )
`MPRnb( LCIGBACC          ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGBACC" )
`MPRnb( WCIGBACC          ,0.0                                      ,"m/V"                                   ,"Width dependence  of CIGBACC" )
`MPRnb( PCIGBACC          ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of CIGBACC" )
`MPRnb( LNIGBACC          ,0.0                                      ,"m"                                     ,"Length dependence of NIGBACC" )
`MPRnb( WNIGBACC          ,0.0                                      ,"m"                                     ,"Width dependence  of NIGBACC" )
`MPRnb( PNIGBACC          ,0.0                                      ,"m^2"                                   ,"Area dependence  of NIGBACC" )
`MPRnb( LAIGC             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGC" )
`MPRnb( WAIGC             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence  of AIGC" )
`MPRnb( PAIGC             ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence  of AIGC" )
`MPRnb( LBIGC             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGC" )
`MPRnb( WBIGC             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence  of BIGC" )
`MPRnb( PBIGC             ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence  of BIGC" )
`MPRnb( LCIGC             ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGC" )
`MPRnb( WCIGC             ,0.0                                      ,"m/V"                                   ,"Width dependence  of CIGC" )
`MPRnb( PCIGC             ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of CIGC" )
`MPRnb( LAIGS             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGS" )
`MPRnb( WAIGS             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence  of AIGS" )
`MPRnb( PAIGS             ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence  of AIGS" )
`MPRnb( LBIGS             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGS" )
`MPRnb( WBIGS             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence  of BIGS" )
`MPRnb( PBIGS             ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence  of BIGS" )
`MPRnb( LCIGS             ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGS" )
`MPRnb( WCIGS             ,0.0                                      ,"m/V"                                   ,"Width dependence  of CIGS" )
`MPRnb( PCIGS             ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of CIGS" )
`MPRnb( LAIGD             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Length dependence of AIGD" )
`MPRnb( WAIGD             ,0.0                                      ,"(F*s^2/g)^0.5"                         ,"Width dependence  of AIGD" )
`MPRnb( PAIGD             ,0.0                                      ,"m*(F*s^2/g)^0.5"                       ,"Area dependence  of AIGD" )
`MPRnb( LBIGD             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Length dependence of BIGD" )
`MPRnb( WBIGD             ,0.0                                      ,"(F*s^2/g)^0.5/V"                       ,"Width dependence  of BIGD" )
`MPRnb( PBIGD             ,0.0                                      ,"m*(F*s^2/g)^0.5/V"                     ,"Area dependence  of BIGD" )
`MPRnb( LCIGD             ,0.0                                      ,"m/V"                                   ,"Length dependence of CIGD" )
`MPRnb( WCIGD             ,0.0                                      ,"m/V"                                   ,"Width dependence  of CIGD" )
`MPRnb( PCIGD             ,0.0                                      ,"m^2/V"                                 ,"Area dependence  of CIGD" )
`MPRnb( LPOXEDGE          ,0.0                                      ,"m"                                     ,"Length dependence of POXEDGE" )
`MPRnb( WPOXEDGE          ,0.0                                      ,"m"                                     ,"Width dependence  of POXEDGE" )
`MPRnb( PPOXEDGE          ,0.0                                      ,"m^2"                                   ,"Area dependence  of POXEDGE" )
`MPRnb( LDLCIG            ,0.0                                      ,"m^2"                                   ,"Length dependence of DLCIG" )
`MPRnb( WDLCIG            ,0.0                                      ,"m^2"                                   ,"Width dependence  of DLCIG" )
`MPRnb( PDLCIG            ,0.0                                      ,"m^3"                                   ,"Area dependence  of DLCIG" )
`MPRnb( LDLCIGD           ,0.0                                      ,"m^2"                                   ,"Length dependence of DLCIGD" )
`MPRnb( WDLCIGD           ,0.0                                      ,"m^2"                                   ,"Width dependence  of DLCIGD" )
`MPRnb( PDLCIGD           ,0.0                                      ,"m^3"                                   ,"Area dependence  of DLCIGD" )
`MPRnb( LNTOX             ,0.0                                      ,"m"                                     ,"Length dependence of NTOX" )
`MPRnb( WNTOX             ,0.0                                      ,"m"                                     ,"Width dependence  of NTOX" )
`MPRnb( PNTOX             ,0.0                                      ,"m^2"                                   ,"Area dependence  of NTOX" )

// GIDL and GISL currents
`MPRnb( AGIDL             ,0.0                                      ,"V/m"                                   ,"Pre-exponential coefficient for GIDL" )
`MPRnb( AGIDLL            ,0.0                                      ,"m"                                     ,"Length dependence coefficient of AGIDL" )
`MPRnb( AGIDLW            ,0.0                                      ,"m"                                     ,"Width dependence coefficient of AGIDL" )
`MPRnb( LAGIDL            ,0.0                                      ,"m^2"                                   ,"Length dependence of AGIDL" )
`MPRnb( WAGIDL            ,0.0                                      ,"m^2"                                   ,"Width dependence  of AGIDL" )
`MPRnb( PAGIDL            ,0.0                                      ,"m^3"                                   ,"Area dependence  of AGIDL" )
`MPRnb( BGIDL             ,2.3e9                                    ,"V/m"                                   ,"Exponential coefficient for GIDL" )
`MPRnb( LBGIDL            ,0.0                                      ,"V"                                     ,"Length dependence of BGIDL" )
`MPRnb( WBGIDL            ,0.0                                      ,"V"                                     ,"Width dependence  of BGIDL" )
`MPRnb( PBGIDL            ,0.0                                      ,"V*m"                                   ,"Area dependence  of BGIDL" )
`MPRnb( CGIDL             ,0.5                                      ,"V/m"                                   ,"Exponential coefficient for GIDL" )
`MPRnb( LCGIDL            ,0.0                                      ,"V"                                     ,"Length dependence of CGIDL" )
`MPRnb( WCGIDL            ,0.0                                      ,"V"                                     ,"Width dependence  of CGIDL" )
`MPRnb( PCGIDL            ,0.0                                      ,"V*m"                                   ,"Area dependence  of CGIDL" )
`MPRnb( EGIDL             ,0.8                                      ,"V"                                     ,"Band bending parameter for GIDL" )
`MPRnb( LEGIDL            ,0.0                                      ,"V*m"                                   ,"Length dependence of EGIDL" )
`MPRnb( WEGIDL            ,0.0                                      ,"V*m"                                   ,"Width dependence  of EGIDL" )
`MPRnb( PEGIDL            ,0.0                                      ,"V*m^2"                                 ,"Area dependence  of EGIDL" )
`MPRnb( AGISL             ,AGIDL                                    ,"V/m"                                   ,"Pre-exponential coefficient for GISL" )
`MPRnb( AGISLL            ,AGIDLL                                   ,"m"                                     ,"Length dependence coefficient of AGISL" )
`MPRnb( AGISLW            ,AGIDLW                                   ,"m"                                     ,"Width dependence coefficient of AGISL" )
`MPRnb( LAGISL            ,LAGIDL                                   ,"m^2"                                   ,"Length dependence of AGISL" )
`MPRnb( WAGISL            ,WAGIDL                                   ,"m^2"                                   ,"Width dependence  of AGISL" )
`MPRnb( PAGISL            ,PAGIDL                                   ,"m^3"                                   ,"Area dependence  of AGISL" )
`MPRnb( BGISL             ,BGIDL                                    ,"V/m"                                   ,"Exponential coefficient for GISL" )
`MPRnb( LBGISL            ,LBGIDL                                   ,"V"                                     ,"Length dependence of BGISL" )
`MPRnb( WBGISL            ,WBGIDL                                   ,"V"                                     ,"Width dependence  of BGISL" )
`MPRnb( PBGISL            ,PBGIDL                                   ,"V*m"                                   ,"Area dependence  of BGISL" )
`MPRnb( CGISL             ,CGIDL                                    ,"V/m"                                   ,"Exponential coefficient for GISL" )
`MPRnb( LCGISL            ,LCGIDL                                   ,"V"                                     ,"Length dependence of CGISL" )
`MPRnb( WCGISL            ,WCGIDL                                   ,"V"                                     ,"Width dependence of CGISL" )
`MPRnb( PCGISL            ,PCGIDL                                   ,"V*m"                                   ,"Area dependence of CGISL" )
`MPRnb( EGISL             ,EGIDL                                    ,"V"                                     ,"Band bending parameter for GISL" )
`MPRnb( LEGISL            ,LEGIDL                                   ,"V*m"                                   ,"Length dependence of EGISL" )
`MPRnb( WEGISL            ,WEGIDL                                   ,"V*m"                                   ,"Width dependence  of EGISL" )
`MPRnb( PEGISL            ,PEGIDL                                   ,"V*m^2"                                 ,"Area dependence  of EGISL" )

// Overlap capacitance and fringing capacitance
`MPRnb( CF                ,0.0                                      ,"F/m"                                   ,"Outer Fringe capacitance" )
`MPRnb( LCF               ,0.0                                      ,"F"                                     ,"Length dependence of CF" )
`MPRnb( WCF               ,0.0                                      ,"F"                                     ,"Width dependence  of CF" )
`MPRnb( PCF               ,0.0                                      ,"F*m"                                    ,"Area dependence  of CF" )
`MPRco( CFRCOEFF          ,1.0                                      ,"F/m"            ,1.0         ,inf      ,"Coefficient for Outer Fringe capacitance" )
`MPRnb( CGSO              ,0.0                                      ,"F/m"                                   ,"Gate - Source overlap capacitance" )
`MPRnb( CGDO              ,0.0                                      ,"F/m"                                   ,"Gate - Drain overlap capacitance" )
`MPRnb( CGBO              ,0.0                                      ,"F/m"                                   ,"Gate - Body overlap capacitance" )
`MPRnb( CGSL              ,0.0                                      ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped source region" )
`MPRnb( LCGSL             ,0.0                                      ,""                                      ,"Length dependence of CGSL" )
`MPRnb( WCGSL             ,0.0                                      ,""                                      ,"Width dependence  of CGSL" )
`MPRnb( PCGSL             ,0.0                                      ,""                                      ,"Area dependence  of CGSL" )
`MPRnb( CGDL              ,0.0                                      ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped drain region" )
`MPRnb( LCGDL             ,0.0                                      ,"F"                                     ,"Length dependence of CGDL" )
`MPRnb( WCGDL             ,0.0                                      ,"F"                                     ,"Width dependence  of CGDL" )
`MPRnb( PCGDL             ,0.0                                      ,"F*m"                                    ,"Area dependence  of CGDL" )
`MPRnb( CKAPPAS           ,0.6                                      ,"V"                                     ,"Coefficient of bias-dependent overlap capacitance for the source side" )
`MPRnb( LCKAPPAS          ,0.0                                      ,"m*V"                                   ,"Length dependence of CKAPPAS" )
`MPRnb( WCKAPPAS          ,0.0                                      ,"m*V"                                   ,"Width dependence  of CKAPPAS" )
`MPRnb( PCKAPPAS          ,0.0                                      ,"m^2*V"                                 ,"Area dependence  of CKAPPAS" )
`MPRnb( CKAPPAD           ,0.6                                      ,"V"                                     ,"Coefficient of bias-dependent overlap capacitance for the drain side" )
`MPRnb( LCKAPPAD          ,0.0                                      ,"m*V"                                   ,"Length dependence of CKAPPAD" )
`MPRnb( WCKAPPAD          ,0.0                                      ,"m*V"                                   ,"Width dependence  of CKAPPAD" )
`MPRnb( PCKAPPAD          ,0.0                                      ,"m^2*V"                                 ,"Area dependence  of CKAPPAD" )

// Layout-dependent parasitics model parameters (resistance only)
`MPRnb( DMCG              ,0.0                                      ,"m"                                     ,"Distance of Mid-Contact to Gate edge" )
`MPRnb( DMCI              ,DMCG                                     ,"m"                                     ,"Distance of Mid-Contact to Isolation" )
`MPRnb( DMDG              ,0.0                                      ,"m"                                     ,"Distance of Mid-Diffusion to Gate edge" )
`MPRnb( DMCGT             ,0.0                                      ,"m"                                     ,"Distance of Mid-Contact to Gate edge in Test" )
`MPRoo( XGL               ,0.0                                      ,"m"         ,-inf        ,L*LMLT+XL     ,"Variation in Ldrawn" )
`MPRcz( RSHG              ,0.1                                      ,"ohm"                                   ,"Gate sheet resistance" )

// Junction capacitance
`MPRnb( CJS               ,5.0e-4                                   ,"F/m^2"                                 ,"Unit area source-side junction capacitance at zero bias" )
`MPRnb( CJD               ,CJS                                      ,"F/m^2"                                 ,"Unit area drain-side junction capacitance at zero bias" )
`MPRnb( CJSWS             ,5.0e-10                                  ,"F/m"                                   ,"Unit length source-side side-wall junction capacitance at zero bias" )
`MPRnb( CJSWD             ,CJSWS                                    ,"F/m"                                   ,"Unit length drain-side side-wall junction capacitance at zero bias" )
`MPRnb( CJSWGS            ,0.0                                      ,"F/m"                                   ,"Unit length source-side gate side-wall junction capacitance at zero bias" )
`MPRnb( CJSWGD            ,CJSWGS                                   ,"F/m"                                   ,"Unit length drain-side gate side-wall junction capacitance at zero bias" )
`MPRnb( PBS               ,1.0                                      ,"V"                                     ,"Source-side bulk junction built-in potential" )
`MPRnb( PBD               ,PBS                                      ,"V"                                     ,"Drain-side bulk junction built-in potential" )
`MPRnb( PBSWS             ,1.0                                      ,"V"                                     ,"Built-in potential for Source-side side-wall junction capacitance" )
`MPRnb( PBSWD             ,PBSWS                                    ,"V"                                     ,"Built-in potential for Drain-side side-wall junction capacitance" )
`MPRnb( PBSWGS            ,PBSWS                                    ,"V"                                     ,"Built-in potential for Source-side gate side-wall junction capacitance" )
`MPRnb( PBSWGD            ,PBSWGS                                   ,"V"                                     ,"Built-in potential for Drain-side gate side-wall junction capacitance" )
`MPRnb( MJS               ,0.5                                      ,""                                      ,"Source bottom junction capacitance grading coefficient" )
`MPRnb( MJD               ,MJS                                      ,""                                      ,"Drain bottom junction capacitance grading coefficient" )
`MPRnb( MJSWS             ,0.33                                     ,""                                      ,"Source side-wall junction capacitance grading coefficient" )
`MPRnb( MJSWD             ,MJSWS                                    ,""                                      ,"Drain side-wall junction capacitance grading coefficient" )
`MPRnb( MJSWGS            ,MJSWS                                    ,""                                      ,"Source-side gate side-wall junction capacitance grading coefficient" )
`MPRnb( MJSWGD            ,MJSWGS                                   ,""                                      ,"Drain-side gate side-wall junction capacitance grading coefficient" )

// Junction current
`MPRnb( JSS               ,1.0e-4                                   ,"A/m^2"                                 ,"Bottom source junction reverse saturation current density" )
`MPRnb( JSD               ,JSS                                      ,"A/m^2"                                 ,"Bottom drain junction reverse saturation current density" )
`MPRnb( JSWS              ,0.0                                      ,"A/m"                                   ,"Unit length reverse saturation current for side-wall source junction" )
`MPRnb( JSWD              ,JSWS                                     ,"A/m"                                   ,"Unit length reverse saturation current for side-wall drain junction" )
`MPRnb( JSWGS             ,0.0                                      ,"A/m"                                   ,"Unit length reverse saturation current for gate-edge side-wall source junction" )
`MPRnb( JSWGD             ,JSWGS                                    ,"A/m"                                   ,"Unit length reverse saturation current for gate-edge side-wall drain junction" )
`MPRoz( NJS               ,1.0                                      ,""                                      ,"Source junction emission coefficient" )
`MPRoz( NJD               ,NJS                                      ,""                                      ,"Drain junction emission coefficient" )
`MPRnb( IJTHSFWD          ,0.1                                      ,"A"                                     ,"Forward source diode breakdown limiting current" )
`MPRnb( IJTHDFWD          ,IJTHSFWD                                 ,"A"                                     ,"Forward drain diode breakdown limiting current" )
`MPRnb( IJTHSREV          ,0.1                                      ,"A"                                     ,"Reverse source diode breakdown limiting current" )
`MPRnb( IJTHDREV          ,IJTHSREV                                 ,"A"                                     ,"Reverse drain diode breakdown limiting current" )
`MPRnb( BVS               ,10.0                                     ,"V"                                     ,"Source diode breakdown voltage" )
`MPRnb( BVD               ,BVS                                      ,"V"                                     ,"Drain diode breakdown voltage" )
`MPRoz( XJBVS             ,1.0                                      ,""                                      ,"Fitting parameter for source diode breakdown current" )
`MPRoz( XJBVD             ,XJBVS                                    ,""                                      ,"Fitting parameter for drain diode breakdown current" )

// Tunneling component of junction current
`MPRnb( JTSS              ,0.0                                      ,"A/m"                                   ,"Bottom source junction trap-assisted saturation current density" )
`MPRnb( JTSD              ,JTSS                                     ,"A/m"                                   ,"Bottom drain junction trap-assisted saturation current density" )
`MPRnb( JTSSWS            ,0.0                                      ,"A/m^2"                                 ,"Unit length trap-assisted saturation current for side-wall source junction" )
`MPRnb( JTSSWD            ,JTSSWS                                   ,"A/m^2"                                 ,"Unit length trap-assisted saturation current for side-wall drain junction" )
`MPRnb( JTSSWGS           ,0.0                                      ,"A/m"                                   ,"Unit length trap-assisted saturation current for gate-edge side-wall source junction" )
`MPRnb( JTSSWGD           ,JTSSWGS                                  ,"A/m"                                   ,"Unit length trap-assisted saturation current for gate-edge side-wall drain junction" )
`MPRcz( JTWEFF            ,0.0                                      ,""                                      ,"Trap assisted tunnelling current width dependence" )
`MPRnb( NJTS              ,20.0                                     ,""                                      ,"Non-ideality factor for JTSS" )
`MPRnb( NJTSD             ,NJTS                                     ,""                                      ,"Non-ideality factor for JTSD" )
`MPRnb( NJTSSW            ,20.0                                     ,""                                      ,"Non-ideality factor for JTSSWS" )
`MPRnb( NJTSSWD           ,NJTSSW                                   ,""                                      ,"Non-ideality factor for JTSSWD" )
`MPRnb( NJTSSWG           ,20.0                                     ,""                                      ,"Non-ideality factor for JTSSWGS" )
`MPRnb( NJTSSWGD          ,NJTSSWG                                  ,""                                      ,"Non-ideality factor for JTSSWGD" )
`MPRnb( VTSS              ,10.0                                     ,"V"                                     ,"Bottom source junction trap-assisted current voltage dependent parameter" )
`MPRnb( VTSD              ,VTSS                                     ,"V"                                     ,"Bottom drain junction trap-assisted current voltage dependent parameter" )
`MPRnb( VTSSWS            ,10.0                                     ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for side-wall source junction" )
`MPRnb( VTSSWD            ,VTSSWS                                   ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for side-wall drain junction" )
`MPRnb( VTSSWGS           ,10.0                                     ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for gate-edge side-wall source junction" )
`MPRnb( VTSSWGD           ,VTSSWGS                                  ,"V"                                     ,"Unit length trap-assisted current voltage dependent parameter for gate-edge side-wall drain junction" )

// High-speed/RF model parameters
`MPRnb( XRCRG1            ,12.0                                     ,""                                      ,"1st fitting parameter the bias-dependent Rg " )
`MPRnb( XRCRG2            ,1.0                                      ,""                                      ,"2nd fitting parameter the bias-dependent Rg " )
`MPRcz( GBMIN             ,1.0e-12                                  ,"mho"                                   ,"Minimum body conductance" )
`MPRoz( RBPS0             ,50.0                                     ,"ohm"                                   ,"Scaling pre-factor for RBPS" )
`MPRcz( RBPSL             ,0.0                                      ,""                                      ,"Length Scaling parameter for RBPS" )
`MPRcz( RBPSW             ,0.0                                      ,""                                      ,"Width Scaling parameter for RBPS" )
`MPRcz( RBPSNF            ,0.0                                      ,""                                      ,"Number of fingers Scaling parameter for RBPS" )
`MPRoz( RBPD0             ,50.0                                     ,"ohm"                                   ,"Scaling pre-factor for RBPD" )
`MPRcz( RBPDL             ,0.0                                      ,""                                      ,"Length Scaling parameter for RBPD" )
`MPRcz( RBPDW             ,0.0                                      ,""                                      ,"Width Scaling parameter for RBPD" )
`MPRcz( RBPDNF            ,0.0                                      ,""                                      ,"Number of fingers Scaling parameter for RBPD" )
`MPRoz( RBPBX0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBPBX" )
`MPRcz( RBPBXL            ,0.0                                      ,""                                      ,"Length Scaling parameter for RBPBX" )
`MPRcz( RBPBXW            ,0.0                                      ,""                                      ,"Width Scaling parameter for RBPBX" )
`MPRcz( RBPBXNF           ,0.0                                      ,""                                      ,"Number of fingers Scaling parameter for RBPBX" )
`MPRoz( RBPBY0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBPBY" )
`MPRcz( RBPBYL            ,0.0                                      ,""                                      ,"Length Scaling parameter for RBPBY" )
`MPRcz( RBPBYW            ,0.0                                      ,""                                      ,"Width Scaling parameter for RBPBY" )
`MPRcz( RBPBYNF           ,0.0                                      ,""                                      ,"Number of fingers Scaling parameter for RBPBY" )
`MPRoz( RBSBX0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBSBX" )
`MPRoz( RBSBY0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBSBY" )
`MPRoz( RBDBX0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBDBX" )
`MPRoz( RBDBY0            ,100.0                                    ,"ohm"                                   ,"Scaling pre-factor for RBDBY" )
`MPRcz( RBSDBXL           ,0.0                                      ,""                                      ,"Length Scaling parameter for RBSBX and RBDBX" )
`MPRcz( RBSDBXW           ,0.0                                      ,""                                      ,"Width Scaling parameter for RBSBX and RBDBX" )
`MPRcz( RBSDBXNF          ,0.0                                      ,""                                      ,"Number of fingers Scaling parameter for RBSBX and RBDBX" )
`MPRcz( RBSDBYL           ,0.0                                      ,""                                      ,"Length Scaling parameter for RBSBY and RBDBY" )
`MPRcz( RBSDBYW           ,0.0                                      ,""                                      ,"Width Scaling parameter for RBSBY and RBDBY" )
`MPRcz( RBSDBYNF          ,0.0                                      ,""                                      ,"Number of fingers Scaling parameter for RBSBY and RBDBY" )

// Flicker noise
`MPRoc( EF                ,1.0                                      ,""          ,0           ,2             ,"Flicker Noise frequency exponent" )
`MPRnb( EM                ,4.1e7                                    ,"V/m"                                   ,"Saturation Field" )
`MPRnb( NOIA              ,6.250e+40                                ,"s^(1-EF)/(eV)^1/m^3"                   ,"Flicker noise parameter A" )
`MPRnb( NOIB              ,3.125e+25                                ,"s^(1-EF)/(eV)^1/m"                     ,"Flicker noise parameter B" )
`MPRnb( NOIC              ,8.750e+8                                 ,"s^(1-EF)*m/(eV)^1"                     ,"Flicker noise parameter C" )
`MPRnb( LINTNOI           ,0.0                                      ,"m"                                     ,"Length Reduction Parameter Offset" )

// Thermal noise
`MPRcz( NTNOI             ,1.0                                      ,""                                      ,"Noise factor for short-channel devices for TNOIMOD=0 only" )
`MPRnb( RNOIA             ,0.577                                    ,""                                      ,"TNOIMOD = 1" )
`MPRnb( RNOIB             ,0.5164                                   ,""                                      ,"TNOIMOD = 1" )
`MPRnb( RNOIC             ,0.395                                    ,""                                      ,"TNOIMOD = 1" )
`MPRoo( TNOIA             ,0.0                                      ,""          ,-inf         ,inf          ,"TNOIMOD = 1" )
`MPRoo( TNOIB             ,0.0                                      ,""          ,-inf         ,inf          ,"TNOIMOD = 1" )
`MPRoo( TNOIC             ,0.0                                      ,""          ,-inf         ,inf          ,"Correlation coefficient" )

// Binning parameters
`MPIcc( BINUNIT           ,1                                        ,""          ,0           ,1             ,"Unit of L and W for Binning, 1 : micro-meter, 0 : default" )
`MPRnb( DLBIN             ,0.0                                      ,""                                      ,"Length reduction parameter for binning" )
`MPRnb( DWBIN             ,0.0                                      ,""                                      ,"Width reduction parameter for binning" )

// Temperature dependence parameters
`MPRnb( TNOM              ,27.0                                     ,"degC"                                  ,"Temperature at which the model was extracted" )
`MPRnb( TBGASUB           ,4.73e-4                                  ,"eV/K"                                  ,"Band-gap Temperature Coefficient" )
`MPRnb( TBGBSUB           ,636.0                                    ,"K"                                     ,"Band-gap Temperature Coefficient" )
`MPRnb( TNFACTOR          ,0.0                                      ,""                                      ,"Temperature exponent for NFACTOR" )
`MPRnb( UTE               ,-1.5                                     ,""                                      ,"Mobility temperature exponent" )
`MPRnb( LUTE              ,0.0                                      ,"m"                                     ,"Length dependence of UTE" )
`MPRnb( WUTE              ,0.0                                      ,"m"                                     ,"Width dependence  of UTE" )
`MPRnb( PUTE              ,0.0                                      ,"m^2"                                   ,"Area dependence  of UTE" )
`MPRnb( UTEL              ,0.0                                      ,"m"                                     ,"Length Scaling parameter for UTE" )
`MPRnb( UA1               ,1.0e-3                                   ,"m/V"                                   ,"Temperature coefficient for UA" )
`MPRnb( LUA1              ,0.0                                      ,"m^2/V"                                 ,"Length dependence of UA1" )
`MPRnb( WUA1              ,0.0                                      ,"m^2/V"                                 ,"Width dependence  of UA1" )
`MPRnb( PUA1              ,0.0                                      ,"m^3/V"                                 ,"Area dependence  of UA1" )
`MPRnb( UA1L              ,0.0                                      ,"m"                                     ,"Length Scaling parameter for UA1" )
`MPRnb( UC1               ,0.056e-9                                 ,"1/K"                                   ,"Temperature coefficient for UC" )
`MPRnb( LUC1              ,0.0                                      ,"m/K"                                   ,"Length dependence of UC1" )
`MPRnb( WUC1              ,0.0                                      ,"m/K"                                   ,"Width dependence  of UC1" )
`MPRnb( PUC1              ,0.0                                      ,"m^2/K"                                 ,"Area dependence  of UC1" )
`MPRnb( UD1               ,0.0                                      ,"1/m^2"                                 ,"Temperature coefficient for UD" )
`MPRnb( LUD1              ,0.0                                      ,"1/m"                                   ,"Length dependence of UD1" )
`MPRnb( WUD1              ,0.0                                      ,"1/m"                                   ,"Width dependence  of UD1" )
`MPRnb( PUD1              ,0.0                                      ,""                                      ,"Area dependence  of UD1" )
`MPRnb( UD1L              ,0.0                                      ,"m"                                     ,"Length Scaling parameter for UD1" )
`MPRnb( UCSTE             ,-4.775e-3                                ,""                                      ,"Temperature coefficient for UCS" )
`MPRnb( LUCSTE            ,0.0                                      ,"m"                                     ,"Length dependence of UCSTE" )
`MPRnb( WUCSTE            ,0.0                                      ,"m"                                     ,"Width dependence  of UCSTE" )
`MPRnb( PUCSTE            ,0.0                                      ,"m^2"                                   ,"Area dependence  of UCSTE" )
`MPRnb( TETA0             ,0.0                                      ,""                                      ,"Temperature coefficient for ETA0" )
`MPRnb( PRT               ,0.0                                      ,""                                      ,"Temperature coefficient for resistance" )
`MPRnb( LPRT              ,0.0                                      ,"m"                                     ,"Length dependence of PRT" )
`MPRnb( WPRT              ,0.0                                      ,"m"                                     ,"Width dependence  of PRT" )
`MPRnb( PPRT              ,0.0                                      ,"m^2"                                   ,"Area dependence  of PRT" )
`MPRnb( AT                ,-1.56e-3                                 ,"m/s"                                   ,"Temperature coefficient for saturation velocity" )
`MPRnb( LAT               ,0.0                                      ,"m^2/s"                                 ,"Length dependence of AT" )
`MPRnb( WAT               ,0.0                                      ,"m^2/s"                                 ,"Width dependence  of AT" )
`MPRnb( PAT               ,0.0                                      ,"m^3/s"                                 ,"Area dependence  of AT" )
`MPRnb( ATL               ,0.0                                      ,"m"                                     ,"Length Scaling parameter for AT" )
`MPRnb( TDELTA            ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for DELTA" )
`MPRnb( PTWGT             ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for PTWG" )
`MPRnb( LPTWGT            ,0.0                                      ,"m/K"                                   ,"Length dependence of PTWGT" )
`MPRnb( WPTWGT            ,0.0                                      ,"m/K"                                   ,"Width dependence  of PTWGT" )
`MPRnb( PPTWGT            ,0.0                                      ,"m^2/K"                                 ,"Area dependence  of PTWGT" )
`MPRnb( PTWGTL            ,0.0                                      ,"m"                                     ,"Length Scaling parameter for PTWGT" )
`MPRnb( KT1               ,-0.11                                    ,"V"                                     ,"Temperature coefficient for Vth" )
`MPRoz( KT1EXP            ,1.0                                      ,""                                      ,"Temperature coefficient for Vth" )
`MPRnb( KT1L              ,0.0                                      ,"V*m"                                   ,"Temperature coefficient for Vth" )
`MPRnb( LKT1              ,0.0                                      ,"V*m"                                   ,"Length dependence of KT1" )
`MPRnb( WKT1              ,0.0                                      ,"V*m"                                   ,"Width dependence  of KT1" )
`MPRnb( PKT1              ,0.0                                      ,"V*m^2"                                 ,"Area dependence  of KT1" )
`MPRnb( KT2               ,0.022                                    ,""                                      ,"Temperature coefficient for Vth" )
`MPRnb( LKT2              ,0.0                                      ,"m"                                     ,"Length dependence of KT2" )
`MPRnb( WKT2              ,0.0                                      ,"m"                                     ,"Width dependence  of KT2" )
`MPRnb( PKT2              ,0.0                                      ,"m^2"                                   ,"Area dependence  of KT2" )
`MPRnb( IIT               ,0.0                                      ,""                                      ,"Temperature coefficient for BETA0" )
`MPRnb( LIIT              ,0.0                                      ,"m"                                     ,"Length dependence of IIT" )
`MPRnb( WIIT              ,0.0                                      ,"m"                                     ,"Width dependence  of IIT" )
`MPRnb( PIIT              ,0.0                                      ,"m^2"                                   ,"Area dependence  of IIT" )
`MPRnb( IGT               ,2.5                                      ,""                                      ,"Gate Current Temperature Dependence" )
`MPRnb( LIGT              ,0.0                                      ,"m"                                     ,"Length dependence of IGT" )
`MPRnb( WIGT              ,0.0                                      ,"m"                                     ,"Width dependence  of IGT" )
`MPRnb( PIGT              ,0.0                                      ,"m^2"                                   ,"Area dependence  of IGT" )
`MPRnb( TGIDL             ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for GIDL/GISL" )
`MPRnb( LTGIDL            ,0.0                                      ,"m/K"                                   ,"Length dependence of TGIDL" )
`MPRnb( WTGIDL            ,0.0                                      ,"m/K"                                   ,"Width dependence  of TGIDL" )
`MPRnb( PTGIDL            ,0.0                                      ,"m^2/K"                                 ,"Area dependence  of TGIDL" )
`MPRnb( TCJ               ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for CJS/CJD" )
`MPRnb( TCJSW             ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for CJSWS/CJSWD" )
`MPRnb( TCJSWG            ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for CJSWGS/CJSWGD" )
`MPRnb( TPB               ,0.0                                      ,"V/K"                                   ,"Temperature coefficient for PBS/PBD" )
`MPRnb( TPBSW             ,0.0                                      ,"V/K"                                   ,"Temperature coefficient for PBSWS/PBSWD" )
`MPRnb( TPBSWG            ,0.0                                      ,"V/K"                                   ,"Temperature coefficient for PBSWGS/PBSWGD" )
`MPRnb( XTIS              ,3.0                                      ,""                                      ,"Source junction current temperature exponent" )
`MPRnb( XTID              ,XTIS                                     ,""                                      ,"Drain junction current temperature exponent" )
`MPRnb( XTSS              ,0.02                                     ,""                                      ,"Power dependence of JTSS on temperature" )
`MPRnb( XTSD              ,XTSS                                     ,""                                      ,"Power dependence of JTSD on temperature" )
`MPRnb( XTSSWS            ,0.02                                     ,""                                      ,"Power dependence of JTSSWS on temperature" )
`MPRnb( XTSSWD            ,XTSSWS                                   ,""                                      ,"Power dependence of JTSSWD on temperature" )
`MPRnb( XTSSWGS           ,0.02                                     ,""                                      ,"Power dependence of JTSSWGS on temperature" )
`MPRnb( XTSSWGD           ,XTSSWGS                                  ,""                                      ,"Power dependence of JTSSWGD on temperature" )
`MPRnb( TNJTS             ,0.0                                      ,""                                      ,"Temperature coefficient for NJTS" )
`MPRnb( TNJTSD            ,TNJTS                                    ,""                                      ,"Temperature coefficient for NJTSD" )
`MPRnb( TNJTSSW           ,0.0                                      ,""                                      ,"Temperature coefficient for NJTSSW" )
`MPRnb( TNJTSSWD          ,TNJTSSW                                  ,""                                      ,"Temperature coefficient for NJTSSWD" )
`MPRnb( TNJTSSWG          ,0.0                                      ,""                                      ,"Temperature coefficient for NJTSSWG" )
`MPRnb( TNJTSSWGD         ,TNJTSSWG                                 ,""                                      ,"Temperature coefficient for NJTSSWGD" )

// Self heating parameters
`MPRco( RTH0              ,0.0                                      ,"m*K/W"       ,0            ,inf        ,"Thermal resistance" )
`MPRco( CTH0              ,1.0E-05                                  ,"s*W/(m*K)"   ,0            ,inf        ,"Thermal capacitance" )
`MPRnb( WTH0              ,0.0                                      ,"m"                                     ,"Width dependence coefficient for Rth and Cth" )

// Stress related parameters
`MPRoz( SAREF             ,1.0e-6                                   ,"m"                                     ,"Reference distance between OD edge from Poly from one side" )
`MPRoz( SBREF             ,1.0e-6                                   ,"m"                                     ,"Reference distance between OD edge from Poly from other side" )
`MPRcz( WLOD              ,0.0                                      ,"m"                                     ,"Width Parameter for Stress Effect" )
`MPRnb( KU0               ,0.0                                      ,"m"                                     ,"Mobility degradation/enhancement Parameter for Stress Effect" )
`MPRnb( KVSAT             ,0.0                                      ,"m"                                     ,"Saturation Velocity degradation/enhancement Parameter for Stress Effect" )
`MPRnb( TKU0              ,0.0                                      ,""                                      ,"Temperature Coefficient for KU0" )
`MPRnb( LKU0              ,0.0                                      ,"m^LLODKU0"                             ,"Length Dependence of KU0" )
`MPRnb( WKU0              ,0.0                                      ,"m^WLODKU0"                             ,"Width Dependence of KU0" )
`MPRnb( PKU0              ,0.0                                      ,"m^(LLODKU0+WLODKU0)"                   ,"Cross Term Dependence of KU0" )
`MPRnb( LLODKU0           ,0.0                                      ,""                                      ,"Length Parameter for U0 stress effect" )
`MPRnb( WLODKU0           ,0.0                                      ,""                                      ,"Width Parameter for U0 stress effect" )
`MPRnb( KVTH0             ,0.0                                      ,"V*m"                                   ,"Threshold Shift parameter for stress effect" )
`MPRnb( LKVTH0            ,0.0                                      ,"m^LLODKU0"                             ,"Length dependence of KVTH0" )
`MPRnb( WKVTH0            ,0.0                                      ,"m^WLODKU0"                             ,"Width dependence of KVTH0" )
`MPRnb( PKVTH0            ,0.0                                      ,"m^(LLODKU0+WLODKU0)"                   ,"Cross-term dependence of KVTH0" )
`MPRnb( LLODVTH           ,0.0                                      ,""                                      ,"Length Parameter for Vth stress effect" )
`MPRnb( WLODVTH           ,0.0                                      ,""                                      ,"Width Parameter for Vth stress effect" )
`MPRnb( STK2              ,0.0                                      ,"m"                                     ,"K2 shift factor related to Vth change" )
`MPRnb( LODK2             ,0.0                                      ,""                                      ,"K2 shift modification factor for stress effect" )
`MPRnb( STETA0            ,0.0                                      ,"m"                                     ,"ETA0 shift related to Vth0 change" )
`MPRnb( LODETA0           ,0.0                                      ,""                                      ,"ETA0 modification factor for stress effect" )

// Well proximity parameters
`MPRnb( WEB               ,0.0                                      ,""                                      ,"Coefficient for SCB (>0.0)" )
`MPRnb( WEC               ,0.0                                      ,""                                      ,"Coefficient for SCC (>0.0)" )
`MPRnb( KVTH0WE           ,0.0                                      ,""                                      ,"Threshold shift factor for well proximity effect" )
`MPRnb( LKVTH0WE          ,0.0                                      ,"m"                                     ,"Length dependence of KVTH0WE" )
`MPRnb( WKVTH0WE          ,0.0                                      ,"m"                                     ,"Width dependence  of KVTH0WE" )
`MPRnb( PKVTH0WE          ,0.0                                      ,"m^2"                                   ,"Area dependence  of KVTH0WE" )
`MPRnb( K2WE              ,0.0                                      ,""                                      ,"K2 shift factor for well proximity effect" )
`MPRnb( LK2WE             ,0.0                                      ,"m"                                     ,"Length dependence of K2WE" )
`MPRnb( WK2WE             ,0.0                                      ,"m"                                     ,"Width dependence  of K2WE" )
`MPRnb( PK2WE             ,0.0                                      ,"m^2"                                   ,"Area dependence  of K2WE" )
`MPRnb( KU0WE             ,0.0                                      ,""                                      ,"Mobility degradation factor for well proximity effect" )
`MPRnb( LKU0WE            ,0.0                                      ,"m"                                     ,"Length dependence of KU0WE" )
`MPRnb( WKU0WE            ,0.0                                      ,"m"                                     ,"Width dependence  of KU0WE" )
`MPRnb( PKU0WE            ,0.0                                      ,"m^2"                                   ,"Area dependence  of KU0WE" )
`MPRoo( SCREF             ,1.0e-6                                   ,"m"     ,0               ,inf           ,"Reference distance to calculate SCA,SCB and SCC (<0)" )

// Sub-surface leakage drain current
`MPRnb( SSL0              ,4.0e2                                    ,"A/m"                                   ,"Temperature- and doping-independent parameter for sub-surface leakage drain current")
`MPRnb( SSL1              ,3.36e8                                   ,"1/m"                                   ,"Temperature- and doping-independent parameter for gate length for sub-surface leakage drain current")
`MPRnb( SSL2              ,0.185                                    ,""                                      ,"Fitting parameter for sub-surface leakage drain current: barrier height")
`MPRnb( SSL3              ,0.3                                      ,"V"                                     ,"Fitting parameter for sub-surface leakage drain current: gate voltage effect")
`MPRnb( SSL4              ,1.4                                      ,"1/V"                                   ,"Fitting parameter for sub-surface leakage drain current: gate voltage effect")
`MPRnb( SSLEXP1           ,0.490                                    ,""                                      ,"Fitting exponent for ssl doping effect")
`MPRnb( SSLEXP2           ,1.42                                     ,""                                      ,"Fitting exponent for ssl temperature")

// Vdsx smoothing
`MPRco( AVDSX             ,20                                       ,""     ,5              ,100             ,"Smoothing parameter in Vdsx in Vbsx" )

// STI edge FET device parameters
`MPRco( WEDGE             ,10.0e-9                                  ,"m"    ,1.0e-9          ,inf            ,"Edge FET Width" )
`MPRoo( DGAMMAEDGE        ,0.0                                      ,""     ,-inf            ,inf            ,"Different in body-bias coefficient between Edge-FET and Main-FET" )
`MPRoo( DGAMMAEDGEL       ,0.0                                      ,""     ,-inf            ,inf            ,"L dependence parameter for DGAMMA" )
`MPRoo( DGAMMAEDGELEXP    ,1.0                                      ,""     ,-inf            ,inf            ,"Exponent of L dependence parameter for DGAMMA" )
`MPRoo( DVTEDGE           ,0.0                                      ,""     ,-inf            ,inf            ,"Vth shift for Edge FET" )
`MPRnb( NFACTOREDGE       ,NFACTOR                                  ,""                                      ,"NFACTOR for Edge FET" )
`MPRnb( LNFACTOREDGE      ,LNFACTOR                                 ,"m"                                     ,"Length dependence of NFACTOREDGE" )
`MPRnb( WNFACTOREDGE      ,WNFACTOR                                 ,"m"                                     ,"Width dependence  of NFACTOREDGE" )
`MPRnb( PNFACTOREDGE      ,PNFACTOR                                 ,"m^2"                                   ,"Area dependence  of NFACTOREDGE" )
`MPRnb( CITEDGE           ,CIT                                      ,"F/m^2"                                 ,"CIT for Edge FET" )
`MPRnb( LCITEDGE          ,LCIT                                     ,"F/m"                                   ,"Length dependence of CITEDGE" )
`MPRnb( WCITEDGE          ,WCIT                                     ,"F/m"                                   ,"Width dependence  of CITEDGE" )
`MPRnb( PCITEDGE          ,PCIT                                     ,"F"                                     ,"Area dependence  of CITEDGE" )
`MPRnb( CDSCDEDGE         ,CDSCD                                    ,"F/m^2/V"                               ,"CDSCD for edge FET" )
`MPRnb( LCDSCDEDGE        ,LCDSCD                                   ,"F/m/V"                                 ,"Length dependence of CDSCDEDGE" )
`MPRnb( WCDSCDEDGE        ,WCDSCD                                   ,"F/m/V"                                 ,"Width dependence  of CDSCDEDGE" )
`MPRnb( PCDSCDEDGE        ,PCDSCD                                   ,"F/V"                                   ,"Area dependence  of CDSCDEDGE" )
`MPRnb( CDSCBEDGE         ,CDSCB                                    ,"F/m^2/V"                               ,"CDSCB for edge FET" )
`MPRnb( LCDSCBEDGE        ,LCDSCB                                   ,"F/m/V"                                 ,"Length dependence of CDSCBEDGE" )
`MPRnb( WCDSCBEDGE        ,WCDSCB                                   ,"F/m/V"                                 ,"Width dependence  of CDSCBEDGE" )
`MPRnb( PCDSCBEDGE        ,PCDSCB                                   ,"F/V"                                   ,"Area dependence  of CDSCBEDGE" )
`MPRnb( ETA0EDGE          ,ETA0                                     ,""                                      ,"DIBL parameter for edge FET" )
`MPRnb( LETA0EDGE         ,LETA0                                    ,"m"                                     ,"Length dependence of ETA0EDGE" )
`MPRnb( WETA0EDGE         ,WETA0                                    ,"m"                                     ,"Width dependence  of ETA0EDGE" )
`MPRnb( PETA0EDGE         ,PETA0                                    ,"m^2"                                   ,"Area dependence  of ETA0EDGE" )
`MPRnb( ETABEDGE          ,ETAB                                     ,"1/V"                                   ,"ETAB for edge FET" )
`MPRnb( LETABEDGE         ,LETAB                                    ,"m/V"                                   ,"Length dependence of ETABEDGE" )
`MPRnb( WETABEDGE         ,WETAB                                    ,"m/V"                                   ,"Width dependence  of ETABEDGE" )
`MPRnb( PETABEDGE         ,PETAB                                    ,"m^2/V"                                 ,"Area dependence  of ETABEDGE" )
`MPRnb( KT1EDGE           ,KT1                                      ,"V"                                     ,"Temperature dependence parameter of threshold voltage for edge FET" )
`MPRnb( LKT1EDGE          ,LKT1                                     ,"V*m"                                   ,"Length dependence of KT1EDGE" )
`MPRnb( WKT1EDGE          ,WKT1                                     ,"V*m"                                   ,"Width dependence  of KT1EDGE" )
`MPRnb( PKT1EDGE          ,PKT1                                     ,"V*m^2"                                 ,"Area dependence  of KT1EDGE" )
`MPRnb( KT1LEDGE          ,KT1L                                     ,"V*m"                                   ,"Temperature dependence parameter of threshold voltage for edge FET" )
`MPRnb( LKT1LEDGE         ,0.0                                      ,"V*m^2"                                 ,"Length dependence of KT1LEDGE" )
`MPRnb( WKT1LEDGE         ,0.0                                      ,"V*m^2"                                 ,"Width dependence  of KT1LEDGE" )
`MPRnb( PKT1LEDGE         ,0.0                                      ,"V*m^3"                                 ,"Area dependence  of KT1LEDGE" )
`MPRnb( KT2EDGE           ,KT2                                      ,""                                      ,"Temperature dependence parameter of threshold voltage for edge FET" )
`MPRnb( LKT2EDGE          ,LKT2                                     ,"m"                                     ,"Length dependence of KT2EDGE" )
`MPRnb( WKT2EDGE          ,WKT2                                     ,"m"                                     ,"Width dependence  of KT2EDGE" )
`MPRnb( PKT2EDGE          ,PKT2                                     ,"m^2"                                   ,"Area dependence  of KT2EDGE" )
`MPRnb( KT1EXPEDGE        ,KT1EXP                                   ,""                                      ,"Temperature dependence parameter of threshold voltage for edge device" )
`MPRnb( LKT1EXPEDGE       ,0.0                                      ,"m"                                     ,"Length dependence of KT1EXPEDGE" )
`MPRnb( WKT1EXPEDGE       ,0.0                                      ,"m"                                     ,"Width dependence  of KT1EXPEDGE" )
`MPRnb( PKT1EXPEDGE       ,0.0                                      ,"m^2"                                   ,"Area dependence  of KT1EXPEDGE" )
`MPRnb( TNFACTOREDGE      ,TNFACTOR                                 ,""                                      ,"Temperature dependence parameter of sub-threshold slope factor for edge" )
`MPRnb( LTNFACTOREDGE     ,0.0                                      ,"m"                                     ,"Length dependence of TNFACTOREDGE" )
`MPRnb( WTNFACTOREDGE     ,0.0                                      ,"m"                                     ,"Width dependence  of TNFACTOREDGE" )
`MPRnb( PTNFACTOREDGE     ,0.0                                      ,"m^2"                                   ,"Area dependence  of TNFACTOREDGE" )
`MPRnb( TETA0EDGE         ,TETA0                                    ,""                                      ,"Temperature dependence parameter of DIBL parameter for edge FET" )
`MPRnb( LTETA0EDGE        ,0.0                                      ,"m"                                     ,"Length dependence of TETA0EDGE" )
`MPRnb( WTETA0EDGE        ,0.0                                      ,"m"                                     ,"Width dependence  of TETA0EDGE" )
`MPRnb( PTETA0EDGE        ,0.0                                      ,"m^2"                                   ,"Area dependence  of TETA0EDGE" )
`MPRnb( DVT0EDGE          ,2.2                                      ,""                                      ,"First coefficient of SCE effect on Vth for Edge FET" )
`MPRnb( DVT1EDGE          ,0.53                                     ,""                                      ,"Second coefficient of SCE effect on Vth for Edge FET" )
`MPRnb( DVT2EDGE          ,0.0                                      ,"1/V"                                   ,"Body-bias coefficient for SCE effect for Edge FET" )
`MPRnb( K2EDGE            ,K2                                       ,"V"                                     ,"Vth shift due to Vertical Non-uniform doping" )
`MPRnb( LK2EDGE           ,LK2                                      ,"m"                                     ,"Length dependence of K2EDGE" )
`MPRnb( WK2EDGE           ,WK2                                      ,"m"                                     ,"Width dependence  of K2EDGE" )
`MPRnb( PK2EDGE           ,PK2                                      ,"m^2"                                   ,"Area dependence  of K2EDGE" )
`MPRnb( KVTH0EDGE         ,KVTH0                                    ,"V*m"                                   ,"Threshold Shift parameter for stress effect" )
`MPRnb( LKVTH0EDGE        ,LKVTH0                                   ,"m^LLODKU0"                             ,"Length dependence of KVTH0EDGE" )
`MPRnb( WKVTH0EDGE        ,WKVTH0                                   ,"m^WLODKU0"                             ,"Width dependence  of KVTH0EDGE" )
`MPRnb( PKVTH0EDGE        ,PKVTH0                                   ,"m^(LLODKU0+WLODKU0)"                   ,"Area dependence  of KVTH0EDGE" )
`MPRnb( STK2EDGE          ,STK2                                     ,"m"                                     ,"K2 shift factor related to Vth change" )
`MPRnb( LSTK2EDGE         ,0.0                                      ,"m^2"                                   ,"Length dependence of STK2EDGE" )
`MPRnb( WSTK2EDGE         ,0.0                                      ,"m^2"                                   ,"Width dependence  of STK2EDGE" )
`MPRnb( PSTK2EDGE         ,0.0                                      ,"m^3"                                   ,"Area dependence  of STK2EDGE" )
`MPRnb( STETA0EDGE        ,STETA0                                   ,"m"                                     ,"ETA0 shift related to Vth0 change" )
`MPRnb( LSTETA0EDGE       ,0.0                                      ,"m^2"                                   ,"Length dependence of STETA0EDGE" )
`MPRnb( WSTETA0EDGE       ,0.0                                      ,"m^2"                                   ,"Width dependence  of STETA0EDGE" )
`MPRnb( PSTETA0EDGE       ,0.0                                      ,"m^3"                                   ,"Area dependence  of STETA0EDGE" )
`MPIcc( IGCLAMP           ,1                                        ,""            ,0           ,1           ,"Model flag" )
`MPRoz( LP                ,10u                                      ,"m"                                     ,"Length scaling parameter for thermal noise" )
`MPRnb( RNOIK             ,0.0                                      ,""                                      ,"Exponential coefficient for enhanced correlated thermal noise" )
`MPRoo( TNOIK             ,0.0                                      ,"1/m"         ,-inf        ,inf         ,"Empirical parameter for Leff trend of Sid at low Ids" )
`MPRcz( TNOIK2            ,0.1                                      ,"1/m"                                   ,"Empirical parameter for sensitivity of RNOIK" )
`MPRnb( K0                ,0.0                                      ,""                                      ,"Non-saturation effect parameter for strong inversion region" )
`MPRnb( LK0               ,0.0                                      ,"m"                                     ,"Length dependence of " )
`MPRnb( WK0               ,0.0                                      ,"m"                                     ,"Width dependence  of " )
`MPRnb( PK0               ,0.0                                      ,"m^2"                                   ,"Area dependence  of " )
`MPRnb( K01               ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for K0" )
`MPRnb( LK01              ,0.0                                      ,"m/K"                                   ,"Length dependence of K0" )
`MPRnb( WK01              ,0.0                                      ,"m/K"                                   ,"Width dependence  of K0" )
`MPRnb( PK01              ,0.0                                      ,"m^2/K"                                 ,"Area dependence  of K0" )
`MPRnb( M0                ,1.0                                      ,""                                      ,"offset of non-saturation effect parameter for strong inversion region" )
`MPRnb( LM0               ,0.0                                      ,"m"                                     ,"Length dependence of " )
`MPRnb( WM0               ,0.0                                      ,"m"                                     ,"Width dependence  of " )
`MPRnb( PM0               ,0.0                                      ,"m^2"                                   ,"Area dependence  of " )
`MPRnb( M01               ,0.0                                      ,"1/K"                                   ,"Temperature coefficient for M0" )
`MPRnb( LM01              ,0.0                                      ,"m/K"                                   ,"Length dependence of M0" )
`MPRnb( WM01              ,0.0                                      ,"m/K"                                   ,"Width dependence  of M0" )
`MPRnb( PM01              ,0.0                                      ,"m^2/K"                                 ,"Area dependence  of M0" )
`MPIcc( FNOIMOD           ,0                                        ,""             ,0           ,1          ,"Flicker noise model selector" )
`MPRoo( LH                ,30n                                      ,"m"            ,0           ,L          ,"Length of Halo transistor" )
`MPRnb( NOIA2             ,NOIA                                     ,"s^(1-EF)/(eV)^1/m^3"                   ,"Flicker noise parameter A for Halo" )
`MPRoz( HNDEP             ,NDEP                                     ,"1/m^3"                                 ,"Halo Doping Concentration for IV" )

// Common variables
real PSiso, PDiso, PSsha, PDsha, PSmer, PDmer, ASiso, ADiso, ASsha, ADsha, ASmer, ADmer;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12;
real Tb;
real epssi, epsox, ni, Weff, Leff, Weff1, Leff1, Wact, Lact, Weffcj, Eg, Eg0, Weff_SH;
real dLIV, dWIV, dLB, dWB, dLCV, dWCV, dWJ, Cox, epsratio;
real Vdb_noswap, Vsb_noswap, Vgs_noswap, Vgd_noswap, Vds_noswap;
real sigvds, vfb, vgfb, vgfbCV, Vbsx, Vfbsdr;
real Vg, vg, Vd, Vs, vs, Vds, Vdsx, Vgs_eff, Vgd_eff;
real Vth_shift;
real qia, qba, qiaCV, qbaCV, qbs, qbd, qb, dps, phib, phib_n;
real nq, psip, psiavg, psipclamp, sqrtpsisa, sqrtpsisainv, sqrtpsip;
real Cdep, Lnew, L_mult, Wnew, W_mult;
real wf, wr;

// Short channel effects
real n, Fp, nVt, inv_nVt, Vt, inv_Vt;
real PhistVbs, sqrtPhistVbs, Xdep, cdsc;
real T1DEP;
real dVth_ldop, DVTP0_i, DVTP1_i, DVTP2_i, DVTP3_i, DVTP4_i, DVTP5_i;
real dVth_VNUD, dVth_dibl, dvth_temp;
real gam, inv_gam, Phist, sqrtPhist, litl;

// Drain saturation voltage
real qis, qdsat, Eeffs, Dmobs, Esat, EsatL, Vdsat, LambdaC_by2, LambdaC;
real Vdseff, Vdssat, VdssatCV, vdeff, vdsat, qdeff, vdsatcv, VdsatCV;
real ln_T1_T2;
real A1_i, A11_i, A1_t, A2_i, A21_i, A2_t, Nsat;

// Mobility degradation
real EeffFactor, Eeffm, ueff, eta_mu, Dmob, Dtot;

// Velocity saturation
real zsat, Dvsat, Dptwg, PSAT_i, PSATR_i, PSAT_a;

// Output conductance
real diffVds, VaDITS, VaSCBE, Vasat;
real DIBLfactor, PVAGfactor, VaDIBL, Vgst2Vtm, Moc, MdL, Mscbe;

// Impact ionization and GIDL
real Iii, igidl, igisl;

// I-V variables
integer devsign;
real ids;

// C-V variables
real Qb, Qs, Qd1, Qd2, Qd, Qi, QBi, QSi, QDi, QGi, WLCOXVtinv;
real qs, qbeff, dqgeff;
real DPD, vgfbPD, gammaPD, gamg2;
real MdL_2, inv_MdL, inv_MdL_2, MdL_less_1;
real sis, sid, vgpqm, Temps, Tempd, DQSD, DQSD2, invgamg2;
real Vgsov, Vgdov, Qovb, Qovg, Qovs, Qovd, Cgsof, Cgdof;
real XDCinv, Coxeffinv, BSIMBULKTOXP;
real Vgd_ov_noswap, Vgs_ov_noswap;

// S/D series resistance
real WeffWRFactor, DMCGeff, DMDGeff, DMCIeff;
real RSourceGeo, RDrainGeo, Rsource, Rdrain, Rdss, Rdsi, Dr;

// S/D junction area and perimeter
real temp_ASeff, temp_ADeff, temp_PSeff, temp_PDeff;
real ASeff, ADeff;

// Gate resistances
real Grgeltd, Gcrg, idsovvds;

// Body resistance
real Lnl, Lnw, Lnnf, Bodymode, Rbpbx, Rbpby, Rbsbx, Rbsby, Rbdbx, Rbdby;
real Rbdb, Rbsb, Rbpb, Rbps, Rbpd;
real Grbsb, Grbdb, Grbpb, Grbps, Grbpd;

// Gate current
real Voxm, Voxminv, Voxmacc, Vdseffx;
real Vaux_Igbinv, Vaux_Igbacc, igbinv, igbacc, igb;
real igcs, igcd, igc0, T1_exp;
real igs, igd, igs_mult, igd_mult;
real Aechvb, Bechvb, AechvbEdge, BechvbEdge, ToxRatio, ToxRatioEdge;

// Junction current and capacitance
real PSeff, PDeff;
real Ibs, Ibd, Vbs_jct, Vbd_jct, arg, sarg;
real Czbs, czbs_p1, czbs_p2, Czbssw, czbssw_p1, czbssw_p2, Czbsswg, czbsswg_p1, czbsswg_p2;
real Czbd, czbd_p1, czbd_p2, Czbdsw, czbdsw_p1, czbdsw_p2, Czbdswg, czbdswg_p1, czbdswg_p2;
real Qbsj, Qbsj1, Qbsj2, Qbsj3;
real Qbdj, Qbdj1, Qbdj2, Qbdj3;
real Isbs, Isbd, Nvtms, Nvtmd;
real SslpRev, IVjsmRev, VjsmRev, SslpFwd, IVjsmFwd, VjsmFwd, XExpBVS;
real DslpRev, IVjdmRev, VjdmRev, DslpFwd, IVjdmFwd, VjdmFwd, XExpBVD;

// Flicker noise
real LINTNOI_i;
real Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal noise
real gspr, gdpr;
real Gtnoi, sidn, Nt;
real mig, migid, mid, Lvsat, Vtn;
real cm_igid, sqid, sqig, ctnoi, betanoisq, thetanoisq, betaLowId;

// Temperature effects
real delTemp1;
real DevTemp, Tnom, Vtm, Vtm0;
real TRatio, delTemp;
real U0_t, U0R_t, UA_t, UAR_t, UC_t, UCR_t, UD_t, UDR_t, UCS_t, UCSR_t, rdstemp, VSAT_t, VSATR_t, VSATCV_t;
real DELTA_t, PTWG_t, PTWGR_t, BETA0_t, BGIDL_t, BGISL_t;
real igtemp;
real ETA0_t, ETA0R_t, NFACTOR_t;

//Diode temperature effects
real CJS_t, CJSWS_t, CJSWGD_t, CJD_t, CJSWD_t, CJSWGS_t;
real PBS_t, PBSWS_t, PBSWGS_t, PBD_t, PBSWD_t, PBSWGD_t;
real JSS_t, JSWS_t, JSWGS_t, JSD_t, JSWD_t, JSWGD_t;
real JTSS_t, JTSD_t, JTSSWS_t, JTSSWD_t, JTSSWGS_t, JTSSWGD_t;
real NJTS_t, NJTSD_t, NJTSSW_t, NJTSSWD_t, NJTSSWG_t, NJTSSWGD_t;

// Binning
real PSATB_i;
real KT1_i, KT2_i;
real W_by_NF;
real L_LLN, W_LWN, LW_LLN_LWN, L_LLN1, W_LWN1, LW_LLN_LWN1;
real L_WLN, W_WWN, LW_WLN_WWN, L_WLN1, W_WWN1, LW_WLN_WWN1;
real Inv_L, Inv_W, Inv_WL, Inv_Lact, Inv_Wact, Inv_Llong, Inv_Wwide;
real BIN_L, BIN_W, BIN_WL;
real NGATE_i, NSD_i, NDEP_i, VFB_i;
real CIT_i, CDSCD_i, CDSCDR_i, CDSCD_a, CDSCB_i, NFACTOR_i;
real PHIN_i, ETA0_i, ETA0R_i, ETA0_a, ETAB_i, K2_i, K1_i;
real DELTA_i;
real U0_i, U0R_i, U0_a, VSAT_i, VSATR_i, VSAT_a, VSATCV_i, UA_i, UAR_i, UA_a, EU_i, UD_i, UDR_i, UD_a, UCS_i, UCSR_i, UCS_a, UC_i, UCR_i, UC_a;
real PDIBLC_i, PDIBLCR_i, PDIBLC_a, PDIBLCB_i, PSCBE1_i, PSCBE2_i, PDITS_i, PDITSD_i, FPROUT_i;
real PRWG_i, WR_i, RDWMIN_i, RSWMIN_i, RDW_i, RSW_i, RDSW_i, RDSWMIN_i;
real PTWG_i, PTWGR_i, PTWG_a, PVAG_i, XJ_i;
real PCLM_i, PCLMR_i, PCLM_a, PCLMCV_i, PRWB_i;
real CF_i, CGSL_i, CGDL_i, CKAPPAS_i, CKAPPAD_i;
real VFBCV_i, NDEPCV_i;
real ALPHA0_i, BETA0_i;
real AGIDL_i, BGIDL_i, CGIDL_i, EGIDL_i;
real AGISL_i, BGISL_i, CGISL_i, EGISL_i;
real UTE_i, UA1_i, UC1_i, UD1_i, UCSTE_i, PRT_i, AT_i, PTWGT_i, IIT_i, TGIDL_i;
real KVTH0WE_i, K2WE_i, KU0WE_i;
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;
real AIGC_i, BIGC_i, CIGC_i;
real AIGS_i, BIGS_i, CIGS_i, AIGD_i, BIGD_i, CIGD_i, POXEDGE_i, PIGCD_i;
real DLCIG_i, DLCIGD_i, NTOX_i;
real IGT_i;
real K0_i, M0_i;
real K01_i, M01_i;
real K0_t, M0_t;
real Mnud;
real NFACTOREDGE_i, CITEDGE_i, CDSCDEDGE_i, CDSCBEDGE_i, ETA0EDGE_i, ETABEDGE_i, KT1EDGE_i, KT1LEDGE_i, KT2EDGE_i, KT1EXPEDGE_i, TNFACTOREDGE_i, TETA0EDGE_i, K2EDGE_i, KVTH0EDGE_i, STK2EDGE_i, STETA0EDGE_i;

// Stress effect
real W_tmp_stress, tmp1_stress, kstress_u0, tmp1_stress_vth, kstress_vth0, ku0_temp;
real Inv_sa, Inv_sb, Inv_saref, Inv_sbref, Inv_odref, rho_ref, Inv_od,rho;
real mu0_mult, vsat_mult, vth0_stress, k2_stress, eta_stress;
integer i;

// Well Proximity effect
real vth0_well, k2_well, mu_well, Wdrn, local_sca, local_scb, local_scc;

// Edge FET Model Variables
real ids_edge, ETA0EDGE_t, NFACTOREDGE_t, Vbi, theta_sce_edge, dvth_dibl, dvth_sce, litl_edge, DGAMMAEDGE_i, vdsatedge, Vdsatedge, Vdssate;
real vth0_stress_EDGE, k2_stress_EDGE, eta_stress_EDGE, K2_EDGE,ETA0_EDGE;

// The following are used by the macro definitions (GEOMOD and RGEOMOD)
real nuIntD, nuEndD, nuIntS, nuEndS;
real Rint, Rend;

// Sub-surface punchthrough
real Issl, SSL0_NT, SSL1_NT, PHIB_SSL;

// VTH variables
real q_vth, psip_th;

// 1/f Noise model for Halo
real vgfbh, gam_h, phib_h, psiph, qsh, nq_h, U0_i_h, i1, qdh, i2, qsch;
real Np2, beta_ch, beta_h, gds_h, gds_ch, gm_ch, R_ch, R_h, Ssi_ch;
real Swi_ch, FNPowerAt1Hz_ch, FNPowerAt1Hz_h;
real T0a, T0b, T0c, T0d, T0e, Swi_h, t_tot, CF_ch, CF_h, LeffnoiH;

// Self Heating
real gth, cth;

// OPERATING POINT VARIABLES
`OPM( QBI,          "C",    "Intrinsic body charge")
`OPM( QSI,          "C",    "Intrinsic source charge")
`OPM( QDI,          "C",    "Intrinsic drain charge")
`OPM( QGI,          "C",    "Intrinsic gate charge")
`OPM( CGGI,         "F",    "Intrinsic g-g MOSFET capacitance")
`OPM( CGBI,         "F",    "Intrinsic g-b MOSFET capacitance")
`OPM( CGSI,         "F",    "Intrinsic g-s MOSFET capacitance")
`OPM( CGDI,         "F",    "Intrinsic g-d MOSFET capacitance")
`OPM( CSGI,         "F",    "Intrinsic s-g MOSFET capacitance")
`OPM( CSBI,         "F",    "Intrinsic s-b MOSFET capacitance")
`OPM( CSSI,         "F",    "Intrinsic s-s MOSFET capacitance")
`OPM( CSDI,         "F",    "Intrinsic s-d MOSFET capacitance")
`OPM( CDGI,         "F",    "Intrinsic d-g MOSFET capacitance")
`OPM( CDBI,         "F",    "Intrinsic d-b MOSFET capacitance")
`OPM( CDSI,         "F",    "Intrinsic d-s MOSFET capacitance")
`OPM( CDDI,         "F",    "Intrinsic d-d MOSFET capacitance")
`OPM( CBGI,         "F",    "Intrinsic b-g MOSFET capacitance")
`OPM( CBBI,         "F",    "Intrinsic b-b MOSFET capacitance")
`OPM( CBSI,         "F",    "Intrinsic b-s MOSFET capacitance")
`OPM( CBDI,         "F",    "Intrinsic b-d MOSFET capacitance")
`OPM( QB,           "C",    "Body charge")
`OPM( QS,           "C",    "Source charge")
`OPM( QD,           "C",    "Drain charge")
`OPM( QG,           "C",    "Gate charge")
`OPM( CGG,          "F",    "g-g MOSFET capacitance")
`OPM( CGB,          "F",    "g-b MOSFET capacitance")
`OPM( CGS,          "F",    "g-s MOSFET capacitance")
`OPM( CGD,          "F",    "g-d MOSFET capacitance")
`OPM( CSG,          "F",    "s-g MOSFET capacitance")
`OPM( CSB,          "F",    "s-b MOSFET capacitance")
`OPM( CSS,          "F",    "s-s MOSFET capacitance")
`OPM( CSD,          "F",    "s-d MOSFET capacitance")
`OPM( CDG,          "F",    "d-g MOSFET capacitance")
`OPM( CDB,          "F",    "d-b MOSFET capacitance")
`OPM( CDS,          "F",    "d-s MOSFET capacitance")
`OPM( CDD,          "F",    "d-d MOSFET capacitance")
`OPM( CBG,          "F",    "b-g MOSFET capacitance")
`OPM( CBB,          "F",    "b-b MOSFET capacitance")
`OPM( CBS,          "F",    "b-s MOSFET capacitance")
`OPM( CBD,          "F",    "b-d MOSFET capacitance")
`OPM( ISUB,         "A",    "Substrate current")
`OPM( IGIDL,        "A",    "")
`OPM( IGISL,        "A",    "")
`OPM( IGS,          "A",    "")
`OPM( IGD,          "A",    "")
`OPM( IGCS,         "A",    "")
`OPM( IGCD,         "A",    "")
`OPM( IGB,          "A",    "")
`OPM( CGSEXT,       "F",    "")
`OPM( CGDEXT,       "F",    "")
`OPM( CGBOV,        "F",    "Front gate charge")
`OPM( CAPBS,        "F",    "")
`OPM( CAPBD,        "F",    "")
`OPP( WEFF,         "m",    "")
`OPP( LEFF,         "m",    "")
`OPP( WEFFCV,       "m",    "")
`OPP( LEFFCV,       "m",    "")
`OPM( IDS,          "A",    "Drain-source current")
`OPM( IDEFF,        "A",    "Effective drain current")
`OPM( ISEFF,        "A",    "Effective source current")
`OPM( IGEFF,        "A",    "Effective gate current")
`OPM( IBS,          "A",    "")
`OPM( IBD,          "A",    "")
`OPP( VDS,          "V",    "Drain to source voltage")
`OPP( VGS,          "V",    "Gate to source voltage")
`OPP( VBS,          "V",    "Body to source voltage")
`OPP( VDSAT,        "V",    "")
`OPM( GM,           "mho",  "")
`OPM( GMBS,         "mho",  "")
`OPM( GDS,          "mho",  "")
`OPP( T_TOTAL_K,    "K",    "")
`OPP( T_TOTAL_C,    "degC", "")
`OPP( T_DELTA_SH,   "K",    "")
`OPP( VTH,          "V",    "Threshold voltage")

analog begin
    // Variable initialization to prevent hidden states
    CDSCDR_i   = 0.0; ETA0R_i      = 0.0; ETA0R_t          = 0.0; L_LLN1          = 0.0;
    L_WLN1     = 0.0; PCLMR_i      = 0.0; PDIBLCR_i        = 0.0; PSATR_i         = 0.0;
    PTWGR_i    = 0.0; PTWGR_t      = 0.0; U0R_i            = 0.0; U0R_t           = 0.0;
    UAR_i      = 0.0; UAR_t        = 0.0; UCR_i            = 0.0; UCR_t           = 0.0;
    UCSR_i     = 0.0; UCSR_t       = 0.0; UDR_i            = 0.0; UDR_t           = 0.0;
    UD_a       = 0.0; VSATR_i      = 0.0; VSATR_t          = 0.0; W_LWN1          = 0.0;
    W_WWN1     = 0.0; local_sca    = 0.0; local_scb        = 0.0; local_scc       = 0.0;
    Inv_sa     = 0.0; Inv_sb       = 0.0; vth0_stress_EDGE = 0.0; k2_stress_EDGE  = 0.0;
    eta_stress = 0.0; K2_EDGE      = 0.0; ETA0_EDGE        = 0.0; eta_stress_EDGE = 0.0;
    local_sca  = 0.0; local_scb    = 0.0; local_scc        = 0.0; K0_i            = 0.0;
    M0_i       = 0.0; K01_i        = 0.0; M01_i            = 0.0; K0_t            = 0.0;
    M0_t       = 0.0; CITEDGE_i    = 0.0; CDSCDEDGE_i      = 0.0; CDSCBEDGE_i     = 0.0;
    ETA0EDGE_i = 0.0; ETABEDGE_i   = 0.0; KT1EDGE_i        = 0.0; KT1LEDGE_i      = 0.0;
    KT2EDGE_i  = 0.0; KT1EXPEDGE_i = 0.0; TNFACTOREDGE_i   = 0.0; TETA0EDGE_i     = 0.0;
    K2EDGE_i   = 0.0; KVTH0EDGE_i  = 0.0; STK2EDGE_i       = 0.0; STETA0EDGE_i    = 0.0;

    // Bias independent calculations
    if (TYPE == `ntype) begin
        devsign = 1;
    end else begin
        devsign = -1;
    end

    // Constants
    epssi    = EPSRSUB * `EPS0;
    epsox    = EPSROX * `EPS0;
    Cox      = EPSROX * `EPS0 / TOXE;
    epsratio = EPSRSUB / EPSROX;

    // Physical Oxide Thickness
    if (!$param_given(TOXP)) begin
        BSIMBULKTOXP = (TOXE * EPSROX / 3.9) - DTOX;
    end else begin
        BSIMBULKTOXP = TOXP;
    end
    L_mult = L * LMLT;
    W_mult = W * WMLT;
    Lnew = L_mult + XL;
    if (Lnew <= 0.0) begin
        $strobe("Fatal: Ldrawn * LMLT + XL = %e for %M is non-positive", Lnew);
        $finish(0);
    end
    W_by_NF = W_mult / NF;
    Wnew    = W_by_NF + XW;
    if (Wnew <= 0.0) begin
        $strobe("Fatal: W / NF * WMLT + XW = %e for %M is non-positive", Wnew);
        $finish(0);
    end

    // Leff and Weff for I-V
    L_LLN      = pow(Lnew, -LLN);
    W_LWN      = pow(Wnew, -LWN);
    LW_LLN_LWN = L_LLN * W_LWN;
    dLIV       = LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;
    L_WLN      = pow(Lnew, -WLN);
    W_WWN      = pow(Wnew, -WWN);
    LW_WLN_WWN = L_WLN * W_WWN;
    dWIV       = WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;
    Leff       = Lnew - 2.0 * dLIV;
    if (Leff <= 0.0) begin
        $strobe("Fatal: Effective channel length = %e for  %M is non-positive", Leff);
        $finish(0);
    end else if (Leff <= 1.0e-9) begin
        $strobe("Warning: Effective channel length = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);
    end
    Weff = Wnew - 2.0 * dWIV;
    if (Weff <= 0.0) begin
        $strobe("Fatal: Effective channel Width = %e for %M is non-positive", Weff);
        $finish(0);
    end else if (Weff <= 1.0e-9) begin
        $strobe("Warning: Effective channel width = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", Weff);
    end

    // Leff and Weff for C-V
    dLCV = DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
    dWCV = DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
    Lact = Lnew - 2.0 * dLCV;
    if (Lact <= 0.0) begin
        $strobe("Fatal: Effective channel length for CV = %e for %M is non-positive", Lact);
        $finish(0);
    end else if (Lact <= 1.0e-9) begin
        $strobe("Warning: Effective channel length for CV = %e for %M is <= 1.0e-9. Recommended Lact >= 1e-8", Lact);
    end
    Wact = Wnew - 2.0 * dWCV;
    if (Wact <= 0.0) begin
        $strobe("Fatal: Effective channel width for CV = %e for %M is non-positive", Wact);
        $finish(0);
    end else if (Wact <= 1.0e-9) begin
        $strobe("Warning: Effective channel width for CV = %e for %M is <= 1.0e-9. Recommended Wact >= 1e-8", Wact);
    end

    // Weffcj for Diode, GIDL etc.
    dWJ    = DWJ + WLC / pow(Lnew, WLN) + WWC / pow(Wnew, WWN) + WWLC / pow(Lnew, WLN) / pow(Wnew, WWN);
    Weffcj = Wnew - 2.0 * dWJ;
    if (Weffcj <= 0.0) begin
        $strobe("Fatal: Effective channel width for S/D junctions = %e for %M is non-positive", Weffcj);
        $finish(0);
    end
    Inv_L     = 1.0e-6 / Leff;
    Inv_W     = 1.0e-6 / Weff;
    Inv_Lact  = 1.0e-6 / Lact;
    Inv_Wact  = 1.0e-6 / Wact;
    Inv_Llong = 1.0e-6 / LLONG;
    Inv_Wwide = 1.0e-6 / WWIDE;
    Inv_WL    = Inv_L * Inv_W;

    // Effective length and width for binning
    L_LLN1 = L_LLN;
    L_WLN1 = L_WLN;
    if (DLBIN != 0.0) begin
        if (DLBIN <= -Lnew) begin
            $strobe("Fatal: DLBIN for %M = %e is <= -Ldrawn * LMLT", DLBIN);
            $finish(0);
        end else begin
            L_LLN1 = pow(Lnew + DLBIN, -LLN);
            L_WLN1 = pow(Lnew + DLBIN, -WLN);
        end
    end
    W_LWN1 = W_LWN;
    W_WWN1 = W_WWN;
    if (DWBIN != 0.0) begin
        if (DWBIN <= -Wnew) begin
            $strobe("Fatal: DWBIN for %M = %e is <= -Wdrawn * WMLT", DWBIN);
            $finish(0);
        end else begin
            W_LWN1 = pow(Wnew + DWBIN, -LWN);
            W_WWN1 = pow(Wnew + DWBIN, -WWN);
        end
    end
    LW_LLN_LWN1 = L_LLN1 * W_LWN1;
    dLB         = LINT + LL * L_LLN1 + LW * W_LWN1 + LWL * LW_LLN_LWN1;
    LW_WLN_WWN1 = L_WLN1 * W_WWN1;
    dWB         = WINT + WL * L_WLN1 + WW * W_WWN1 + WWL * LW_WLN_WWN1;
    Leff1 = Lnew - 2.0 * dLB + DLBIN;
    if (Leff1 <= 0.0) begin
        $strobe("Fatal: Effective channel length for binning = %e for %M is non-positive", Leff1);
        $finish(0);
    end
    Weff1 = Wnew - 2.0 * dWB + DWBIN;
    if (Weff1 <= 0.0) begin
        $strobe("Fatal: Effective channel width for binning = %e for %M is non-positive", Weff1);
        $finish(0);
    end
    if (BINUNIT == 1) begin
        BIN_L = 1.0e-6 / Leff1;
        BIN_W = 1.0e-6 / Weff1;
    end else begin
        BIN_L = 1.0 / Leff1;
        BIN_W = 1.0 / Weff1;
    end
    BIN_WL         = BIN_L * BIN_W;
    VFB_i          = VFB + BIN_L * LVFB + BIN_W * WVFB + BIN_WL * PVFB;
    VFBCV_i        = VFBCV + BIN_L * LVFBCV + BIN_W * WVFBCV + BIN_WL * PVFBCV;
    NSD_i          = NSD + BIN_L * LNSD + BIN_W * WNSD + BIN_WL * PNSD;
    NDEP_i         = NDEP + BIN_L * LNDEP + BIN_W * WNDEP + BIN_WL * PNDEP;
    NDEPCV_i       = NDEPCV + BIN_L * LNDEPCV + BIN_W * WNDEPCV + BIN_WL * PNDEPCV;
    NGATE_i        = NGATE + BIN_L * LNGATE + BIN_W * WNGATE + BIN_WL * PNGATE;
    CIT_i          = CIT + BIN_L * LCIT + BIN_W * WCIT + BIN_WL * PCIT;
    NFACTOR_i      = NFACTOR + BIN_L * LNFACTOR + BIN_W * WNFACTOR + BIN_WL * PNFACTOR;
    CDSCD_i        = CDSCD + BIN_L * LCDSCD + BIN_W * WCDSCD + BIN_WL * PCDSCD;
    CDSCB_i        = CDSCB + BIN_L * LCDSCB + BIN_W * WCDSCB + BIN_WL * PCDSCB;
    DVTP0_i        = DVTP0 + BIN_L * LDVTP0 + BIN_W * WDVTP0 + BIN_WL * PDVTP0;
    DVTP1_i        = DVTP1 + BIN_L * LDVTP1 + BIN_W * WDVTP1 + BIN_WL * PDVTP1;
    DVTP2_i        = DVTP2 + BIN_L * LDVTP2 + BIN_W * WDVTP2 + BIN_WL * PDVTP2;
    DVTP3_i        = DVTP3 + BIN_L * LDVTP3 + BIN_W * WDVTP3 + BIN_WL * PDVTP3;
    DVTP4_i        = DVTP4 + BIN_L * LDVTP4 + BIN_W * WDVTP4 + BIN_WL * PDVTP4;
    DVTP5_i        = DVTP5 + BIN_L * LDVTP5 + BIN_W * WDVTP5 + BIN_WL * PDVTP5;
    K2_i           = K2 + BIN_L * LK2 + BIN_W * WK2 + BIN_WL * PK2;
    K1_i           = K1 + BIN_L * LK1 + BIN_W * WK1 + BIN_WL * PK1;
    XJ_i           = XJ + BIN_L * LXJ + BIN_W * WXJ + BIN_WL * PXJ;
    PHIN_i         = PHIN + BIN_L * LPHIN + BIN_W * WPHIN + BIN_WL * PPHIN;
    ETA0_i         = ETA0 + BIN_L * LETA0 + BIN_W * WETA0 + BIN_WL * PETA0;
    ETAB_i         = ETAB + BIN_L * LETAB + BIN_W * WETAB + BIN_WL * PETAB;
    DELTA_i        = DELTA + BIN_L * LDELTA + BIN_W * WDELTA + BIN_WL * PDELTA;
    U0_i           = U0 + BIN_L * LU0 + BIN_W * WU0 + BIN_WL * PU0;
    UA_i           = UA + BIN_L * LUA + BIN_W * WUA + BIN_WL * PUA;
    UD_i           = UD + BIN_L * LUD + BIN_W * WUD + BIN_WL * PUD;
    EU_i           = EU + BIN_L * LEU + BIN_W * WEU + BIN_WL * PEU;
    UCS_i          = UCS + BIN_L * LUCS + BIN_W * WUCS + BIN_WL * PUCS;
    UC_i           = UC + BIN_L * LUC + BIN_W * WUC + BIN_WL * PUC;
    PCLM_i         = PCLM + BIN_L * LPCLM + BIN_W * WPCLM + BIN_WL * PPCLM;
    PCLMCV_i       = PCLMCV + BIN_L * LPCLMCV + BIN_W * WPCLMCV + BIN_WL * PPCLMCV;
    RSW_i          = RSW + BIN_L * LRSW + BIN_W * WRSW + BIN_WL * PRSW;
    RDW_i          = RDW + BIN_L * LRDW + BIN_W * WRDW + BIN_WL * PRDW;
    PRWG_i         = PRWG + BIN_L * LPRWG + BIN_W * WPRWG + BIN_WL * PPRWG;
    PRWB_i         = PRWB + BIN_L * LPRWB + BIN_W * WPRWB + BIN_WL * PPRWB;
    WR_i           = WR + BIN_L * LWR + BIN_W * WWR + BIN_WL * PWR;
    RSWMIN_i       = RSWMIN + BIN_L * LRSWMIN + BIN_W * WRSWMIN + BIN_WL * PRSWMIN;
    RDWMIN_i       = RDWMIN + BIN_L * LRDWMIN + BIN_W * WRDWMIN + BIN_WL * PRDWMIN;
    RDSW_i         = RDSW + BIN_L * LRDSW + BIN_W * WRDSW + BIN_WL * PRDSW;
    RDSWMIN_i      = RDSWMIN + BIN_L * LRDSWMIN + BIN_W * WRDSWMIN + BIN_WL * PRDSWMIN;
    PTWG_i         = PTWG + BIN_L * LPTWG + BIN_W * WPTWG + BIN_WL * PPTWG;
    PDIBLC_i       = PDIBLC + BIN_L * LPDIBLC + BIN_W * WPDIBLC + BIN_WL * PPDIBLC;
    PDIBLCB_i      = PDIBLCB + BIN_L * LPDIBLCB + BIN_W * WPDIBLCB + BIN_WL * PPDIBLCB;
    PSCBE1_i       = PSCBE1 + BIN_L * LPSCBE1 + BIN_W * WPSCBE1 + BIN_WL * PPSCBE1;
    PSCBE2_i       = PSCBE2 + BIN_L * LPSCBE2 + BIN_W * WPSCBE2 + BIN_WL * PPSCBE2;
    PDITS_i        = PDITS + BIN_L * LPDITS + BIN_W * WPDITS + BIN_WL * PPDITS;
    PDITSD_i       = PDITSD + BIN_L * LPDITSD + BIN_W * WPDITSD + BIN_WL * PPDITSD;
    FPROUT_i       = FPROUT + BIN_L * LFPROUT + BIN_W * WFPROUT + BIN_WL * PFPROUT;
    PVAG_i         = PVAG + BIN_L * LPVAG + BIN_W * WPVAG + BIN_WL * PPVAG;
    VSAT_i         = VSAT + BIN_L * LVSAT + BIN_W * WVSAT + BIN_WL * PVSAT;
    PSAT_i         = PSAT + BIN_L * LPSAT + BIN_W * WPSAT + BIN_WL * PPSAT;
    VSATCV_i       = VSATCV + BIN_L * LVSATCV + BIN_W * WVSATCV + BIN_WL * PVSATCV;
    CF_i           = CF + BIN_L * LCF + BIN_W * WCF + BIN_WL * PCF;
    CGSL_i         = CGSL + BIN_L * LCGSL + BIN_W * WCGSL + BIN_WL * PCGSL;
    CGDL_i         = CGDL + BIN_L * LCGDL + BIN_W * WCGDL + BIN_WL * PCGDL;
    CKAPPAS_i      = CKAPPAS + BIN_L * LCKAPPAS + BIN_W * WCKAPPAS + BIN_WL * PCKAPPAS;
    CKAPPAD_i      = CKAPPAD + BIN_L * LCKAPPAD + BIN_W * WCKAPPAD + BIN_WL * PCKAPPAD;
    ALPHA0_i       = ALPHA0 + BIN_L * LALPHA0 + BIN_W * WALPHA0 + BIN_WL * PALPHA0;
    BETA0_i        = BETA0 + BIN_L * LBETA0 + BIN_W * WBETA0 + BIN_WL * PBETA0;
    KVTH0WE_i      = KVTH0WE + BIN_L * LKVTH0WE  + BIN_W * WKVTH0WE + BIN_WL * PKVTH0WE;
    K2WE_i         = K2WE + BIN_L * LK2WE + BIN_W * WK2WE + BIN_WL * PK2WE;
    KU0WE_i        = KU0WE + BIN_L * LKU0WE + BIN_W * WKU0WE + BIN_WL * PKU0WE;
    AGIDL_i        = AGIDL + BIN_L * LAGIDL + BIN_W * WAGIDL + BIN_WL * PAGIDL;
    BGIDL_i        = BGIDL + BIN_L * LBGIDL + BIN_W * WBGIDL + BIN_WL * PBGIDL;
    CGIDL_i        = CGIDL + BIN_L * LCGIDL + BIN_W * WCGIDL + BIN_WL * PCGIDL;
    EGIDL_i        = EGIDL + BIN_L * LEGIDL + BIN_W * WEGIDL + BIN_WL * PEGIDL;
    AGISL_i        = AGISL + BIN_L * LAGISL + BIN_W * WAGISL + BIN_WL * PAGISL;
    BGISL_i        = BGISL + BIN_L * LBGISL + BIN_W * WBGISL + BIN_WL * PBGISL;
    CGISL_i        = CGISL + BIN_L * LCGISL + BIN_W * WCGISL + BIN_WL * PCGISL;
    EGISL_i        = EGISL + BIN_L * LEGISL + BIN_W * WEGISL + BIN_WL * PEGISL;
    UTE_i          = UTE + BIN_L * LUTE + BIN_W * WUTE + BIN_WL * PUTE;
    UA1_i          = UA1 + BIN_L * LUA1 + BIN_W * WUA1 + BIN_WL * PUA1;
    UC1_i          = UC1 + BIN_L * LUC1 + BIN_W * WUC1 + BIN_WL * PUC1;
    UD1_i          = UD1 + BIN_L * LUD1 + BIN_W * WUD1 + BIN_WL * PUD1;
    UCSTE_i        = UCSTE + BIN_L * LUCSTE + BIN_W * WUCSTE + BIN_WL * PUCSTE;
    PRT_i          = PRT + BIN_L * LPRT + BIN_W * WPRT + BIN_WL * PPRT;
    AT_i           = AT + BIN_L * LAT + BIN_W * WAT + BIN_WL * PAT;
    PTWGT_i        = PTWGT + BIN_L * LPTWGT + BIN_W * WPTWGT + BIN_WL * PPTWGT;
    IIT_i          = IIT + BIN_L * LIIT + BIN_W * WIIT + BIN_WL * PIIT;
    TGIDL_i        = TGIDL + BIN_L * LTGIDL + BIN_W * WTGIDL + BIN_WL * PTGIDL;
    IGT_i          = IGT + BIN_L * LIGT + BIN_W * WIGT + BIN_WL * PIGT;
    AIGBINV_i      = AIGBINV + BIN_L * LAIGBINV + BIN_W * WAIGBINV + BIN_WL * PAIGBINV;
    BIGBINV_i      = BIGBINV + BIN_L * LBIGBINV + BIN_W * WBIGBINV + BIN_WL * PBIGBINV;
    CIGBINV_i      = CIGBINV + BIN_L * LCIGBINV + BIN_W * WCIGBINV + BIN_WL * PCIGBINV;
    EIGBINV_i      = EIGBINV + BIN_L * LEIGBINV + BIN_W * WEIGBINV + BIN_WL * PEIGBINV;
    NIGBINV_i      = NIGBINV + BIN_L * LNIGBINV + BIN_W * WNIGBINV + BIN_WL * PNIGBINV;
    AIGBACC_i      = AIGBACC + BIN_L * LAIGBACC + BIN_W * WAIGBACC + BIN_WL * PAIGBACC;
    BIGBACC_i      = BIGBACC + BIN_L * LBIGBACC + BIN_W * WBIGBACC + BIN_WL * PBIGBACC;
    CIGBACC_i      = CIGBACC + BIN_L * LCIGBACC + BIN_W * WCIGBACC + BIN_WL * PCIGBACC;
    NIGBACC_i      = NIGBACC + BIN_L * LNIGBACC + BIN_W * WNIGBACC + BIN_WL * PNIGBACC;
    AIGC_i         = AIGC + BIN_L * LAIGC + BIN_W * WAIGC + BIN_WL * PAIGC;
    BIGC_i         = BIGC + BIN_L * LBIGC + BIN_W * WBIGC + BIN_WL * PBIGC;
    CIGC_i         = CIGC + BIN_L * LCIGC + BIN_W * WCIGC + BIN_WL * PCIGC;
    AIGS_i         = AIGS + BIN_L * LAIGS + BIN_W * WAIGS + BIN_WL * PAIGS;
    BIGS_i         = BIGS + BIN_L * LBIGS + BIN_W * WBIGS + BIN_WL * PBIGS;
    CIGS_i         = CIGS + BIN_L * LCIGS + BIN_W * WCIGS + BIN_WL * PCIGS;
    AIGD_i         = AIGD + BIN_L * LAIGD + BIN_W * WAIGD + BIN_WL * PAIGD;
    BIGD_i         = BIGD + BIN_L * LBIGD + BIN_W * WBIGD + BIN_WL * PBIGD;
    CIGD_i         = CIGD + BIN_L * LCIGD + BIN_W * WCIGD + BIN_WL * PCIGD;
    POXEDGE_i      = POXEDGE + BIN_L * LPOXEDGE + BIN_W * WPOXEDGE + BIN_WL * PPOXEDGE;
    DLCIG_i        = DLCIG + BIN_L * LDLCIG + BIN_W * WDLCIG + BIN_WL * PDLCIG;
    DLCIGD_i       = DLCIGD + BIN_L * LDLCIGD + BIN_W * WDLCIGD + BIN_WL * PDLCIGD;
    NTOX_i         = NTOX + BIN_L * LNTOX + BIN_W * WNTOX + BIN_WL * PNTOX;
    KT1_i          = KT1 + BIN_L * LKT1 + BIN_W * WKT1 + BIN_WL * PKT1;
    KT2_i          = KT2 + BIN_L * LKT2 + BIN_W * WKT2 + BIN_WL * PKT2;
    PSATB_i        = PSATB + BIN_L * LPSATB + BIN_W * WPSATB + BIN_WL * PPSATB;
    A1_i           = A1 + BIN_L * LA1 + BIN_W * WA1 + BIN_WL * PA1;
    A11_i          = A11 + BIN_L * LA11 + BIN_W * WA11 + BIN_WL * PA11;
    A2_i           = A2 + BIN_L * LA2 + BIN_W * WA2 + BIN_WL * PA2;
    A21_i          = A21 + BIN_L * LA21 + BIN_W * WA21 + BIN_WL * PA21;
    K0_i           = K0 + BIN_L * LK0 + BIN_W * WK0 + BIN_WL * PK0;
    M0_i           = M0 + BIN_L * LM0 + BIN_W * WM0 + BIN_WL * PM0;
    K01_i          = K01 + BIN_L * LK01 + BIN_W * WK01 + BIN_WL * PK01;
    M01_i          = M01 + BIN_L * LM01 + BIN_W * WM01 + BIN_WL * PM01;
    NFACTOREDGE_i  = NFACTOREDGE + BIN_L * LNFACTOREDGE + BIN_W * WNFACTOREDGE + BIN_WL * PNFACTOREDGE;
    CITEDGE_i      = CITEDGE + BIN_L * LCITEDGE + BIN_W * WCITEDGE + BIN_WL * PCITEDGE;
    CDSCDEDGE_i    = CDSCDEDGE + BIN_L * LCDSCDEDGE + BIN_W * WCDSCDEDGE + BIN_WL * PCDSCDEDGE;
    CDSCBEDGE_i    = CDSCBEDGE + BIN_L * LCDSCBEDGE + BIN_W * WCDSCBEDGE + BIN_WL * PCDSCBEDGE;
    ETA0EDGE_i     = ETA0EDGE + BIN_L * LETA0EDGE + BIN_W * WETA0EDGE + BIN_WL * PETA0EDGE;
    ETABEDGE_i     = ETABEDGE + BIN_L * LETABEDGE + BIN_W * WETABEDGE + BIN_WL * PETABEDGE;
    KT1EDGE_i      = KT1EDGE + BIN_L * LKT1EDGE + BIN_W * WKT1EDGE + BIN_WL * PKT1EDGE;
    KT1LEDGE_i     = KT1LEDGE + BIN_L * LKT1LEDGE + BIN_W * WKT1LEDGE + BIN_WL * PKT1LEDGE;
    KT2EDGE_i      = KT2EDGE + BIN_L * LKT2EDGE + BIN_W * WKT2EDGE + BIN_WL * PKT2EDGE;
    KT1EXPEDGE_i   = KT1EXPEDGE + BIN_L * LKT1EXPEDGE + BIN_W * WKT1EXPEDGE + BIN_WL * PKT1EXPEDGE;
    TNFACTOREDGE_i = TNFACTOREDGE + BIN_L * LTNFACTOREDGE + BIN_W * WTNFACTOREDGE + BIN_WL * PTNFACTOREDGE;
    TETA0EDGE_i    = TETA0EDGE + BIN_L * LTETA0EDGE + BIN_W * WTETA0EDGE + BIN_WL * PTETA0EDGE;
    K2EDGE_i       = K2EDGE + BIN_L * LK2EDGE + BIN_W * WK2EDGE + BIN_WL * PK2EDGE;
    KVTH0EDGE_i    = KVTH0EDGE + BIN_L * LKVTH0EDGE + BIN_W * WKVTH0EDGE + BIN_WL * PKVTH0EDGE;
    STK2EDGE_i     = STK2EDGE + BIN_L * LSTK2EDGE + BIN_W * WSTK2EDGE + BIN_WL * PSTK2EDGE;
    STETA0EDGE_i   = STETA0EDGE + BIN_L * LSTETA0EDGE + BIN_W * WSTETA0EDGE + BIN_WL * PSTETA0EDGE;

    if (ASYMMOD != 0) begin
        CDSCDR_i  = CDSCDR + BIN_L * LCDSCDR + BIN_W * WCDSCDR + BIN_WL * PCDSCDR;
        ETA0R_i   = ETA0R + BIN_L * LETA0R + BIN_W * WETA0R + BIN_WL * PETA0R;
        U0R_i     = U0R + BIN_L * LU0R + BIN_W * WU0R + BIN_WL * PU0R;
        UAR_i     = UAR + BIN_L * LUAR + BIN_W * WUAR + BIN_WL * PUAR;
        UDR_i     = UDR + BIN_L * LUDR + BIN_W * WUDR + BIN_WL * PUDR;
        UCSR_i    = UCSR + BIN_L * LUCSR + BIN_W * WUCSR + BIN_WL * PUCSR;
        UCR_i     = UCR + BIN_L * LUCR + BIN_W * WUCR + BIN_WL * PUCR;
        PCLMR_i   = PCLMR + BIN_L * LPCLMR + BIN_W * WPCLMR + BIN_WL * PPCLMR;
        PDIBLCR_i = PDIBLCR + BIN_L * LPDIBLCR + BIN_W * WPDIBLCR + BIN_WL * PPDIBLCR;
        VSATR_i   = VSATR + BIN_L * LVSATR + BIN_W * WVSATR + BIN_WL * PVSATR;
        PSATR_i   = PSATR + BIN_L * LPSATR + BIN_W * WPSATR + BIN_WL * PPSATR;
        PTWGR_i   = PTWGR + BIN_L * LPTWGR + BIN_W * WPTWGR + BIN_WL * PPTWGR;
    end

    // Geometrical scaling
    T0        = NDEPL1 * max(pow(Inv_L, NDEPLEXP1) - pow(Inv_Llong, NDEPLEXP1), 0.0) + NDEPL2 * max(pow(Inv_L, NDEPLEXP2) - pow(Inv_Llong, NDEPLEXP2), 0.0);
    T1        = NDEPW * max(pow(Inv_W, NDEPWEXP) - pow(Inv_Wwide, NDEPWEXP), 0.0) + NDEPWL * pow(Inv_W * Inv_L, NDEPWLEXP);
    NDEP_i    = NDEP_i * (1.0 + T0 + T1);
    T0        = NFACTORL * max( pow(Inv_L, NFACTORLEXP) - pow(Inv_Llong, NFACTORLEXP), 0.0);
    T1        = NFACTORW * max( pow(Inv_W, NFACTORWEXP) - pow(Inv_Wwide, NFACTORWEXP), 0.0) + NFACTORWL * pow(Inv_WL, NFACTORWLEXP);
    NFACTOR_i = NFACTOR_i * (1.0 + T0 + T1);
    T0        = (1.0 + CDSCDL * max(pow(Inv_L, CDSCDLEXP) - pow(Inv_Llong, CDSCDLEXP), 0.0));
    CDSCD_i   = CDSCD_i * T0;
    if (ASYMMOD != 0) begin
        CDSCDR_i = CDSCDR_i * T0;
    end
    CDSCB_i = CDSCB_i * (1.0 + CDSCBL * max(pow(Inv_L, CDSCBLEXP) - pow(Inv_Llong, CDSCBLEXP), 0.0));
    U0_i    = MULU0 * U0_i;
    if (MOBSCALE != 1) begin
        if (U0LEXP > 0.0) begin
            U0_i = U0_i * (1.0 - U0L * max(pow(Inv_L, U0LEXP) - pow(Inv_Llong, U0LEXP), 0.0));
            if (ASYMMOD != 0) begin
                U0R_i = U0R_i * (1.0 - U0L * max(pow(Inv_L, U0LEXP) - pow(Inv_Llong, U0LEXP), 0.0));
            end
        end else begin
            U0_i = U0_i * (1.0 - U0L);
            if (ASYMMOD != 0) begin
                U0R_i = U0R_i * (1.0 - U0L);
            end
        end
    end else begin
        U0_i = U0_i * (1.0 - (UP1 * lexp(-Leff / LP1)) - (UP2 * lexp(-Leff / LP2)));
        if (ASYMMOD != 0) begin
            U0R_i = U0R_i * (1.0 - (UP1 * lexp(-Leff / LP1)) - (UP2 * lexp(-Leff / LP2)));
        end
    end
    T0   = UAL * max(pow(Inv_L, UALEXP) - pow(Inv_Llong, UALEXP), 0.0);
    T1   = UAW * max(pow(Inv_W, UAWEXP) - pow(Inv_Wwide, UAWEXP), 0.0) + UAWL * pow(Inv_WL, UAWLEXP);
    UA_i = UA_i * (1.0 + T0 + T1);
    if (ASYMMOD != 0) begin
        UAR_i = UAR_i * (1.0 + T0 + T1);
    end
    T0   = EUL * max(pow(Inv_L, EULEXP) - pow(Inv_Llong, EULEXP), 0.0);
    T1   = EUW * max(pow(Inv_W, EUWEXP) - pow(Inv_Wwide, EUWEXP), 0.0) + EUWL * pow(Inv_WL, EUWLEXP);
    EU_i = EU_i * (1.0 + T0 + T1);
    T0   = 1.0 + UDL * max(pow(Inv_L, UDLEXP) - pow(Inv_Llong, UDLEXP), 0.0);
    UD_i = UD_i * T0;
    if (ASYMMOD != 0) begin
        UDR_i = UDR_i * T0;
    end
    T0   = UCL * max(pow(Inv_L, UCLEXP) - pow(Inv_Llong, UCLEXP), 0.0);
    T1   = UCW * max(pow(Inv_W, UCWEXP) - pow(Inv_Wwide, UCWEXP), 0.0) + UCWL * pow(Inv_WL, UCWLEXP);
    UC_i = UC_i * (1.0 + T0 + T1);
    if (ASYMMOD != 0) begin
        UCR_i = UCR_i * (1.0 + T0 + T1);
    end
    T0     = max(pow(Inv_L, DSUB) - pow(Inv_Llong, DSUB), 0.0);
    ETA0_i = ETA0_i * T0;
    if (ASYMMOD != 0) begin
        ETA0R_i = ETA0R_i * T0;
    end
    ETAB_i   = ETAB_i * max(pow(Inv_L, ETABEXP) - pow(Inv_Llong, ETABEXP), 0.0);
    T0       = 1.0 + PDIBLCL * max(pow(Inv_L, PDIBLCLEXP) - pow(Inv_Llong, PDIBLCLEXP), 0.0);
    PDIBLC_i = PDIBLC_i * T0;
    if (ASYMMOD != 0) begin
        PDIBLCR_i = PDIBLCR_i * T0;
    end
    T0       = DELTA_i * (1.0 + DELTAL * max(pow(Inv_L, DELTALEXP) - pow(Inv_Llong, DELTALEXP), 0.0));
    DELTA_i  = min(T0, 0.5);
    FPROUT_i = FPROUT_i * (1.0 + FPROUTL * max(pow(Inv_L, FPROUTLEXP) - pow(Inv_Llong, FPROUTLEXP), 0.0));
    T0       = (1.0 + PCLML * max(pow(Inv_L, PCLMLEXP) - pow(Inv_Llong, PCLMLEXP), 0.0));
    PCLM_i   = PCLM_i * T0;
    PCLM_i   = max(PCLM_i, 0.0);
    if (ASYMMOD != 0) begin
        PCLMR_i = PCLMR_i * T0;
        PCLMR_i = max(PCLMR_i, 0.0);
    end
    T0     = VSATL * max(pow(Inv_L, VSATLEXP) - pow(Inv_Llong, VSATLEXP), 0.0);
    T1     = VSATW * max(pow(Inv_W, VSATWEXP) - pow(Inv_Wwide, VSATWEXP), 0.0) + VSATWL * pow(Inv_WL, VSATWLEXP);
    VSAT_i = VSAT_i * (1.0 + T0 + T1);
    if (ASYMMOD != 0) begin
        VSATR_i = VSATR_i * (1.0 + T0 + T1);
    end
    PSAT_i = max(PSAT_i * (1.0 + PSATL * max(pow(Inv_L, PSATLEXP) - pow(Inv_Llong, PSATLEXP), 0.0)), 0.25);
    if (ASYMMOD != 0) begin
        PSATR_i = max(PSATR_i * (1.0 + PSATL * max(pow(Inv_L, PSATLEXP) - pow(Inv_Llong, PSATLEXP), 0.0)), 0.25);
    end
    T0     = (1.0 + PTWGL * max(pow(Inv_L, PTWGLEXP) - pow(Inv_Llong, PTWGLEXP), 0.0));
    PTWG_i = PTWG_i * T0;
    if (ASYMMOD != 0) begin
        PTWGR_i = PTWGR_i * T0;
    end
    ALPHA0_i = ALPHA0_i * (1.0 + ALPHA0L * max(pow(Inv_L, ALPHA0LEXP) - pow(Inv_Llong, ALPHA0LEXP), 0.0));
    AGIDL_i  = AGIDL_i * (1.0 + AGIDLL * Inv_L + AGIDLW * Inv_W);
    AGISL_i  = AGISL_i * (1.0 + AGISLL * Inv_L + AGISLW * Inv_W);
    AIGC_i   = AIGC_i * (1.0 + AIGCL * Inv_L + AIGCW * Inv_W);
    AIGS_i   = AIGS_i * (1.0 + AIGSL * Inv_L + AIGSW * Inv_W);
    AIGD_i   = AIGD_i * (1.0 + AIGDL * Inv_L + AIGDW * Inv_W);
    PIGCD_i  = PIGCD * (1.0 + PIGCDL * Inv_L);
    T0       = NDEPCVL1 * max(pow(Inv_Lact, NDEPCVLEXP1) - pow(Inv_Llong, NDEPCVLEXP1), 0.0) + NDEPCVL2 * max( pow(Inv_Lact, NDEPCVLEXP2) - pow(Inv_Llong, NDEPCVLEXP2), 0.0);
    T1       = NDEPCVW * max(pow(Inv_Wact, NDEPCVWEXP) - pow(Inv_Wwide, NDEPCVWEXP), 0.0) + NDEPCVWL * pow(Inv_Wact * Inv_Lact, NDEPCVWLEXP);
    NDEPCV_i = NDEPCV_i * (1.0 + T0 + T1);
    T0       = VFBCVL * max(pow(Inv_Lact, VFBCVLEXP) - pow(Inv_Llong, VFBCVLEXP), 0.0);
    T1       = VFBCVW * max(pow(Inv_Wact, VFBCVWEXP) - pow(Inv_Wwide, VFBCVWEXP), 0.0) + VFBCVWL * pow(Inv_WL, VFBCVWLEXP);
    VFBCV_i  = VFBCV_i * (1.0 + T0 + T1);
    T0       = VSATCVL * max(pow(Inv_Lact, VSATCVLEXP) - pow(Inv_Llong, VSATCVLEXP), 0.0);
    T1       = VSATCVW * max(pow(Inv_W, VSATCVWEXP) - pow(Inv_Wwide, VSATCVWEXP), 0.0) + VSATCVWL * pow(Inv_WL, VSATCVWLEXP);
    VSATCV_i = VSATCV_i * (1.0 + T0 + T1);
    PCLMCV_i = PCLMCV_i * (1.0 + PCLMCVL * max(pow(Inv_Lact, PCLMCVLEXP) - pow(Inv_Llong, PCLMCVLEXP), 0.0));
    PCLMCV_i = max(PCLMCV_i, 0.0);
    T0       = K1L * max(pow(Inv_L, K1LEXP) - pow(Inv_Llong, K1LEXP), 0.0);
    T1       = K1W * max(pow(Inv_W, K1WEXP) - pow(Inv_Wwide, K1WEXP), 0.0) + K1WL * pow(Inv_WL, K1WLEXP);
    K1_i     = K1_i * (1.0 + T0 + T1);
    T0       = K2L * max(pow(Inv_L, K2LEXP) - pow(Inv_Llong, K2LEXP), 0.0);
    T1       = K2W * max(pow(Inv_W, K2WEXP) - pow(Inv_Wwide, K2WEXP), 0.0) + K2WL * pow(Inv_WL, K2WLEXP);
    K2_i     = K2_i * (1.0 + T0 + T1);
    PRWB_i   = PRWB_i * (1.0 + PRWBL * max( pow(Inv_L, PRWBLEXP) - pow(Inv_Llong, PRWBLEXP), 0));

    // Global scaling parameters for temperature
    UTE_i   = UTE_i * (1.0 + Inv_L * UTEL);
    UA1_i   = UA1_i * (1.0 + Inv_L * UA1L);
    UD1_i   = UD1_i * (1.0 + Inv_L * UD1L);
    AT_i    = AT_i * (1.0 + Inv_L * ATL);
    PTWGT_i = PTWGT_i * (1.0 + Inv_L * PTWGTL);
    if ($port_connected(t) == 0) begin
        if (SHMOD == 0 || RTH0 == 0.0) begin
            Temp(t) <+ 0.0;
        end else begin
            $strobe("5 terminal Module, while 't' node is not connected, SH is activated.");
        end
    end
    if (RDSMOD == 1) begin
        RSW_i = RSW_i * (1.0 + RSWL * max(pow(Inv_L, RSWLEXP) - pow(Inv_Llong, RSWLEXP), 0.0));
        RDW_i = RDW_i * (1.0 + RDWL * max(pow(Inv_L, RDWLEXP) - pow(Inv_Llong, RDWLEXP), 0.0));
    end else begin
        RDSW_i = RDSW_i * (1.0 + RDSWL * max(pow(Inv_L, RDSWLEXP) - pow(Inv_Llong, RDSWLEXP), 0.0));
    end

    // Parameter checking
    if (UCS_i < 1.0) begin
        UCS_i = 1.0;
    end else if (UCS_i > 2.0) begin
        UCS_i = 2.0;
    end
    if (ASYMMOD != 0) begin
        if (UCSR_i < 1.0) begin
            UCSR_i = 1.0;
        end else if (UCSR_i > 2.0) begin
            UCSR_i = 2.0;
        end
    end
    if (CGIDL_i < 0.0) begin
        $strobe("Fatal: CGIDL_i = %e is negative.", CGIDL_i);
        $finish(0);
    end
    if (CGISL_i < 0.0) begin
        $strobe("Fatal: CGISL_i = %e is negative.", CGISL_i);
        $finish(0);
    end
    if (CKAPPAD_i <= 0.0) begin
        $strobe("Fatal: CKAPPAD_i = %e is non-positive.", CKAPPAD_i);
        $finish(0);
    end
    if (CKAPPAS_i <= 0.0) begin
        $strobe("Fatal: CKAPPAS_i = %e is non-positive.", CKAPPAS_i);
        $finish(0);
    end
    if (PDITS_i < 0.0) begin
        $strobe("Fatal: PDITS_i = %e is negative.", PDITS_i);
        $finish(0);
    end
    if (CIT_i < 0.0) begin
        $strobe("Fatal: CIT_i = %e is negative.", CIT_i);
        $finish(0);
    end
    if (NFACTOR_i < 0.0) begin
        $strobe("Fatal: NFACTOR_i = %e is negative.", NFACTOR_i);
        $finish(0);
    end
    if (K1_i < 0.0) begin
        $strobe("Fatal: K1_i = %e is negative.", K1_i);
        $finish(0);
    end

    if (NSD_i <= 0.0) begin
        $strobe("Fatal: NSD_i = %e is non-positive.", NSD_i);
        $finish(0);
    end
    if (NDEP_i <= 0.0) begin
        $strobe("Fatal: NDEP_i = %e is non-positive.", NDEP_i);
        $finish(0);
    end
    if (NDEPCV_i <= 0.0) begin
        $strobe("Fatal: NDEPCV_i = %e is non-positive.", NDEPCV_i);
        $finish(0);
    end
    if (IGBMOD != 0) begin
        if (NIGBINV_i <= 0.0) begin
            $strobe("Fatal: NIGBINV_i = %e is non-positive.", NIGBINV_i);
            $finish(0);
        end
        if (NIGBACC_i <= 0.0) begin
            $strobe("Fatal: NIGBACC_i = %e is non-positive.", NIGBACC_i);
            $finish(0);
        end
    end
    if (IGCMOD != 0) begin
        if (POXEDGE_i <= 0.0) begin
            $strobe("Fatal: POXEDGE_i = %e is non-positive.", POXEDGE_i);
            $finish(0);
        end
    end
    if (CDSCD_i < 0.0) begin
        $strobe("Fatal: CDSCD_i = %e is negative.", CDSCD_i);
        $finish(0);
    end
    if (ASYMMOD != 0) begin
        if (CDSCDR_i < 0.0) begin
            $strobe("Fatal: CDSCDR_i = %e is negative.", CDSCDR_i);
            $finish(0);
        end
    end
    if (DLCIG_i < 0.0) begin
        $strobe("Warning: DLCIG = %e is negative, setting it to 0.", DLCIG_i);
        DLCIG_i = 0.0;
    end
    if (DLCIGD_i < 0.0) begin
        $strobe("Warning: DLCIGD = %e is negative, setting it to 0.", DLCIGD_i);
        DLCIGD_i = 0.0;
    end
    if (M0_i < 0.0) begin
        $strobe("Warning: M0_i = %e is negative, setting it to 0.", M0_i);
        M0_i = 0.0;
    end

    // Initialize variables used in geometry macros
    nuEndD = 0.0; nuEndS = 0.0; nuIntD = 0.0; nuIntS = 0.0; Rend = 0.0; Rint = 0.0;

    // Process drain series resistance
    DMCGeff = DMCG - DMCGT;
    DMCIeff = DMCI;
    DMDGeff = DMDG - DMCGT;

    // Processing S/D resistance and conductance below
    if($param_given(NRS)) begin
        RSourceGeo = RSH * NRS;
    end else if (RGEOMOD > 0 && RSH > 0.0) begin
        `BSIMBULKRdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 1, RSourceGeo)
    end else begin
        RSourceGeo = 0.0;
    end

    if ($param_given(NRD)) begin
        RDrainGeo = RSH * NRD;
    end else if (RGEOMOD > 0 && RSH > 0.0) begin
        `BSIMBULKRdseffGeo(NF, GEOMOD, RGEOMOD, MINZ, Weff, RSH, DMCGeff, DMCIeff, DMDGeff, 0, RDrainGeo)
    end else begin
        RDrainGeo = 0.0;
    end

    // Clamping of source/drain resistances
    if (RSourceGeo <= 1.0e-3) begin
        RSourceGeo = 1.0e-3;
    end
    if (RDrainGeo <= 1.0e-3) begin
        RDrainGeo = 1.0e-3;
    end

    if (RDSMOD == 1) begin
        if (RSWMIN_i <= 0.0) begin
            RSWMIN_i = 0.0;
        end
        if (RDWMIN_i <= 0.0) begin
            RDWMIN_i = 0.0;
        end
        if (RSW_i <= 0.0) begin
            RSW_i = 0.0;
        end
        if (RDW_i <= 0.0) begin
            RDW_i = 0.0;
        end
    end else begin
        if (RDSWMIN_i <= 0.0) begin
            RDSWMIN_i = 0.0;
        end
        if (RDSW_i <= 0.0) begin
            RDSW_i = 0.0;
        end
    end

    // Body resistance network
    Grbsb = 0.0;
    Grbdb = 0.0;
    Grbpb = 0.0;
    Grbps = 0.0;
    Grbpd = 0.0;
    if (RBODYMOD != 0) begin
        Lnl  = lln(Leff * 1.0e6);
        Lnw  = lln(Weff * 1.0e6);
        Lnnf = lln(NF);
        Bodymode = 5;
        Rbpb = RBPB;
        Rbpd = RBPD;
        Rbps = RBPS;
        Rbdb = RBDB;
        Rbsb = RBSB;
        if (!$param_given(RBPS0) || !$param_given(RBPD0)) begin
            Bodymode = 1;
        end
        else if (!$param_given(RBSBX0) && !$param_given(RBSBY0) || !$param_given(RBDBX0) && !$param_given(RBDBY0)) begin
            Bodymode = 3;
        end
        if (RBODYMOD == 2) begin
            if (Bodymode == 5) begin
                Rbsbx = RBSBX0 * lexp(RBSDBXL * Lnl + RBSDBXW * Lnw + RBSDBXNF * Lnnf);
                Rbsby = RBSBY0 * lexp(RBSDBYL * Lnl + RBSDBYW * Lnw + RBSDBYNF * Lnnf);
                Rbsb  = Rbsbx * Rbsby / (Rbsbx + Rbsby);
                Rbdbx = RBDBX0 * lexp(RBSDBXL * Lnl + RBSDBXW * Lnw + RBSDBXNF * Lnnf);
                Rbdby = RBDBY0 * lexp(RBSDBYL * Lnl + RBSDBYW * Lnw + RBSDBYNF * Lnnf);
                Rbdb  = Rbdbx * Rbdby / (Rbdbx + Rbdby);
            end
            if (Bodymode == 3 || Bodymode == 5) begin
                Rbps = RBPS0 * lexp(RBPSL * Lnl + RBPSW * Lnw + RBPSNF * Lnnf);
                Rbpd = RBPD0 * lexp(RBPDL * Lnl + RBPDW * Lnw + RBPDNF * Lnnf);
            end
            Rbpbx = RBPBX0 * lexp(RBPBXL * Lnl + RBPBXW * Lnw + RBPBXNF * Lnnf);
            Rbpby = RBPBY0 * lexp(RBPBYL * Lnl + RBPBYW * Lnw + RBPBYNF * Lnnf);
            Rbpb  = Rbpbx * Rbpby / (Rbpbx + Rbpby);
        end
        if (RBODYMOD == 1 || (RBODYMOD == 2 && Bodymode == 5)) begin
            if (Rbdb < 1.0e-3) begin
                Grbdb = 1.0e3;  // in mho
            end else begin
                Grbdb = GBMIN + 1.0 / Rbdb;
            end
            if (Rbpb < 1.0e-3) begin
                Grbpb = 1.0e3;
            end else begin
                Grbpb = GBMIN + 1.0 / Rbpb;
            end
            if (Rbps < 1.0e-3) begin
                Grbps = 1.0e3;
            end else begin
                Grbps = GBMIN + 1.0 / Rbps;
            end
            if (Rbsb < 1.0e-3) begin
                Grbsb = 1.0e3;
            end else begin
                Grbsb = GBMIN + 1.0 / Rbsb;
            end
            if (Rbpd < 1.0e-3) begin
                Grbpd = 1.0e3;
            end else begin
                Grbpd = GBMIN + 1.0 / Rbpd;
            end
        end else if (RBODYMOD == 2 && Bodymode == 3) begin
            Grbdb = GBMIN;
            Grbsb = GBMIN;
            if (Rbpb < 1.0e-3) begin
                Grbpb = 1.0e3;
            end else begin
                Grbpb = GBMIN + 1.0 / Rbpb;
            end
            if (Rbps < 1.0e-3) begin
                Grbps = 1.0e3;
            end else begin
                Grbps = GBMIN + 1.0 / Rbps;
            end
            if (Rbpd < 1.0e-3) begin
                Grbpd = 1.0e3;
            end else begin
                Grbpd = GBMIN + 1.0 / Rbpd;
            end
        end else if (RBODYMOD == 2 && Bodymode == 1) begin
            Grbdb = GBMIN;
            Grbsb = GBMIN;
            Grbps = 1.0e3;
            Grbpd = 1.0e3;
            if (Rbpb < 1.0e-3) begin
                Grbpb = 1.0e3;
            end else begin
                Grbpb = GBMIN + 1.0 / Rbpb;
            end
        end
    end

    // Gate process resistance
    Grgeltd = RSHG * (XGW + Weffcj / 3.0 / NGCON) / (NGCON * NF * (Lnew - XGL));
    if (Grgeltd > 0.0) begin
        Grgeltd = 1.0 / Grgeltd;
    end else begin
        Grgeltd = 1.0e3;
        if (RGATEMOD != 0) begin
            `STROBE("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
        end
    end
    T0           = TOXE * TOXE;
    T1           = TOXE * POXEDGE_i;
    T2           = T1 * T1;
    ToxRatio     = lexp(NTOX_i * lln(TOXREF / TOXE)) / T0;
    ToxRatioEdge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
    Aechvb       = (TYPE == `ntype) ? 4.97232e-7 : 3.42537e-7;
    Bechvb       = (TYPE == `ntype) ? 7.45669e11 : 1.16645e12;
    AechvbEdge   = Aechvb * Weff * ToxRatioEdge;
    BechvbEdge   = -Bechvb * TOXE * POXEDGE_i;
    Aechvb       = Aechvb * (Weff * Leff * ToxRatio);
    Bechvb       = -Bechvb * TOXE;
    Weff_SH = WTH0 + Weff;

    // Parameters for self-heating
    if((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        gth = Weff_SH * NF / RTH0;
        cth = CTH0 * Weff_SH * NF;
    end else begin
        // set gth to some value to prevent a singular G matrix
        gth = 1.0;
        cth = 0.0;
    end

    // Temperature Dependent Calculations Begin Here
    if (TNOM <= -`P_CELSIUS0) begin
        T0 = `REFTEMP - `P_CELSIUS0;
        $strobe("Warning: TNOM = %e C <= %e C. Setting TNOM to %e C.", TNOM, -`P_CELSIUS0, T0);
        Tnom = `REFTEMP;
    end else begin
        Tnom = TNOM + `P_CELSIUS0;
    end
    DevTemp = $temperature + DTEMP;

    // Calculate temperature dependent values for self-heating effect
    if ((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        delTemp1 = Temp(t);
    end else begin
        delTemp1 = 0.0;
    end
    DevTemp    = delTemp1 + DevTemp;
    T_DELTA_SH = Temp(t);
    T_TOTAL_K  = DevTemp;
    T_TOTAL_C  = DevTemp - `P_CELSIUS0;
    Vt         = `KboQ * DevTemp;
    inv_Vt     = 1.0 / Vt;
    TRatio     = DevTemp / Tnom;
    delTemp    = DevTemp - Tnom;
    Vtm        = `KboQ * DevTemp;
    Vtm0       = `KboQ * Tnom;
    Eg         = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
    Eg0        = BG0SUB - TBGASUB * Tnom * Tnom / (Tnom + TBGBSUB);
    T1         = (DevTemp / Tnom) * sqrt(DevTemp / Tnom);
    ni         = NI0SUB * T1 * lexp(Eg / (2.0 * Vtm0) - Eg / (2.0 * Vtm));
    if ((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        T0   = lln(NDEP_i / ni);
        phib = sqrt(T0 * T0 + 1.0e-6);
    end else begin
        phib = lln(NDEP_i / ni);
    end
    if ((SHMOD != 0) && (RTH0 > 0.0) && (Weff_SH > 0.0)) begin
        T0  = lln(NDEP_i * NSD_i / (ni * ni));
        Vbi = sqrt(T0 * T0 + 1.0e-6);
    end else begin
        Vbi = lln(NDEP_i * NSD_i / (ni * ni));
    end
    if (NGATE_i > 0.0) begin
        Vfbsdr = -devsign * Vt * lln(NGATE_i / NSD_i) + VFBSDOFF;
    end else begin
        Vfbsdr = 0.0;
    end

    // Short channel effects
    Phist     = max(0.4 + Vt * phib + PHIN_i, 0.4);
    sqrtPhist = sqrt(Phist);
    T1DEP     = sqrt(2.0 * epssi / (`q * NDEP_i));
    litl      = sqrt((epssi / epsox) * TOXE * XJ_i);
    NFACTOR_t = NFACTOR_i * hypsmooth((1.0 + TNFACTOR * (TRatio - 1.0)), 1e-3);
    ETA0_t    = ETA0_i * (1.0 + TETA0 * (TRatio - 1.0));
    if (ASYMMOD != 0) begin
        ETA0R_t = ETA0R_i * (1.0 + TETA0 * (TRatio - 1.0));
    end

    // Mobility degradation
    eta_mu = (TYPE != `ntype) ? (`Oneby3 * ETAMOB) : (0.5 * ETAMOB);
    U0_t   = U0_i * pow(TRatio, UTE_i);
    UA_t   = UA_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
    UC_t   = UC_i * hypsmooth(1.0 + UC1_i * delTemp - 1.0e-6, 1.0e-3);
    UD_t   = UD_i * pow(TRatio, UD1_i);
    UCS_t  = UCS_i * pow(TRatio, UCSTE_i);
    if (ASYMMOD != 0) begin
        U0R_t  = U0R_i * pow(TRatio, UTE_i);
        UAR_t  = UAR_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
        UCR_t  = UCR_i * hypsmooth(1.0 + UC1_i * delTemp - 1.0e-6, 1.0e-3);
        UDR_t  = UDR_i * pow(TRatio, UD1_i);
        UCSR_t = UCSR_i * pow(TRatio, UCSTE_i);
    end
    rdstemp = pow(TRatio, PRT_i);
    VSAT_t  = VSAT_i * pow(TRatio, -AT_i);
    if (VSAT_t < 100.0) begin
        $strobe("Warning: VSAT(%f) = %e is less than 100, setting it to 100.", DevTemp, VSAT_t);
        VSAT_t = 100.0;
    end
    if (ASYMMOD != 0) begin
        VSATR_t = VSATR_i * pow(TRatio, -AT_i);
        if(VSATR_t < 100.0) begin
            $strobe("Warning: VSATR(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATR_t);
            VSATR_t = 100.0;
        end
    end
    VSATCV_t = VSATCV_i * pow(TRatio, -AT_i);
    if (VSATCV_t < 100.0) begin
        $strobe("Warning: VSATCV(%f) = %e is less than 100, setting it to 100.", DevTemp, VSATCV_t);
        VSATCV_t = 100.0;
    end
    DELTA_t = 1.0 / ( hypsmooth((1.0 / DELTA_i) * (1.0 + TDELTA * delTemp) - 2.0 , 1.0e-3) + 2.0);
    PTWG_t  = PTWG_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
    if (ASYMMOD != 0) begin
        PTWGR_t = PTWGR_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
    end
    A1_t    = A1_i * hypsmooth(1.0 + A11_i * delTemp - 1.0e-6, 1.0e-3);
    A2_t    = A2_i * hypsmooth(1.0 + A21_i * delTemp - 1.0e-6, 1.0e-3);
    BETA0_t = BETA0_i * pow(TRatio, IIT_i);
    BGIDL_t = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
    BGISL_t = BGISL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
    igtemp  = lexp(IGT_i * lln(TRatio));
    K0_t    = K0_i * hypsmooth(1.0 + K01_i * delTemp - 1.0e-6, 1.0e-3);
    M0_t    = M0_i * hypsmooth(1.0 + M01_i * delTemp - 1.0e-6, 1.0e-3);

    // Diode Model temperature Code Start
    CJS_t     = CJS * hypsmooth(1.0 + TCJ * delTemp - 1.0e-6, 1.0e-3);
    CJD_t     = CJD * hypsmooth(1.0 + TCJ * delTemp - 1.0e-6, 1.0e-3);
    CJSWS_t   = CJSWS * hypsmooth(1.0 + TCJSW * delTemp - 1.0e-6, 1.0e-3);
    CJSWD_t   = CJSWD * hypsmooth(1.0 + TCJSW * delTemp - 1.0e-6, 1.0e-3);
    CJSWGS_t  = CJSWGS * hypsmooth(1.0 + TCJSWG * delTemp - 1.0e-6, 1.0e-3);
    CJSWGD_t  = CJSWGD * hypsmooth(1.0 + TCJSWG * delTemp - 1.0e-6, 1.0e-3);
    PBS_t     = hypsmooth(PBS - TPB * delTemp - 0.01, 1.0e-3) + 0.01;
    PBD_t     = hypsmooth(PBD - TPB * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWS_t   = hypsmooth(PBSWS - TPBSW * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWD_t   = hypsmooth(PBSWD - TPBSW * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWGS_t  = hypsmooth(PBSWGS - TPBSWG * delTemp - 0.01, 1.0e-3) + 0.01;
    PBSWGD_t  = hypsmooth(PBSWGD - TPBSWG * delTemp - 0.01, 1.0e-3) + 0.01;
    T0        = Eg0 / Vtm0 - Eg / Vtm;
    T1        = lln(TRatio);
    T3        = lexp((T0 + XTIS * T1) / NJS);
    JSS_t     = JSS * T3;
    JSWS_t    = JSWS * T3;
    JSWGS_t   = JSWGS * T3;
    T3        = lexp((T0 + XTID * T1) / NJD);
    JSD_t     = JSD * T3;
    JSWD_t    = JSWD * T3;
    JSWGD_t   = JSWGD * T3;
    JTSS_t    = JTSS * lexp(Eg0 * XTSS * (TRatio - 1.0) / Vtm);
    JTSSWS_t  = JTSSWS * lexp(Eg0 * XTSSWS * (TRatio - 1.0) / Vtm);
    JTSSWGS_t = JTSSWGS * (sqrt(JTWEFF / Weffcj) + 1.0) * lexp(Eg0 * XTSSWGS * (TRatio - 1) / Vtm);
    JTSD_t    = JTSD * lexp(Eg0 * XTSD * (TRatio - 1.0) / Vtm);
    JTSSWD_t  = JTSSWD * lexp(Eg0 * XTSSWD * (TRatio - 1.0) / Vtm);
    JTSSWGD_t = JTSSWGD * (sqrt(JTWEFF / Weffcj) + 1.0) * lexp(Eg0 * XTSSWGD * (TRatio - 1) / Vtm);

    // All NJT*'s smoothed to 0.01 to prevent divide by zero / negative values
    NJTS_t     = hypsmooth(NJTS * (1.0 + TNJTS * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSW_t   = hypsmooth(NJTSSW * (1.0 + TNJTSSW * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSWG_t  = hypsmooth(NJTSSWG * (1.0 + TNJTSSWG * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSD_t    = hypsmooth(NJTSD * (1.0 + TNJTSD * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSWD_t  = hypsmooth(NJTSSWD * (1.0 + TNJTSSWD * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;
    NJTSSWGD_t = hypsmooth(NJTSSWGD * (1.0 + TNJTSSWGD * (TRatio - 1.0)) - 0.01, 1.0e-3) + 0.01;

    // Effective Source/Drain junction area and perimeter
    `BSIMBULKPAeffGeo(NF, GEOMOD, MINZ, Weffcj, DMCGeff, DMCIeff, DMDGeff, temp_PSeff, temp_PDeff, temp_ASeff, temp_ADeff)
    if ($param_given(AS)) begin
        ASeff = AS * WMLT * LMLT;
    end else begin
        ASeff = temp_ASeff;
    end
    if (ASeff < 0.0) begin
        $strobe("Warning: (instance %M) ASeff = %e is negative, set to zero.", ASeff);
        ASeff = 0.0;
    end
    if ($param_given(AD)) begin
        ADeff = AD * WMLT * LMLT;
    end else begin
        ADeff = temp_ADeff;
    end
    if (ADeff < 0.0) begin
        $strobe("Warning: (instance %M) ADeff = %e is negative, set to zero.", ADeff);
        ADeff = 0.0;
    end
    if ($param_given(PS)) begin
        if (PERMOD == 0) begin
            // PS does not include gate-edge perimeter
            PSeff = PS * WMLT;
        end else begin
            // PS includes gate-edge perimeter
            PSeff = max(PS * WMLT - Weffcj * NF, 0.0);
        end
    end else begin
        PSeff = temp_PSeff;
        if (PSeff < 0.0) begin
            $strobe("Warning: (instance %M) PSeff = %e is negative.Set to 0.0", PSeff);
            PSeff = 0.0;
        end
    end
    if ($param_given(PD)) begin
        if (PERMOD == 0) begin
            // PD does not include gate-edge perimeter
            PDeff = PD * WMLT;
        end else begin
            // PD includes gate-edge perimeter
            PDeff = max(PD * WMLT - Weffcj * NF, 0.0);
        end
    end else begin
        PDeff = temp_PDeff;
        if (PDeff < 0.0) begin
            $strobe("Warning: (instance %M) PDeff = %e is negative.Set to 0.0", PDeff);
            PDeff = 0.0;
        end
    end
    Isbs = ASeff * JSS_t + PSeff * JSWS_t + Weffcj * NF * JSWGS_t;
    if (Isbs > 0.0) begin
        Nvtms    = Vtm * NJS;
        XExpBVS  = lexp(-BVS / Nvtms) * XJBVS;
        T2       = max(IJTHSFWD / Isbs, 10.0);
        Tb       = 1.0 + T2 - XExpBVS;
        VjsmFwd  = Nvtms * lln(0.5 * (Tb + sqrt(Tb * Tb + 4.0 * XExpBVS)));
        T0       = lexp(VjsmFwd / Nvtms);
        IVjsmFwd = Isbs * (T0 - XExpBVS / T0 + XExpBVS - 1.0);
        SslpFwd  = Isbs * (T0 + XExpBVS / T0) / Nvtms;
        T2       = hypsmooth(IJTHSREV / Isbs - 10.0, 1.0e-3) + 10.0;
        VjsmRev  = -BVS - Nvtms * lln((T2 - 1.0) / XJBVS);
        T1       = XJBVS * lexp(-(BVS + VjsmRev) / Nvtms);
        IVjsmRev = Isbs * (1.0 + T1);
        SslpRev  = -Isbs * T1 / Nvtms;
    end else begin
        Nvtms    = 0.0;
        XExpBVS  = 0.0;
        VjsmFwd  = 0.0;
        IVjsmFwd = 0.0;
        SslpFwd  = 0.0;
        VjsmRev  = 0.0;
        IVjsmRev = 0.0;
        SslpRev  = 0.0;
    end

    // Drain-side junction current
    Isbd = ADeff * JSD_t + PDeff * JSWD_t + Weffcj * NF * JSWGD_t;
    if (Isbd > 0.0) begin
        Nvtmd    = Vtm * NJD;
        XExpBVD  = lexp(-BVD / Nvtmd) * XJBVD;
        T2       = max(IJTHDFWD / Isbd, 10.0);
        Tb       = 1.0 + T2 - XExpBVD;
        VjdmFwd  = Nvtmd * lln(0.5 * (Tb + sqrt(Tb * Tb + 4.0 * XExpBVD)));
        T0       = lexp(VjdmFwd / Nvtmd);
        IVjdmFwd = Isbd * (T0 - XExpBVD / T0 + XExpBVD - 1.0);
        DslpFwd  = Isbd * (T0 + XExpBVD / T0) / Nvtmd;
        T2       = hypsmooth(IJTHDREV / Isbd - 10.0, 1.0e-3) + 10.0;
        VjdmRev  = -BVD - Nvtmd * lln((T2 - 1.0) / XJBVD);
        T1       = XJBVD * lexp(-(BVD + VjdmRev) / Nvtmd);
        IVjdmRev = Isbd * (1.0 + T1);
        DslpRev  = -Isbd * T1 / Nvtmd;
    end else begin
        Nvtmd    = 0.0;
        XExpBVD  = 0.0;
        VjdmFwd  = 0.0;
        IVjdmFwd = 0.0;
        DslpFwd  = 0.0;
        VjdmRev  = 0.0;
        IVjdmRev = 0.0;
        DslpRev  = 0.0;
    end

    // STI stress equations
    if((SA > 0.0) && (SB > 0.0) && ((NF == 1.0) || ((NF > 1.0) && (SD > 0.0)))) begin
        T0              = pow(Lnew, LLODKU0);
        W_tmp_stress    = Wnew + WLOD;
        T1              = pow(W_tmp_stress, WLODKU0);
        tmp1_stress     = LKU0 / T0 + WKU0 / T1 + PKU0 / (T0 * T1);
        kstress_u0      = 1.0 + tmp1_stress;
        T0              = pow(Lnew, LLODVTH);
        T1              = pow(W_tmp_stress, WLODVTH);
        tmp1_stress_vth = LKVTH0 / T0 + WKVTH0 / T1 + PKVTH0 / (T0 * T1);
        kstress_vth0    = 1.0 + tmp1_stress_vth;
        T0              = TRatio - 1.0;
        ku0_temp        = kstress_u0 * (1.0 + TKU0 * T0) + 1.0e-9;
        for (i = 0; i < NF; i = i + 1) begin : forloop
            T0     = 1.0 / NF / (SA + 0.5 * L_mult + i * (SD + L_mult));
            T1     = 1.0 / NF / (SB + 0.5 * L_mult + i * (SD + L_mult));
            Inv_sa = Inv_sa + T0;
            Inv_sb = Inv_sb + T1;
        end
        Inv_saref   = 1.0 / (SAREF + 0.5 * L_mult);
        Inv_sbref   = 1.0 / (SBREF + 0.5 * L_mult);
        Inv_odref   = Inv_saref + Inv_sbref;
        rho_ref     = (KU0 / ku0_temp) * Inv_odref;
        Inv_od      = Inv_sa + Inv_sb;
        rho         = (KU0 / ku0_temp) * Inv_od;
        mu0_mult    = (1.0 + rho) / (1.0 + rho_ref);
        vsat_mult   = (1.0 + rho * KVSAT) / (1.0 + rho_ref * KVSAT);
        vth0_stress = (KVTH0 / kstress_vth0) * (Inv_od - Inv_odref);
        k2_stress   = (STK2 / pow(kstress_vth0, LODK2)) * (Inv_od - Inv_odref);
        eta_stress  = (STETA0 / pow(kstress_vth0, LODETA0)) * (Inv_od - Inv_odref);
        U0_t        = U0_t * mu0_mult;
        VSAT_t      = VSAT_t * vsat_mult;
        K2_i        = K2_i + k2_stress;
        ETA0_t      = ETA0_t + eta_stress;
        if (EDGEFET == 1) begin
            vth0_stress_EDGE = (KVTH0EDGE_i / kstress_vth0) * (Inv_od - Inv_odref);
            k2_stress_EDGE   = (STK2EDGE_i / pow(kstress_vth0, LODK2)) * (Inv_od - Inv_odref);
            eta_stress_EDGE  = (STETA0EDGE_i / pow(kstress_vth0, LODETA0)) * (Inv_od - Inv_odref);
        end
        K2_EDGE   = K2EDGE_i + k2_stress_EDGE;
        ETA0_EDGE = ETA0EDGE_i + eta_stress_EDGE;
    end else begin
        vth0_stress = 0.0;
        vth0_stress_EDGE = 0.0;
    end

    // Well proximity effect
    if (WPEMOD == 1) begin
        Wdrn      = W / NF;
        local_sca = SCA;
        local_scb = SCB;
        local_scc = SCC;
        if (!$param_given(SCA) && !$param_given(SCB) && !$param_given(SCC)) begin
            if($param_given(SC) && SC > 0.0) begin
                T1        = SC + Wdrn;
                T2        = 1.0 / SCREF;
                local_sca = SCREF * SCREF / (SC * T1);
                local_scb = ((0.1 * SC + 0.01 * SCREF) * lexp(-10.0 * SC * T2)  - (0.1 * T1 + 0.01 * SCREF) *
                            lexp(-10.0 * T1 * T2)) / Wdrn;
                local_scc = ((0.05 * SC + 0.0025 * SCREF) * lexp(-20.0 * SC * T2)  - (0.05 * T1 + 0.0025 * SCREF) *
                            lexp(-20.0 * T1 * T2)) / Wdrn;
            end else begin
                `STROBE("Warning: (Instance %M) No WPE as none of SCA, SCB, SCC, SC is given and/or SC not positive.");
            end
        end
    end
    vth0_well = KVTH0WE_i * (local_sca + WEB * local_scb + WEC * local_scc);
    k2_well   = K2WE_i * (local_sca + WEB * local_scb + WEC * local_scc);
    mu_well   = 1.0 + KU0WE_i * (local_sca + WEB * local_scb + WEC * local_scc);
    U0_t      = U0_t * mu_well;
    K2_i      = K2_i + k2_well;

    // Load Terminal Voltages
    Vg            = devsign * V(gi, bi);
    Vd            = devsign * V(di, bi);
    Vs            = devsign * V(si, bi);
    Vds           = Vd - Vs;
    Vds_noswap    = Vds;
    Vsb_noswap    = Vs;
    Vdb_noswap    = Vd;
    Vbs_jct       = devsign * V(sbulk, si);
    Vbd_jct       = devsign * V(dbulk, di);
    Vgd_noswap    = Vg - Vd;
    Vgs_noswap    = Vg - Vs;
    Vgd_ov_noswap = devsign * V(gm, di);
    Vgs_ov_noswap = devsign * V(gm, si);

    // Terminal voltage conditioning
    // Source-drain interchange
    sigvds = 1.0;
    if (Vds < 0.0) begin
        sigvds = -1.0;
        Vd = devsign * V(si, bi);
        Vs = devsign * V(di, bi);
    end
    Vds  = Vd - Vs;
    T0   = AVDSX * Vds;
    if (T0 > `EXPL_THRESHOLD) begin
       T1 = T0;
    end else begin
       T1 = ln(1.0 + exp(T0));
    end
    Vdsx = ((2.0/AVDSX) * T1) - Vds - ((2.0/AVDSX) * ln(2.0));
    Vbsx = -(Vs + 0.5 * (Vds - Vdsx));

    // Asymmetry model
    T0 = tanh(0.6 * Vds_noswap / Vtm);
    wf = 0.5 + 0.5 * T0;
    wr = 1.0 - wf;
    if (ASYMMOD != 0) begin
        CDSCD_a  = CDSCDR_i * wr + CDSCD_i * wf;
        ETA0_a   = ETA0R_t * wr + ETA0_t * wf;
        PDIBLC_a = PDIBLCR_i * wr + PDIBLC_i * wf;
        PCLM_a   = PCLMR_i * wr + PCLM_i * wf;
        PSAT_a   = PSATR_i * wr + PSAT_i * wf;
        VSAT_a   = VSATR_t * wr + VSAT_t * wf;
        PTWG_a   = PTWGR_t * wr + PTWG_t * wf;
        U0_a     = U0R_t * wr + U0_t * wf;
        UA_a     = UAR_t * wr + UA_t * wf;
        UC_a     = UCR_t * wr + UC_t * wf;
        UD_a     = UDR_t * wr + UD_t * wf;
        UCS_a    = UCSR_t * wr + UCS_t * wf;
    end else begin
        CDSCD_a  = CDSCD_i;
        ETA0_a   = ETA0_t;
        PDIBLC_a = PDIBLC_i;
        PCLM_a   = PCLM_i;
        PSAT_a   = PSAT_i;
        VSAT_a   = VSAT_t;
        PTWG_a   = PTWG_t;
        U0_a     = U0_t;
        UA_a     = UA_t;
        UC_a     = UC_t;
        UD_a     = UD_t;
        UCS_a    = UCS_t;
    end

    // SCE, DIBL, SS degradation effects, Ref: BSIM4 Model
    `Smooth(Phist - Vbsx, 0.05, 0.1, PhistVbs)
    sqrtPhistVbs = sqrt(PhistVbs);
    Xdep         = T1DEP * sqrtPhistVbs;
    Cdep         = epssi / Xdep;
    cdsc         = CIT_i + NFACTOR_t + CDSCD_a * Vdsx - CDSCB_i * Vbsx;
    T1           = 1.0 + cdsc/Cox;
    `Smooth(T1, 1, 0.05, n)
    nVt     = n * Vt;
    inv_nVt = 1.0 / nVt;

    // Vth Shift for DIBL
    dVth_dibl = -(ETA0_a + ETAB_i * Vbsx) * Vdsx;

    // Vth shift with temperature
    dvth_temp = (KT1_i + KT1L / Leff + KT2_i * Vbsx) * (pow(TRatio, KT1EXP) - 1.0);
    `Smooth2(dVth_dibl, 0.0, 5.0e-5, dVth_dibl)

    // Vth Correction for Pocket Implant
    if (DVTP0_i > 0.0) begin
        T0 = -DVTP1_i * Vdsx;
        if (T0 < -`EXPL_THRESHOLD) begin
            T2 = `MIN_EXPL;
        end else begin
            T2 = lexp(T0);
        end
        T3        = Leff + DVTP0_i * (1.0 + T2);
        dVth_ldop = -nVt * lln(Leff / T3);
    end else begin
        dVth_ldop = 0.0;
    end
    T4        = DVTP5_i + DVTP2_i / pow(Leff, DVTP3_i);
    dVth_ldop = dVth_ldop - T4 * tanh(DVTP4_i * Vdsx);

    // Normalization of terminal and flatband voltage by nVt
    VFB_i = VFB_i + DELVTO;
    vg    = Vg * inv_nVt;
    vs    = Vs * inv_nVt;
    vfb   = VFB_i * inv_nVt;

    // Compute dVth_VNUD with "first-order" and "second-order" body-bias effect
    dVth_VNUD = K1_i * (sqrtPhistVbs - sqrtPhist) - K2_i * Vbsx;
    Vth_shift = dVth_dibl + dVth_ldop + dVth_VNUD - dvth_temp + vth0_stress + vth0_well;
    vgfb      = vg - vfb - Vth_shift * inv_nVt;

    // Threshold voltage for operating point information
    gam     = sqrt(2.0 * `q * epssi * NDEP_i * inv_Vt) / Cox;
    q_vth   = 0.5;
    T0      = hypsmooth((2.0 * phib + Vs * inv_Vt), 1.0e-3);
    nq      = 1.0 + gam / (2.0 * sqrt(T0));
    psip_th = hypsmooth((Vs * inv_Vt + 2.0 * phib + lln(q_vth) + 2.0 * q_vth + lln(2.0 * nq / gam * (2.0 * q_vth * nq / gam + 2.0 * sqrt(T0)))), 1.0e-3);
    VTH     = devsign * (VFB_i + (psip_th - Vs * inv_Vt) * Vt + Vt * gam * sqrt(psip_th) + Vth_shift);

    // Normalized body factor
    gam     = sqrt(2.0 * `q * epssi * NDEP_i * inv_nVt) / Cox;
    inv_gam = 1.0 / gam;

    // psip: pinch-off voltage
    phib_n = phib / n;
    `PO_psip(vgfb, gam, 0, phib_n, psip)

    // normalized inversion charge at source end of channel
    `BSIM_q(psip, phib_n, vs, gam, qs)

    // average charge-surf. pot. slope, Ref: Charge-based MOS Transistor Modeling by C. Enz & E. Vittoz
    `Smooth(psip, 1.0, 2.0, psipclamp)
    sqrtpsip = sqrt(psipclamp);

    // source side surf pot.
    psiavg = psip - 2.0 * qs;
    `Smooth(psiavg, 1.0, 2.0, T0)
    nq = 1.0 + gam / (sqrtpsip + sqrt(T0));

    // Drain Saturation Voltage
    EeffFactor = 1.0e-8 / (epsratio * TOXE);
    T0 = nVt * (vgfb - psip - 2.0 * qs * (nq - 1.0));
    `Smooth(T0, 0, 0.1, qbs)

    // Source side qi and qb for Vdsat- normalized to Cox
    qis = 2.0 * nq * nVt * qs;
    Eeffs = EeffFactor * (qbs + eta_mu * qis);

    // Ref: BSIM4 Model mobility model
    T2 = pow(0.5 * (1.0 + (qis / qbs)), UCS_a);
    T3 = (UA_a + UC_a * Vbsx) * pow(Eeffs, EU_i) + UD_a / T2;
    T4 = 1.0 + T3;
    `Smooth(T4, 1.0, 0.0015, Dmobs)
    WeffWRFactor = 1.0 / (pow(Weff * 1.0e6, WR_i) * NF);

    if (RDSMOD == 1) begin
        Rdss = 0.0;
    end else begin
        T0   = 1.0 + PRWG_i * qis;
        T1   = PRWB_i * (sqrtPhistVbs - sqrtPhist);
        T2   = 1.0 / T0 + T1;
        T3   = T2 + sqrt(T2 * T2 + 0.01);
        Rdss = (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF * rdstemp;
        if (RDSMOD == 2) begin
            Rdss = (RSourceGeo + (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF + RDrainGeo) * rdstemp;
        end
    end
    T0 = pow(Dmobs, 1.0 / PSAT_a);
    if (PSATB_i < 0.0) begin
        T1 = 1.0 / (1.0 + PSATB_i * Vbsx);
    end else begin
        T1 = 1.0 - PSATB_i * Vbsx;
    end
    T2 = 10.0 * PSATX * qs * T1 / (10.0 * PSATX + qs * T1);
    if (PTWG_a < 0.0) begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 / (1.0 - PTWG_a * T2));
    end else begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 + PTWG_a * T2);
    end

    // qdsat for external Rds
    if (Rdss == 0) begin
        // Accurate qdsat derived from consistent I-V
        T0 = 0.5 * LambdaC * (qs * qs + qs) / (1.0 + 0.5 * LambdaC * (1.0 + qs));
        T1 = 2.0 * LambdaC * (qs - T0);
        T2 = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0.0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = -2.0 * LambdaC * (T1/T2) * (T1/T2) *(T1/T2);
        end
        T6 = T0 * T5 + T3 + LambdaC * (2.0 * T0 + 1.0);
        T0 = T0 - (T4 / T6);
        T1 = 2.0 * LambdaC * (qs - T0);
        T2 = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0.0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = (T1 / T2) * (T1 / T2) * (T1 / T2);
        end
        T6    = T0 * T5 + T3 + LambdaC * (2.0 * T0 + 1.0);
        qdsat = T0 - (T4/T6);
    // qdsat for internal Rds, Ref: BSIM4 Model
    end else begin
        // Accurate qdsat derived from consistent I-V
        T11 = Weff * 2.0 * nq * Cox * nVt * VSAT_a;
        T12 = T11 * LambdaC * Rdss / (2.0 * nVt);
        T0  = 0.5 * LambdaC * (qs * qs + qs) / (1.0 + 0.5 * LambdaC * (1.0 + qs));
        T1  = 2.0 * LambdaC * (qs - T0);
        T2  = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0.0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = -2.0 * LambdaC * (T1 / T2) * (T1 / T2) * (T1 / T2);
        end
        T6 = T0 * T5 + T3 + T12 * (qs + 2.0 * T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
        T0 = T0 - T4 / T6;
        T1 = 2.0 * LambdaC * (qs - T0);
        T2 = sqrt(1.0 + T1 * T1);
        ln_T1_T2 = asinh(T1);
        if (T1 != 0) begin
            T3 = T2 + (1.0 / T1) * ln_T1_T2;
        end else begin
            T3 = T2 + (1.0 / T2);
        end
        T4 = T0 * T3 + T12 * T0 * (qs + T0 + 1.0) - LambdaC * ((qs * qs + qs) - (T0 * T0 + T0));
        if (T1 != 0.0) begin
            T5 = -2.0 * LambdaC * (T1 * T2 - ln_T1_T2) / (T1 * T1);
        end else begin
            T5 = -2.0 * LambdaC * (T1 / T2) * (T1 / T2) * (T1 / T2);
        end
        T6    = T0 * T5 + T3 + T12 * (qs + 2.0 * T0 + 1.0) + LambdaC * (2.0 * T0 + 1.0);
        qdsat = T0 - T4 / T6;
    end
    vdsat = psip - 2.0 * phib_n - (2.0 * qdsat + lln((qdsat * 2.0 * nq * inv_gam) * ((qdsat * 2.0 * nq * inv_gam) + (gam / (nq - 1.0)))));
    Vdsat = vdsat * nVt;

    // normalized charge qdeff at drain end of channel
    // Vdssat clamped to avoid negative values during transient simulation
    `Smooth(Vdsat - Vs, 0.0, 1.0e-3, Vdssat)
    T7      = pow(Vds / Vdssat , 1.0 / DELTA_t);
    T8      = pow(1.0 + T7, -DELTA_t);
    Vdseff  = Vds * T8;
    vdeff   = (Vdseff + Vs) * inv_nVt;
    `BSIM_q(psip, phib_n, vdeff, gam, qdeff)

    // Reevaluation of nq to include qdeff
    psiavg = psip - qs - qdeff -1.0;
    `Smooth(psiavg, 1.0, 2.0, T0)
    T2 = sqrt(T0);
    nq = 1.0 + gam / (sqrtpsip + T2);

    // Inversion and bulk charge
    DQSD2 = (qs - qdeff) * (qs - qdeff);
    T0    = 1.0 / (1.0 + qs + qdeff);
    T1    = DQSD2 * T0;
    Qb    = vgfb - psip - (nq - 1.0) * (qs + qdeff + `Oneby3 * T1);
    T2    = `Oneby3 * nq;
    T3    = T1 * T0;
    Qs    = T2 * (2.0 * qs + qdeff + 0.5 * (1.0 + 0.8 * qs + 1.2 * qdeff) * T3);
    Qd    = T2 * (qs + 2.0 * qdeff + 0.5 * (1.0 + 1.2 * qs + 0.8 * qdeff) * T3);

    // Mobility degradation, Ref: BSIM4
    // Average charges (qba and qia) - normalized to Cox
    `Smooth(nVt * Qb, 0, 0.1, qba)
    qia   = nVt * (Qs + Qd);

    Eeffm = EeffFactor * (qba + eta_mu * qia);
    T2    = pow(0.5 * (1.0 + (qia / qba)), UCS_a);
    T3    = (UA_a + UC_a * Vbsx) * pow(Eeffm, EU_i) + UD_a / T2;
    T4    = 1.0 + T3;
    `Smooth(T4, 1.0, 0.0015, Dmob)

    // Output conductance
    Esat  = 2.0 * VSAT_a / (U0_a / Dmob);
    EsatL = Esat * Leff;
    if (PVAG_i > 0.0) begin
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
    end else begin
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end

    // Output conductance due to DIBL, Ref: BSIM4
    DIBLfactor = PDIBLC_a;
    diffVds    = Vds - Vdseff;
    Vgst2Vtm   = qia + 2.0 * nVt;
    if (DIBLfactor > 0.0) begin
        T3     = Vgst2Vtm / (Vdssat + Vgst2Vtm);
        T4     = hypsmooth((1.0 + PDIBLCB_i * Vbsx), 1.0e-3);
        T5     = 1.0 / T4;
        VaDIBL = Vgst2Vtm / DIBLfactor * T3 * PVAGfactor * T5;
        Moc    = 1.0 + diffVds / VaDIBL;
    end else begin
        Moc = 1.0;
    end

    // Degradation factor due to pocket implant, Ref: BSIM4 Model
    if (FPROUT_i <= 0.0) begin
        Fp = 1.0;
    end else begin
        T9 = FPROUT_i * sqrt(Leff) / Vgst2Vtm;
        Fp = 1.0 / (1.0 + T9);
    end

    // Channel length modulation, Ref: BSIM4 Model
    Vasat = Vdssat + EsatL;
    if(PCLM_a != 0.0) begin
        if (PCLMG < 0.0) begin
            T1 = PCLM_a / (1.0 - PCLMG * qia / EsatL) / Fp;
        end else begin
            T1 = PCLM_a * (1.0 + PCLMG * qia / EsatL) / Fp;
        end
        MdL = 1.0 + T1 * lln(1.0 + diffVds / T1 / Vasat);
    end else begin
        MdL = 1.0;
    end
    Moc = Moc * MdL;

    // Calculate Va_DITS, Ref: BSIM4
    T1 = lexp(PDITSD_i * Vds);
    if (PDITS_i > 0.0) begin
        T2      = 1.0 + PDITSL * Leff;
        VaDITS  = (1.0 + T2 * T1) / PDITS_i;
        VaDITS  = VaDITS * Fp;
    end else begin
        VaDITS  = `MAX_EXPL;
    end
    T4  = diffVds / VaDITS;
    T0  = 1.0 + T4;
    Moc = Moc * T0;

    // Calculate Vascbe, Ref: BSIM4 Model
    if (PSCBE2_i > 0.0) begin
        if (diffVds > PSCBE1_i * litl / `EXPL_THRESHOLD) begin
            T0     = PSCBE1_i * litl / diffVds;
            VaSCBE = Leff * lexp(T0) / PSCBE2_i;
        end else begin
            VaSCBE = `MAX_EXPL * Leff/PSCBE2_i;
        end
    end else begin
        VaSCBE = `MAX_EXPL;
    end
    Mscbe = 1.0 + (diffVds / VaSCBE);
    Moc   = Moc * Mscbe;

    // Velocity saturation
    T0 = pow(Dmob, 1.0 / PSAT_a);
    if (PSATB_i < 0.0) begin
        T1 = 1.0 / (1.0 + PSATB_i * Vbsx);
    end else begin
        T1 = 1.0 - PSATB_i * Vbsx;
    end
    T2 = 10.0 * PSATX * qia * T1 / (10.0 * PSATX + qia * T1);
    if (PTWG_a < 0.0) begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 / (1.0 - PTWG_a * T2));
    end else begin
        LambdaC = 2.0 * ((U0_a / T0) * nVt / (VSAT_a * Leff)) * (1.0 + PTWG_a * T2);
    end
    T1 = 2.0 * LambdaC * (qs - qdeff);
    T2 = sqrt(1.0 + T1 * T1);
    if (T1 != 0.0) begin
        Dvsat = 0.5 * (T2 + (1.0 / T1) * asinh(T1));
    end else begin
        Dvsat = 0.5 * (T2 + (1.0 / T2));
    end
    Dptwg = Dvsat;

    // S/D Series Resistance, Ref: BSIM4
    Rsource = 0.0;
    Rdrain  = 0.0;
    if (RDSMOD == 1) begin
        Rdsi = 0.0;
        Dr   = 1.0;
        // Rs (Source side resistance for all fingers)
        T2      = Vgs_noswap - Vfbsdr;
        T3      = sqrt(T2 * T2 + 0.01);
        Vgs_eff = 0.5 * (T2 + T3);
        T5      = 1.0 + PRWG_i * Vgs_eff;
        T6      = (1.0 / T5) + PRWB_i * Vsb_noswap;
        T4      = 0.5 * (T6 + sqrt(T6 * T6 + 0.01));
        Rsource = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T4) * WeffWRFactor);
        // Rd (Drain side resistance for all fingers)
        T2      = Vgd_noswap - Vfbsdr;
        T3      = sqrt(T2 * T2 + 0.01);
        Vgd_eff = 0.5 * (T2 + T3);
        T5      = 1.0 + PRWG_i * Vgd_eff;
        T6      = (1.0 / T5) + PRWB_i * Vdb_noswap;
        T4      = 0.5 * (T6 + sqrt(T6 * T6 + 0.01));
        Rdrain  = rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T4) * WeffWRFactor);
    end else begin
        // Ref: (1) BSIM4 Model (2) "Operation and Modeling of the MOS Transistor" by Yannis Tsividis
        T0      = 1.0 + PRWG_i * qia;
        T1      = PRWB_i * (sqrtPhistVbs - sqrtPhist);
        T2      = 1.0 / T0 + T1;
        T3      = 0.5 * (T2 + sqrt(T2 * T2 + 0.01));
        Rdsi    = rdstemp * (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF;
        Rdrain  = RDrainGeo;
        Rsource = RSourceGeo;
        Dr      = 1.0 + U0_a /(Dvsat * Dmob) * Cox * Weff / Leff * qia * Rdsi;
        if (RDSMOD == 2) begin
            Rdsi    = rdstemp * (RSourceGeo + (RDSWMIN_i + RDSW_i * T3) * WeffWRFactor * NF + RDrainGeo);
            Rdrain  = 0.0;
            Rsource = 0.0;
            Dr      = 1.0 + U0_a /(Dvsat * Dmob) * Cox * Weff / Leff * qia * Rdsi;
        end
    end

    // Non-saturation effect
    T0   = A1_t + A2_t / (qia + 2.0 * n * Vtm);
    DQSD = qs - qdeff;
    T1   = T0 * DQSD * DQSD;
    T2   = T1 + 1.0 - 0.001;
    T3   = -1.0 + 0.5 * (T2 + sqrt(T2 * T2 + 0.004));
    Nsat = 0.5 * (1.0 + sqrt(1.0 + T3));

    // MNUD model to enhance Id-Vd fitting flexibility
    T0   = (qs + qdeff);
    T1   = (qs - qdeff);
    T2   = T1 / (T0 + M0_t);
    T3   = K0_t * T2 * T2;
    Mnud = 1.0 + T3;
    Dtot = Dmob * Dvsat * Dr;

    // Effective mobility including mobility degradation
    ueff = U0_a / Dtot;

    // I-V
    ids  = 2.0 * NF * nq * ueff * Weff / Leff * Cox * nVt * nVt * ((qs - qdeff) * (1.0 + qs + qdeff)) * Moc / Nsat * Mnud;
    ids  = ids * IDS0MULT;
    Gcrg = 0.0;
    if (RGATEMOD > 1) begin
        idsovvds = ueff * Weff / Leff * Cox * qia;
        T9       = XRCRG2 * Vt;
        T0       = T9 * ueff * Weff / Leff * Cox;
        Gcrg     = XRCRG1 * NF * (T0 + idsovvds);
        if (RGATEMOD == 2) begin
            T11  = Grgeltd + Gcrg;
            Gcrg = Grgeltd * Gcrg / T11;
        end
    end

    // Impact ionization current, Ref: BSIM4
    if ((ALPHA0_i <= 0.0) || (BETA0_t <= 0.0)) begin
        Iii = 0.0;
    end else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
        T1  = -BETA0_t / diffVds;
        Iii = ALPHA0_i * diffVds * ids * lexp(T1) / Mscbe;
    end else begin
        Iii = ALPHA0_i * diffVds * ids * `MIN_EXPL / Mscbe;
    end
    ISUB = Iii * devsign;

    // Gate Current, Ref: BSIM4 Model
    igbinv = 0.0;
    igbacc = 0.0;
    igb    = 0.0;
    igcs   = 0.0;
    igcd   = 0.0;
    igs    = 0.0;
    igd    = 0.0;
    if ((IGCMOD != 0) || (IGBMOD != 0)) begin
        Voxm    = nVt * (vgfb - psip + qs + qdeff);
        T1      = sqrt(Voxm * Voxm + 1.0e-4);
        Voxmacc = 0.5 * (-Voxm + T1);
        Voxminv = 0.5 * (Voxm + T1);
    // Igbinv
    if (IGBMOD != 0) begin
        T1     = Voxmacc / NIGBACC_i / Vt;
        Vaux_Igbacc = NIGBACC_i * Vt * lln(1.0 + lexp(-T1));
        T2     = AIGBACC_i - BIGBACC_i * Voxmacc;
        T3     = 1.0 + CIGBACC_i * Voxmacc;
        T4     = -7.45669e11 * TOXE * T2 * T3;
        T5     = lexp(T4);
        T6     = 4.97232e-7;
        igbacc = NF * Weff * Leff * T6 * ToxRatio * Vg * Vaux_Igbacc * T5;
        igbacc = igbacc * igtemp;
        T1     = (Voxminv - EIGBINV_i) / NIGBINV_i / Vt;
        Vaux_Igbinv = NIGBINV_i * Vt * lln(1.0 + lexp(T1));
        T2     = AIGBINV_i - BIGBINV_i * Voxminv;
        T3     = 1.0 + CIGBINV_i * Voxminv;
        T4     = -9.82222e11 * TOXE * T2 * T3;
        T5     = lexp (T4);
        T6     = 3.75956e-7;
        igbinv = NF * Weff * Leff * T6 * ToxRatio * Vg * Vaux_Igbinv * T5;
        igbinv = igbinv * igtemp;
        igb    = igbacc + igbinv;
    end

    if (IGCMOD != 0) begin
        // Igcinv
        T1   = AIGC_i - BIGC_i * Voxminv;
        T2   = 1.0 + CIGC_i * Voxminv;
        T3   = Bechvb * T1 * T2;
        T4   = nq * nVt * (qs + qdeff) * lexp(T3);
        igc0 = NF * Aechvb * T4 * (Vg + 0.5 * Vdsx - 0.5 * (Vs + Vd)) * igtemp;
        // Gate-current partitioning
        Vdseffx = sqrt(Vdseff * Vdseff + 0.01) - 0.1;
        T1      = PIGCD_i * Vdseffx;
        T1_exp  = lexp(-T1);
        T3      = T1 + T1_exp -1.0 + 1.0e-4;
        T4      = 1.0 - (T1 + 1.0) * T1_exp + 1.0e-4;
        T5      = T1 * T1 + 2.0e-4;
        if (sigvds > 0) begin
            igcd = igc0 * T4 / T5;
            igcs = igc0 * T3 / T5;
        end else begin
            igcs = igc0 * T4 / T5;
            igcd = igc0 * T3 / T5;
        end
        // Igs
        T2      = Vgs_noswap - Vfbsdr;
        Vgs_eff = sqrt(T2 * T2 + 1.0e-4);
        if (IGCLAMP == 1) begin
            T1 = hypsmooth((AIGS_i - BIGS_i * Vgs_eff), 1.0e-6);
            if (CIGS_i < 0.01) begin
                CIGS_i = 0.01;
            end
        end else begin
            T1 = AIGS_i - BIGS_i * Vgs_eff;
        end
        T2       = 1.0 + CIGS_i * Vgs_eff;
        T3       = BechvbEdge * T1 * T2;
        T4       = lexp(T3);
        igs_mult = igtemp * NF * AechvbEdge * DLCIG_i;
        igs      = igs_mult * Vgs_noswap * Vgs_eff * T4;
        // Igd
        T2      = Vgd_noswap - Vfbsdr;
        Vgd_eff = sqrt(T2 * T2 + 1.0e-4);
        if (IGCLAMP == 1) begin
            T1 = hypsmooth((AIGD_i - BIGD_i * Vgd_eff), 1.0e-6);
            if (CIGD_i < 0.01) begin
                CIGD_i = 0.01;
            end
        end else begin
            T1 = AIGD_i - BIGD_i * Vgd_eff;
        end
        T2       = 1.0 + CIGD_i * Vgd_eff;
        T3       = BechvbEdge * T1 * T2;
        T4       = lexp(T3);
        igd_mult = igtemp * NF * AechvbEdge * DLCIGD_i;
        igd      = igd_mult * Vgd_noswap * Vgd_eff * T4;
    end
    end
    IGS  = devsign * igs;
    IGD  = devsign * igd;
    IGB  = devsign * igb;
    IGCS = devsign * igcs;
    IGCD = devsign * igcd;

    // GIDL and GISL Currents , Ref: BSIM4 Model
    igisl = 0.0;
    igidl = 0.0;
    if (GIDLMOD != 0) begin
        T0 = epsratio * TOXE;
        // GIDL
        if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0) || (CGIDL_i < 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-Vgd_noswap - EGIDL_i + Vfbsdr) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGIDL_t / (T1 + 1.0e-3);
            if (CGIDL_i != 0.0) begin
                T3 = Vdb_noswap * Vdb_noswap * Vdb_noswap;
                T4 = CGIDL_i + abs(T3) + 1.0e-4;
                T5 = hypsmooth(T3 / T4, 1.0e-6) - 1.0e-6;
            end else begin
                T5 = 1.0;
            end
            T6 = AGIDL_i * Weff * T1 * lexp(-T2) * T5;
        end
        igidl = T6;
        // GISL
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0) || (CGISL_i < 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-Vgs_noswap - EGISL_i + Vfbsdr) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGISL_t / (T1 + 1.0e-3);
            if (CGISL_i != 0.0) begin
                T3 = Vsb_noswap * Vsb_noswap * Vsb_noswap;
                T4 = CGISL_i + abs(T3) + 1.0e-4;
                T5 = hypsmooth(T3 / T4, 1.0e-6) - 1.0e-6;
            end else begin
                T5 = 1.0;
            end
            T6 = AGISL_i * Weff * T1 * lexp(-T2) * T5;
        end
        igisl = T6;
    end
    IGIDL = devsign * NF * igidl;
    IGISL = devsign * NF * igisl;

    // Junction current and capacitances
    // Source-side junction current
    if (Isbs > 0.0) begin
        if (Vbs_jct < VjsmRev) begin
            T0  = Vbs_jct / Nvtms;
            T1  = lexp(T0) - 1.0;
            T2  = IVjsmRev + SslpRev * (Vbs_jct - VjsmRev);
            Ibs = T1 * T2;
        end else if (Vbs_jct <= VjsmFwd) begin
            T0  = Vbs_jct / Nvtms;
            T1  = (BVS + Vbs_jct) / Nvtms;
            T2  = lexp(-T1);
            Ibs = Isbs * (lexp(T0) + XExpBVS - 1.0 - XJBVS * T2);
        end else begin
            Ibs = IVjsmFwd + SslpFwd * (Vbs_jct - VjsmFwd);
        end
    end else begin
        Ibs = 0.0;
    end

    //Source-side junction tunneling current
    if (JTSS_t > 0.0) begin
        if ((VTSS - Vbs_jct) < (VTSS * 1.0e-3)) begin
            T0  = -Vbs_jct / Vtm0 / NJTS_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibs = Ibs - ASeff * JTSS_t * T1;
        end else begin
            T0  = -Vbs_jct / Vtm0 / NJTS_t;
            T1  = lexp(T0 * VTSS / (VTSS - Vbs_jct)) - 1.0;
            Ibs = Ibs - ASeff * JTSS_t * T1;
        end
    end
    if (JTSSWS_t > 0.0) begin
        if ((VTSSWS - Vbs_jct) < (VTSSWS * 1.0e-3)) begin
            T0  = -Vbs_jct / Vtm0 / NJTSSW_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibs = Ibs - PSeff * JTSSWS_t * T1;
        end else begin
            T0  = -Vbs_jct / Vtm0 / NJTSSW_t;
            T1  = lexp(T0 * VTSSWS / (VTSSWS - Vbs_jct)) - 1.0;
            Ibs = Ibs - PSeff * JTSSWS_t * T1;
        end
    end
    if (JTSSWGS_t > 0.0) begin
        if((VTSSWGS - Vbs_jct) < (VTSSWGS * 1.0e-3)) begin
            T0  = -Vbs_jct / Vtm0 / NJTSSWG_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
        end else begin
            T0  = -Vbs_jct / Vtm0 / NJTSSWG_t;
            T1  = lexp(T0 * VTSSWGS / (VTSSWGS - Vbs_jct)) - 1.0;
            Ibs = Ibs - Weffcj * NF * JTSSWGS_t * T1;
        end
    end

    // Drain-side Junction Current
    if (Isbd > 0.0) begin
        if (Vbd_jct < VjdmRev) begin
            T0  = Vbd_jct / Nvtmd;
            T1  = lexp(T0) - 1.0;
            T2  = IVjdmRev + DslpRev * (Vbd_jct - VjdmRev);
            Ibd = T1 * T2;
        end else if (Vbd_jct <= VjdmFwd) begin
            T0  = Vbd_jct / Nvtmd;
            T1  = (BVD + Vbd_jct) / Nvtmd;
            T2  = lexp(-T1);
            Ibd = Isbd * (lexp(T0) + XExpBVD - 1.0 - XJBVD * T2);
        end else begin
            Ibd = IVjdmFwd + DslpFwd * (Vbd_jct - VjdmFwd);
        end
    end else begin
        Ibd = 0.0;
    end

    // Drain-side junction tunneling current
    if (JTSD_t > 0.0) begin
        if ((VTSD - Vbd_jct) < (VTSD * 1.0e-3)) begin
            T0  = -Vbd_jct / Vtm0 / NJTSD_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibd = Ibd - ADeff * JTSD_t * T1;
        end else begin
            T0  = -Vbd_jct / Vtm0 / NJTSD_t;
            T1  = lexp(T0 * VTSD/ (VTSD - Vbd_jct)) - 1.0;
            Ibd = Ibd - ADeff * JTSD_t * T1;
        end
    end
    if (JTSSWD_t > 0.0) begin
        if ((VTSSWD - Vbd_jct) < (VTSSWD * 1.0e-3)) begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWD_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibd = Ibd - PDeff * JTSSWD_t * T1;
        end else begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWD_t;
            T1  = lexp(T0 * VTSSWD / (VTSSWD - Vbd_jct)) - 1.0;
            Ibd = Ibd - PDeff * JTSSWD_t * T1;
        end
    end
    if (JTSSWGD_t > 0.0) begin
        if ((VTSSWGD - Vbd_jct) < (VTSSWGD * 1.0e-3)) begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWGD_t;
            T1  = lexp(T0 * 1.0e3) - 1.0;
            Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
        end else begin
            T0  = -Vbd_jct / Vtm0 / NJTSSWGD_t;
            T1  = lexp(T0 * VTSSWGD / (VTSSWGD - Vbd_jct)) - 1.0;
            Ibd = Ibd - Weffcj * NF * JTSSWGD_t * T1;
        end
    end

    // Junction capacitance (no swapping)
    // Source Bulk Junction
    Czbs       = CJS_t * ASeff;
    Czbssw     = CJSWS_t * PSeff;
    Czbsswg    = CJSWGS_t * Weffcj * NF;
    czbs_p1    = pow(0.1, -MJS);
    czbs_p2    = 1.0 / (1.0 - MJS) * (1.0 - 0.05 * MJS * (1.0 + MJS) * czbs_p1);
    czbssw_p1  = pow(0.1, -MJSWS);
    czbssw_p2  = 1.0 / (1.0 - MJSWS) * (1.0 - 0.05 * MJSWS * (1.0 + MJSWS) * czbssw_p1);
    czbsswg_p1 = pow(0.1, -MJSWGS);
    czbsswg_p2 = 1.0 / (1.0 - MJSWGS) * (1.0 - 0.05 * MJSWGS * (1.0 + MJSWGS) * czbsswg_p1);
    `JunCap(Czbs, Vbs_jct, PBS_t, MJS, czbs_p1, czbs_p2, Qbsj1)
    `JunCap(Czbssw, Vbs_jct, PBSWS_t, MJSWS, czbssw_p1, czbssw_p2, Qbsj2)
    `JunCap(Czbsswg, Vbs_jct, PBSWGS_t, MJSWGS, czbsswg_p1, czbsswg_p2, Qbsj3)
    Qbsj = Qbsj1 + Qbsj2 + Qbsj3;

    // Drain Bulk Junction
    Czbd       = CJD_t * ADeff;
    Czbdsw     = CJSWD_t * PDeff;
    Czbdswg    = CJSWGD_t * Weffcj * NF;
    czbd_p1    = pow(0.1, -MJD);
    czbd_p2    = 1.0 / (1.0 - MJD) * (1.0 - 0.05 * MJD * (1.0 + MJD) * czbd_p1);
    czbdsw_p1  = pow(0.1, -MJSWD);
    czbdsw_p2  = 1.0 / (1.0 - MJSWD) * (1.0 - 0.05 * MJSWD * (1.0 + MJSWD) * czbdsw_p1);
    czbdswg_p1 = pow(0.1, -MJSWGD);
    czbdswg_p2 = 1.0 / (1.0 - MJSWGD) * (1.0 - 0.05 * MJSWGD * (1.0 + MJSWGD) * czbdswg_p1);
    `JunCap(Czbd, Vbd_jct, PBD_t, MJD, czbd_p1, czbd_p2, Qbdj1)
    `JunCap(Czbdsw, Vbd_jct, PBSWD_t, MJSWD, czbdsw_p1, czbdsw_p2, Qbdj2)
    `JunCap(Czbdswg, Vbd_jct, PBSWGD_t, MJSWGD, czbdswg_p1, czbdswg_p2, Qbdj3)
    Qbdj = Qbdj1 + Qbdj2 + Qbdj3;

    // Sub-Surface Leakage Drain Current
    if (SSLMOD != 0) begin
        T1 = pow(NDEP_i / 1.0e23, SSLEXP1);
        T2 = pow(300.0 / DevTemp, SSLEXP2);
        SSL0_NT  = SSL0 * lexp(-T1 * T2);
        SSL1_NT  = SSL1 * T2 * T1;
        PHIB_SSL = SSL3 * tanh(lexp(devsign * SSL4 * (V(g, b) - VTH)));
        Issl     = sigvds * NF * Weff * SSL0_NT * lexp(-SSL1_NT * Leff) * lexp(PHIB_SSL / Vt) * (lexp(SSL2 * Vdsx / Vt) - 1.0);
        I(di, si) <+ Issl;
    end

    // Harshit's New Flicker Noise Model, Ref : H. Agarwal et. al., IEEE JEDS,Vol. 3, Issue 4, April 2015.
    Nt = 4.0 * Vt * `q;
    Esatnoi = 2.0 * VSAT_a / ueff;
    if (EM <= 0.0) begin
       DelClm = 0.0;
    end else begin
        T0     = (diffVds / litl + EM) / Esatnoi;
        DelClm = litl * lln(T0);
        if (DelClm < 0.0) begin
           DelClm = 0.0;
        end
    end
    Nstar = Vt / `q * (Cox + Cdep + CIT_i);
    Nl    = 2.0 * nq * Cox * Vt * qdeff / `q;
    T0a   = `q * `q * `q * Vt * abs(ids) * ueff;
    T0b   = `q * Vt * ids * ids;
    T0c   = NOIA + NOIB * Nl + NOIC * Nl * Nl;
    T0d   = (Nl + Nstar) * (Nl + Nstar);
    T0e   = NOIA * `q * Vt;
    if (FNOIMOD == 1) begin
        if(LINTNOI >= (Leff - LH) / 2.0) begin
            $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
            LINTNOI_i = 0.0;
        end else begin
            LINTNOI_i = LINTNOI;
        end
        LeffnoiH = Leff;
        if (Leff < LH) begin
            LeffnoiH = LH;
        end
        vgfbh  = (Vg - VFB_i) / Vt;
        gam_h  = sqrt(2.0 * `q * epssi * HNDEP / Vt) / Cox;
        phib_h = ln(HNDEP / ni);

        // Pinch-Off potential for halo region
        `PO_psip(vgfbh, gam_h, 0, phib_h, psiph)

        // normalized inversion charge at source end of halo MOSFET
        `BSIM_q(psiph, phib_h, vs, gam_h, qsh)
        nq_h = 1.0 + gam_h / (2.0 * sqrt(psiph));

        // Setting mobility of Halo region equal to the mobility of the channel. In general, U0H<ueff
        U0_i_h  = ueff;
        beta_h  = U0_i_h * Cox * Weff;
        beta_ch = ueff * Cox * Weff;

        // Normalized drain current for halo transistor. Eq. (14) of the paper
        i1 = ids * LH / (2.0 * nq_h * beta_h * Vt * Vt);

        // Normalized drain current for channel transistor. Eq. (15) of the paper
        i2 = ids * (LeffnoiH - LH) / (2.0 * nq * beta_ch * nVt * nVt);
        T0 = (1.0 + 4.0 * (qsh * qsh + qsh - i1));
        if (T0 < 1.0) begin
            qdh = 0.0;
        end else begin
            // drain charge of halo transistor. Eq. (16) of the paper
            qdh = -0.5 + 0.5 * sqrt(T0);
        end

        // source charge of channel transistor. Eq. (17) of the paper
        qsch   = -0.5 + 0.5 * sqrt(1.0 + 4.0 * (qdeff * qdeff + qdeff + i2));
        gds_h  = 2.0 * nq_h * beta_h * Vt * qdh;
        gds_ch = 2.0 * nq * beta_ch * Vt * qdeff;
        gm_ch  = 2.0 * beta_ch * Vt * (qsch - qdeff);
        R_ch   = gds_h * (LeffnoiH - LH);
        R_h    = gm_ch * LH + gds_ch * LH;
        t_tot  = 1.0 / (R_ch + R_h) / (R_ch + R_h);
        CF_ch  = R_ch * R_ch * t_tot;
        CF_h   = R_h * R_h * t_tot;

        // Local Noise Source
        if (Leff != LH) begin
            Np2       = 2.0 * nq * Cox * Vt * qsch / `q;
            Leffnoi   = LeffnoiH - 2.0 * LINTNOI_i-LH;
            Leffnoisq = Leffnoi * Leffnoi;
            // Channel Transistor LNS
            T1     = 1.0e10 * Cox * Leffnoisq;
            T2     = NOIA * lln((Np2 + Nstar) / (Nl + Nstar));
            T3     = NOIB * (Np2 - Nl);
            T4     = 0.5 * NOIC * (Np2 * Np2 - Nl * Nl);
            T5     = 1.0e10 * Leffnoisq * Weff * NF;
            Ssi_ch = T0a / T1 * (T2 + T3 + T4) + T0b / T5 * DelClm * T0c / T0d;
            T6     = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
            Swi_ch = T0e / T6 * ids * ids;
            T7 = Swi_ch + Ssi_ch;
            if (T7 > 0.0)  begin
                FNPowerAt1Hz_ch = (Ssi_ch * Swi_ch) / T7;
            end else begin
                FNPowerAt1Hz_ch = 0.0;
            end
        end else begin
            FNPowerAt1Hz_ch = 0.0;
        end

        // Halo transistor LNS
        T8    = NOIA2 * `q * Vt;
        T9    = Weff * NF * LH * 1.0e10 * Nstar * Nstar;
        Swi_h = T8 / T9 * ids * ids;
        T10   = Swi_h;
        if (T10 > 0.0) begin
            FNPowerAt1Hz_h = Swi_h;
        end else begin
            FNPowerAt1Hz_h = 0.0;
        end

        // Overall noise
        FNPowerAt1Hz = FNPowerAt1Hz_ch * CF_ch + FNPowerAt1Hz_h * CF_h;
        I(di, si) <+ flicker_noise(FNPowerAt1Hz, EF, "1overf");
    end else begin
            //Parameter checking
        if (LINTNOI >= Leff/2.0) begin
            $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
            LINTNOI_i = 0.0;
        end else begin
            LINTNOI_i = LINTNOI;
        end
        if (NOIA > 0 || NOIB > 0 || NOIC > 0) begin
            Leffnoi   = Leff - 2.0 * LINTNOI_i;
            Leffnoisq = Leffnoi * Leffnoi;
            T0        = 1.0e10 * Cox * Leffnoisq;
            N0        = 2.0 * nq * Cox * Vt * qs / `q;
            T1        = NOIA * lln((N0 + Nstar) / (Nl + Nstar));
            T2        = NOIB * (N0 - Nl);
            T3        = 0.5 * NOIC * (N0 * N0 - Nl * Nl);
            T4        = 1.0e10 * Leffnoisq * Weff * NF;
            Ssi       = T0a / T0 * (T1 + T2 + T3) + T0b / T4 * DelClm * T0c / T0d;
            T5        = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
            Swi       = T0e / T5 * ids * ids;
            T6        = Swi + Ssi;
            if (T6 > 0.0) begin
                FNPowerAt1Hz = (Ssi * Swi) / T6;
            end else begin
                FNPowerAt1Hz = 0.0;
            end
        end else begin
            FNPowerAt1Hz = 0.0;
        end
        I(di, si) <+ flicker_noise(FNPowerAt1Hz, EF, "1overf");
    end
    T0         = qia / Esatnoi / Leff;
    T1         = T0 * T0;
    T3         = RNOIA * (1.0 + TNOIA * Leff * T1);
    T4         = RNOIB * (1.0 + TNOIB * Leff * T1);
    T5         = RNOIK * (1.0 + TNOIK * Leff * T1);
    ctnoi      = RNOIC * (1.0 + TNOIC * Leff * T1);
    betanoisq  = 3.0 * T3 * T3;
    betanoisq  = (betanoisq - 1.0) * exp(-Leff / LP) + 1.0;
    betaLowId  = T5 * T5;
    thetanoisq = T4 * T4;
    cm_igid    = 0.0;
    case (TNOIMOD)
    0: begin
        QSi   = -NF * Weff * Leff * Cox * Vt * Qs;
        QDi   = -NF * Weff * Leff * Cox * Vt * Qd;
        T0    = ueff * abs(QSi + QDi);
        T1    = T0 * Rdsi + Leff * Leff;
        Gtnoi = (T0 / T1) * NTNOI;
        sidn  = Nt * Gtnoi;
        I(di, si) <+ white_noise(sidn, "id");
        V(N1)     <+ 0.0;
    end
    1: begin
        Vtn   = 2.0 * nq * nVt;
        T0    = ueff * Dptwg * Moc * Cox * Vtn;
        T1    = 0.5 * (qs + qdeff);
        T3    = T1 + 0.5;
        T4    = T3 * T3;
        T5    = T4 * T3;
        T6    = qs - qdeff;
        T7    = T6 * T6;
        T8    = T7 * T6;
        T9    = (6.0 * T1 + 0.5) * T7;
        Lvsat = Leff * Dptwg;
        T10   = Lvsat / Leff;
        T12   = 1.0 + (betaLowId * (Vdseff / Vdssat) / (TNOIK2 + qia));
        T12   = ((T12 - 1.0) * exp(-Leff / LP)) + 1.0;
        `Smooth(T12, 0, 1.0e-1, T12)
        mid   = T0 * NF * Weff / Lvsat * (T1 * T12 + T7 * betanoisq / (12.0 * T3));
        mig   = Lvsat * T10 * T10 * (T1 / T4 - T9 / (60.0 * T4 * T4) + T7 * T7 / (144.0 * T4 * T5)) * 15.0 / 4.0 * thetanoisq / (NF * Weff * 12.0 * T0);
        migid = T10 * (T6 / (12.0 * T3) - T8 / (144.0 * T5)) * ctnoi / 0.395;
        sqid  = sqrt(Nt * mid);
        if (mig == 0.0) begin
            sqig    = 0.0;
            cm_igid = 0.0;
        end else begin
            sqig =  sqrt(Nt / mig);
            if (sqid == 0.0) begin
                cm_igid = 0.0;
            end else begin
                cm_igid = migid * sqig / sqid;
            end
        end
        I(N2) <+ white_noise(cm_igid, "corl");
        I(NI) <+ white_noise(sqig * sqig * (1.0 - cm_igid), "corl");
        I(NI) <+ -sqig * V(N2);
        I(NC) <+ ddt(mig * Cox * Weff * NF * Leff * V(NC));
        I(di, si) <+ white_noise(sqid * sqid * (1.0 - cm_igid), "id");
        I(di, si) <+ sqid * V(N2);
        I(gi, si) <+ ddt(0.5 * ((1.0 + sigvds) * mig * Cox * Weff * NF * Leff * V(NC)));
        I(gi, di) <+ ddt(0.5 * ((1.0 - sigvds) * mig * Cox * Weff * NF * Leff * V(NC)));
    end
    endcase
    I(N2) <+ V(N2);
    I(NR) <+ V(NR);

    // Gate current shot noise
    if (IGCMOD != 0) begin
        I(gi, si) <+ white_noise(2.0 * `q * abs(igcs + igs), "igs");
        I(gi, di) <+ white_noise(2.0 * `q * abs(igcd + igd), "igd");
    end
    if (IGBMOD != 0) begin
        I(gi, bi) <+ white_noise(2.0 * `q * abs(igb), "igb");
    end

    // C-V model
    vgfbCV   = vgfb;
    gamg2    = (2.0 * `q * epssi * NGATE_i) / (Cox * Cox * Vt);
    invgamg2 = (NGATE_i > 0.0) ? (1.0 / gamg2) : 0.0;
    if (CVMOD == 1) begin
        VFBCV_i = VFBCV_i + DELVTO;
        vg      = Vg * inv_Vt;
        vs      = Vs * inv_Vt;
        vfb     = VFBCV_i * inv_Vt;
        vgfbCV  = vg - vfb;
        phib    = lln(NDEPCV_i / ni);
        // Normalized body factor
        gam      = sqrt(2.0 * `q * epssi * NDEPCV_i * inv_Vt) / Cox;
        inv_gam  = 1.0 / gam;
        gamg2    = (2.0 * `q * epssi * NGATE_i) / (Cox * Cox * Vt);
        invgamg2 = (NGATE_i > 0.0) ? (1.0 / gamg2) : 0.0;
        DPD      = (NGATE_i > 0.0) ? (NDEPCV_i / NGATE_i) : 0.0;

        // psip: pinch-off voltage
        `PO_psip(vgfbCV, gam, DPD, phib, psip)

        // normalized inversion charge at source end of channel
        `BSIM_q(psip, phib, vs, gam, qs)
        `Smooth(psip, 1.0, 2.0, psipclamp)
        sqrtpsip = sqrt(psipclamp);

        // source side surf pot.
        psiavg = psip - 2.0 * qs;
        `Smooth(psiavg, 1.0, 2.0, T0)
        nq = 1.0 + gam / (sqrtpsip + sqrt(T0));

        // Drain Saturation Voltage
        T0 = Vt * (vgfbCV - psip - 2.0 * qs * (nq - 1.0));
        `Smooth(T0, 0, 0.1, qbs)

       // Source side qi and qb for Vdsat- normalized to Cox
        qis = 2.0 * nq * Vt * qs;
        Eeffs = EeffFactor * (qbs + eta_mu * qis); // in the unit of MV/cm

        // Ref: BSIM4 Model mobility model
        T3 = (UA_a + UC_a * Vbsx) * pow(Eeffs, EU_i);
        T4 = 1.0 + T3;
        `Smooth(T4, 1.0, 0.0015, Dmobs)
        LambdaC_by2 = (U0_a / Dmobs) * Vt / (VSATCV_t * Lact);
        qdsat       = LambdaC_by2 * (qs * qs + qs) / (1.0 + LambdaC_by2 * (1.0 + qs));
        vdsatcv     = psip - 2.0 * phib - (2.0 * qdsat + lln((qdsat * 2.0 * nq * inv_gam) * ((qdsat * 2.0 * nq * inv_gam) + (gam / (nq - 1.0)))));
        VdsatCV     = vdsatcv * Vt;

        // Normalized charge qdeff at drain end of channel
        `Smooth(VdsatCV - Vs, 0.0, 1e-3, VdssatCV)
        T7     = pow(Vds / VdssatCV , 1.0 / DELTA_t);
        T8     = pow(1.0 + T7, -DELTA_t);
        Vdseff = Vds * T8;
        vdeff  = (Vdseff + Vs) * inv_Vt;
        `BSIM_q(psip, phib, vdeff, gam, qdeff)

        // Reevaluation of nq to include qdeff needed for gummel symmetry
        psiavg = psip - qs - qdeff - 1.0;
        `Smooth(psiavg, 1.0, 2.0, T0)
        T2 = sqrt(T0);
        T3 = 1.0 + DPD + gam / (sqrtpsip + T2);
        T4 = 0.5 + DPD * T2 * inv_gam;
        T5 = sqrt(T4 * T4 + T3 * (qs + qdeff) * invgamg2);
        nq = T3 / (T4 + T5);

        // CV Expressions including Velocity Saturation and CLM
        // Velocity Saturation for CV
        T0  = Vt * (vgfbCV - psip - 2.0 * qs * (nq - 1.0));
        `Smooth(T0, 0, 0.1, qbs)
        T1  = Vt * (vgfbCV - psip - 2.0 * qdeff * (nq - 1.0));
        `Smooth(T1, 0, 0.1, qbd)
        qb  = 0.5 * (qbs + qbd);
        qia = nq * Vt * (qs + qdeff);
        Eeffm = EeffFactor * (qb + eta_mu * qia);
        T3    = (UA_a + UC_a * Vbsx) * pow(Eeffm, EU_i);
        T4    = 1.0 + T3;
        `Smooth(T4, 1.0, 0.0015, Dmob)
        LambdaC = 2.0 * (U0_a / Dmob) * Vt / (VSATCV_t * Lact);
        dps     = qs - qdeff;
        T1      = 2.0 * (LambdaC * dps) * (LambdaC * dps);
        zsat    = sqrt(1.0 + T1);
        Dvsat   = 0.5 * (1.0 + zsat);
        // CLM for CV
        Esat    = 2.0 * VSATCV_t / (U0_a / Dmob);
        EsatL   = Esat * Lact;
        Vasat   = VdssatCV + EsatL;
        diffVds = Vds - Vdseff;
    end
    if (PCLMCV_i != 0.0) begin
        MdL = 1.0 + PCLMCV_i * lln(1.0 + diffVds / PCLMCV_i / Vasat);
    end else begin
        MdL = 1.0;
    end
    MdL_2       = MdL * MdL;
    inv_MdL     = 1.0 / MdL;
    inv_MdL_2   = 1.0 / MdL_2;
    MdL_less_1  = MdL - 1.0;
    vgpqm = vgfbCV - psip;
    DQSD  = (qs - qdeff);
    DQSD2 = (qs - qdeff) * (qs - qdeff);
    sis   = vgpqm + 2.0 * qs;
    sid   = vgpqm + 2.0 * qdeff;
    `Smooth(sis, 0.0, 0.5, T1)
    `Smooth(sid, 0.0, 0.5, T2)
    Temps = sqrt(0.25 + T1 * invgamg2);
    Tempd = sqrt(0.25 + T2 * invgamg2);
    T1 = sis / (1.0 + 2.0 * Temps);
    T2 = sid / (1.0 + 2.0 * Tempd);
    T3 = Temps + Tempd;
    T4 = `Oneby3 * (DQSD2 / (T3 * T3 * T3));
    T5 = (Dvsat * inv_MdL) / (1.0 + qs + qdeff);
    T6 = 0.8 * (T3 * T3 + Temps * Tempd) * T5;
    T7 = T6 + (2.0 * invgamg2);
    T8 = `Oneby3 * DQSD2 * T5;
    dqgeff = sid * (2.0 * Tempd - 1.0) / (2.0 * Tempd + 1.0);
    qbeff  = vgpqm - 2.0 * (nq - 1.0) * qdeff + dqgeff;
    Qb  = inv_MdL * (T1 + T2 + (T4 * T7 - nq * (qs + qdeff + T8))) + MdL_less_1 * qbeff;
    T9  = qs + qdeff;
    T10 = DQSD2 * T5 * T5;
    Qi  = nq * inv_MdL * (T9 + `Oneby3 * DQSD2 * T5) + 2.0 * nq * MdL_less_1 * qdeff;
    Qd1 = nq * inv_MdL_2 * (0.5 * T9 - (DQSD / 6.0) * (1.0 - DQSD * T5 - 0.2 * T10));
    Qd2 = nq * (MdL - inv_MdL) * qdeff;
    Qd  = Qd1 + Qd2;
    Qs  = Qi - Qd;

    // Quantum Mechanical Effect
    `Smooth(Vt*Qb, 0, 0.1, qbaCV)
    qiaCV      = Vt *( Qs + Qd);
    T0         = (qiaCV + ETAQM * qbaCV) / QM0;
    T1         = 1.0 + pow(T0, 0.7 * BDOS);
    XDCinv     = ADOS * 1.9e-9 / T1;
    Coxeffinv  = 3.9 * `EPS0 / (BSIMBULKTOXP * 3.9 / EPSROX + XDCinv / epsratio);
    QBi        = -NF * Wact * Lact * (`EPS0 * EPSROX / BSIMBULKTOXP) * Vt * Qb;
    WLCOXVtinv = NF * Wact * Lact * Coxeffinv * Vt;
    QSi        = -WLCOXVtinv * Qs;
    QDi        = -WLCOXVtinv * Qd;
    QGi        = -(QBi + QSi + QDi);

    // Outer fringing capacitance
    if (!$param_given(CF)) begin
        CF_i = 2.0 * EPSROX * `EPS0 / `M_PI * lln(CFRCOEFF * (1.0 + 0.4e-6 / TOXE));
    end
    Cgsof = CGSO + CF_i;
    Cgdof = CGDO + CF_i;

    // Overlap capacitance
    if (COVMOD == 0) begin
        Qovs = -Wact * NF * Cgsof * Vgs_ov_noswap;
        Qovd = -Wact * NF * Cgdof * Vgd_ov_noswap;
    end else begin
        T0    = sqrt((Vgs_ov_noswap - Vfbsdr + `DELTA_1) * (Vgs_ov_noswap -Vfbsdr + `DELTA_1) + 4.0 * `DELTA_1);
        Vgsov = 0.5 * (Vgs_ov_noswap - Vfbsdr + `DELTA_1 - T0);
        T1    = sqrt(1.0 - 4.0 * Vgsov / CKAPPAS_i);
        Qovs  = -Wact * NF * (Cgsof * Vgs_ov_noswap + CGSL_i * (Vgs_ov_noswap -Vfbsdr - Vgsov - 0.5 * CKAPPAS_i * (-1.0 + T1)));
        T0    = sqrt((Vgd_ov_noswap - Vfbsdr + `DELTA_1) * (Vgd_ov_noswap - Vfbsdr + `DELTA_1) + 4.0 * `DELTA_1);
        Vgdov = 0.5 * (Vgd_ov_noswap - Vfbsdr + `DELTA_1 - T0);
        T2    = sqrt(1.0 - 4.0 * Vgdov / CKAPPAD_i);
        Qovd  = -Wact * NF * (Cgdof * Vgd_ov_noswap + CGDL_i * (Vgd_ov_noswap - Vfbsdr - Vgdov - 0.5 * CKAPPAD_i * (-1.0 + T2)));
    end
    Qovb = -devsign * NF * Lact * CGBO * V(gm, bi);
    Qovg = -(Qovs + Qovd + Qovb);

    // Edge FET model
    if (EDGEFET == 1) begin
        NFACTOREDGE_t = NFACTOREDGE_i * hypsmooth((1.0 + TNFACTOREDGE_i * (TRatio - 1.0)), 1e-3);
        ETA0EDGE_t    = ETA0_EDGE * (1.0 + TETA0EDGE_i * (TRatio - 1.0));
        cdsc          = CITEDGE_i + NFACTOREDGE_t + CDSCDEDGE_i * Vdsx - CDSCBEDGE_i * Vbsx;
        T1            = 1.0 + cdsc/Cox;
        `Smooth(T1, 1.0, 0.05, n)
        nVt       = n * Vt;
        inv_nVt   = 1.0 / nVt;
        vg        = Vg * inv_nVt;
        vs        = Vs * inv_nVt;
        vfb       = VFB_i * inv_nVt;
        dvth_dibl = -(ETA0EDGE_t + ETABEDGE_i * Vbsx) * Vdsx;
        dvth_temp = (KT1EDGE_i + KT1LEDGE_i / Leff + KT2EDGE_i * Vbsx) * (pow(TRatio, KT1EXPEDGE_i) - 1.0);
        litl_edge = litl * (1.0 + DVT2EDGE * Vbsx);
        T0        = DVT1EDGE * Leff / litl_edge;
        if (T0 < 40.0) begin
            theta_sce_edge = 0.5 * DVT0EDGE / (cosh(T0) - 1.0);
        end else begin
            theta_sce_edge = DVT0EDGE * lexp(-T0);
        end
        dvth_sce  = theta_sce_edge * (Vbi - Phist);
        Vth_shift = dvth_dibl - dvth_temp + dvth_sce + DVTEDGE + vth0_stress_EDGE - K2_EDGE * Vbsx;
        vgfb      = vg - vfb - Vth_shift * inv_nVt;

        // Normalized body factor
        DGAMMAEDGE_i = DGAMMAEDGE * (1.0 + DGAMMAEDGEL * pow(Leff, -DGAMMAEDGELEXP));
        gam          = sqrt(2.0 * `q * epssi * NDEP_i * inv_nVt) / Cox;
        gam          = gam * (1.0 + DGAMMAEDGE_i);
        inv_gam      = 1.0 / gam;
        phib_n       = phib / n;
        `PO_psip(vgfb, gam, 0, phib_n, psip)
        `BSIM_q(psip, phib_n, vs, gam, qs)

        // Approximate Pinch Off voltage
        vdsatedge = 2.0 * nVt * qs + 2.0 * nVt;
        Vdsatedge = vdsatedge;
        Vdsatedge = Vdsatedge + Vs;

        // Vdssat clamped to avoid negative values during transient simulation
        `Smooth(Vdsatedge - Vs, 0.0, 1.0e-3, Vdssate)
        T7     = pow(Vds / Vdssate , 1.0 / DELTA_t);
        T8     = pow(1.0 + T7, -DELTA_t);
        Vdseff = Vds * T8;
        vdeff  = (Vdseff + Vs) * inv_nVt;
        `BSIM_q(psip, phib_n, vdeff, gam, qdeff)

        // Nq calculation for Edge FET
        `Smooth(psip, 1.0, 2.0, psipclamp)
        sqrtpsip = sqrt(psipclamp);
        psiavg = psip - qs - qdeff -1.0;
        `Smooth(psiavg, 1.0, 2.0, T0)
        T2       = sqrt(T0);
        nq       = 1.0 + gam / (sqrtpsip + T2);
        ids_edge = 2.0 * NF * nq * ueff * WEDGE / Leff * Cox * nVt * nVt *((qs - qdeff)*(1.0 + qs + qdeff)) *Moc;
        ids      = ids_edge + ids;
    end

    // Edge FET Parasitic Device Drain Current Model Ends
    // Charge expressions including fringing and overlap capacitance
    QB = devsign * (QBi + Qovb + Qbsj + Qbdj);
    if (sigvds > 0) begin
        QSI = devsign * QSi;
        QDI = devsign * QDi;
        QS  = devsign * (QSi + Qovs - Qbsj);
        QD  = devsign * (QDi + Qovd - Qbdj);
    end else begin
        QSI = devsign * QDi;
        QDI = devsign * QSi;
        QS  = devsign * (QDi + Qovs - Qbsj);
        QD  = devsign * (QSi + Qovd - Qbdj);
    end
    QG = devsign * (QGi + Qovg);

    // Output
    // Intrinsic Charges
    QBI = devsign * QBi;
    QGI = devsign * QGi;

    // QSI and QDI are defined above
    // Intrinsic Capacitances
    CGSI = -ddx(QGI,V(si));
    CGDI = -ddx(QGI,V(di));
    CGBI = -ddx(QGI,V(bi));
    CGGI = ddx(QGI,V(gi));
    CSSI = ddx(QSI,V(si));
    CSDI = -ddx(QSI,V(di));
    CSBI = -ddx(QSI,V(bi));
    CSGI = -ddx(QSI,V(gi));
    CDSI = -ddx(QDI,V(si));
    CDDI = ddx(QDI,V(di));
    CDBI = -ddx(QDI,V(bi));
    CDGI = -ddx(QDI,V(gi));
    CBSI = -ddx(QBI,V(si));
    CBDI = -ddx(QBI,V(di));
    CBBI = ddx(QBI,V(bi));
    CBGI = -ddx(QBI,V(gi));

    // Total Capacitances
    CGS = -ddx(QG, V(si));
    CGD = -ddx(QG, V(di));
    CGB = -ddx(QG, V(bi));
    CGG = CGGI + ddx(devsign * Qovg, V(gm));
    CSS = ddx(QS, V(si));
    CSD = -ddx(QS, V(di));
    CSB = CSBI - ddx((QS - QSI), V(sbulk));
    CSG = CSGI - ddx((QS - QSI), V(gm));
    CDS = -ddx(QD, V(si));
    CDD = ddx(QD, V(di));
    CDB = CDBI - ddx((QD - QDI), V(dbulk));
    CDG = CDGI - ddx((QD - QDI), V(gm));
    CBS = -ddx(QB, V(si));
    CBD = -ddx(QB, V(di));
    CBB = CBBI + ddx(QB, V(sbulk)) + ddx(QB, V(dbulk)) + ddx((devsign * Qovb), V(bi));
    CBG = -ddx(QB, V(gi)) - ddx((devsign * Qovb), V(gm));

    // Total extrinsic capacitance
    CGSEXT = -devsign * ddx(Qovg, V(si));  // Gate-Source Overlap + outer fringing
    CGDEXT = -devsign * ddx(Qovg, V(di));  // Gate-Drain Overlap + outer fringing
    CGBOV  = -devsign * ddx(Qovg, V(bi));  // Gate-Body Overlap

    // Total Source/Drain Junction Capacitances
    CAPBS  = -devsign * ddx(Qbsj, V(si));
    CAPBD  = -devsign * ddx(Qbdj, V(di));

    // W & L
    WEFF   = Weff;  // Effective width for IV
    LEFF   = Leff;  // Effective length for IV
    WEFFCV = Wact;  // Effective width for CV
    LEFFCV = Lact;  // Effective length for CV

    // Currents and derivatives
    if (sigvds > 0) begin
        IDS   = devsign * ids;                      // Intrinsic drain to source current
        IDEFF = IDS - (IGD + IGCD) + ISUB + IGIDL;  // Total drain current
        ISEFF = -IDS - (IGS + IGCS) + IGISL;        // Total source current
    end else begin
        IDS   = -devsign * ids;                      // Intrinsic drain to source current
        IDEFF = IDS - (IGD + IGCD) + IGIDL;          // Total drain current
        ISEFF = -IDS - (IGS + IGCS) + ISUB + IGISL;  // Total source current
    end
    IGEFF = IGB + IGS + IGCS + IGD + IGCD;//Total gate tunneling current
    IBS   = -devsign * Ibs;   // Source junction current
    IBD   = -devsign * Ibd;   // Source junction current
    VDS   = V(di, si);        // Drain-Source Voltage
    VGS   = V(gi, si);
    VBS   = -V(si, bi);       // Source-body Voltage
    VDSAT = Vdssat;           // Drain-Source saturation Voltage
    GM    = ddx(IDS, V(gi));  // Transconductance
    GMBS  = ddx(IDS, V(bi));  // Body transconductance
    GDS   = ddx(IDS, V(di));  // Output conductance

    // Loading variables
    I(gi, bi) <+ ddt(QGI);
    I(si, bi) <+ ddt(QSI);
    I(di, bi) <+ ddt(QDI);
    I(gm, si) <+ ddt(-devsign * Qovs);
    I(gm, di) <+ ddt(-devsign * Qovd);
    I(gm, bi) <+ ddt(-devsign * Qovb);

    // Drain to source current
    I(di, si) <+ devsign * sigvds * ids;

    if (IGBMOD != 0) begin
        I(gi, bi) <+ IGB;
    end
    if (IGCMOD != 0) begin
        I(gi, si) <+ (IGS + IGCS);
        I(gi, di) <+ (IGD + IGCD);
    end
    if (sigvds > 0) begin
        I(di, bi) <+ ISUB + IGIDL;
        I(si, bi) <+ IGISL;
    end else begin
        I(di, bi) <+ IGIDL;
        I(si, bi) <+ ISUB + IGISL;
    end

    // External S/D Resistance
    if (RDSMOD != 2) begin
        gdpr = 1.0 / Rdrain;   // Note: gdpr considers all fingers
        gspr = 1.0 / Rsource;  // Note: gspr considers all fingers
        I(d, di) <+ V(d, di) * gdpr;
        I(s, si) <+ V(s, si) * gspr;
        I(d, di) <+ white_noise(Nt * gdpr, "rd");
        I(s, si) <+ white_noise(Nt * gspr, "rs");
    end else begin
        V(d, di) <+ 0.0;
        V(s, si) <+ 0.0;
    end
    if (RGATEMOD == 0) begin
        V(g, gm) <+ 0.0;
    end else begin: rgate
        real Ggate, Gnoise;
        if (RGATEMOD == 2) begin
            Ggate = Gcrg;
            Gnoise = Gcrg * Gcrg / Grgeltd;
        end else begin
            Ggate = Grgeltd;
            Gnoise = Grgeltd;
        end
        I(g, gm) <+ V(g, gm) * Ggate;
        I(g, gm) <+ white_noise(Nt * Gnoise, "rg");
    end
    if (RGATEMOD == 3) begin
        I(gm, gi) <+ V(gm, gi) * Gcrg;
    end else begin
        V(gm, gi) <+ 0;
    end
    if ((SHMOD != 0) && (RTH0 > 0.0)) begin
        if (RDSMOD != 2) begin
            Pwr(t) <+ -(devsign * sigvds * ids * V(di, si) + V(d,di) * V(d,di) / Rdrain + V(s,si) * V(s,si) / Rsource) + ddt(delTemp1 * cth) + delTemp1 * gth;
        end else begin
            Pwr(t) <+ -(devsign * sigvds * ids * V(di, si))  + ddt(delTemp1 * cth) + delTemp1 * gth;
        end
    end else begin
        Temp(t) <+ 0.0;
    end
    if (RBODYMOD != 0) begin
        I(bi, sbulk) <+ V(bi, sbulk) * Grbps;
        I(b, sbulk)  <+ V(b, sbulk)  * Grbsb;
        I(b, bi)     <+ V(b, bi)     * Grbpb;
        I(b, dbulk)  <+ V(b, dbulk)  * Grbdb;
        I(bi, dbulk) <+ V(bi, dbulk) * Grbpd;
        I(sbulk, bi) <+ white_noise(Nt * Grbps, "rbps");
        I(sbulk, b)  <+ white_noise(Nt * Grbsb, "rbsb");
        I(b, bi)     <+ white_noise(Nt * Grbpb, "rbpb");
        I(dbulk, bi) <+ white_noise(Nt * Grbpd, "rbpd");
        I(dbulk, b)  <+ white_noise(Nt * Grbdb, "rbdb");
    end else begin
        V(b, sbulk)  <+ 0.0;
        V(b, bi)     <+ 0.0;
        V(b, dbulk)  <+ 0.0;
    end

    // Diode Current and Capacitance
    if (RBODYMOD != 0) begin
        I(sbulk, si) <+ devsign * Ibs;
        I(dbulk, di) <+ devsign * Ibd;
        I(sbulk, si) <+ devsign * ddt(Qbsj);
        I(dbulk, di) <+ devsign * ddt(Qbdj);
    end else begin
        I(bi, si) <+ devsign * Ibs;
        I(bi, di) <+ devsign * Ibd;
        I(bi, si) <+ devsign * ddt(Qbsj);
        I(bi, di) <+ devsign * ddt(Qbdj);
    end
end
endmodule
