/***********************************************************************

 HiSIM (Hiroshima University STARC IGFET Model)
 Copyright (C) 2000-2016 Hiroshima University and STARC
 Copyright (C) 2016-2019 Hiroshima University

 MODEL NAME : HiSIM2
 ( VERSION : 3  SUBVERSION : 1  REVISION : 1 )
 Model Parameter 'VERSION' : 3.11
 FILE : hisim2.va
 Module : hisim2_va   Terminal : d g s b

 Date : 2019.04.04

 released by Hiroshima University
 
***********************************************************************/
//
////////////////////////////////////////////////////////////////
//
//Licensed under the Educational Community License, Version 2.0 
//(the "License"); you may not use this file except in 
//compliance with the License. 
//
//You may obtain a copy of the License at: 
//
//      http://opensource.org/licenses/ECL-2.0
//
//Unless required by applicable law or agreed to in writing, 
//software distributed under the License is distributed on an 
//"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, 
//either express or implied. See the License for the specific 
//language governing permissions and limitations under the 
//License.
//
//
//The HiSIM_SOI standard has been supported by the members of 
//Silicon Integration Initiative's Compact Model Coalition. A 
//link to the most recent version of this standard can be found 
//at:
//
//http://www.si2.org/cmc
//
////////////////////////////////////////////////////////////////
//
//* Memorandum on programming
//* 
//*(1) Bias(x: b|d|g)
//*     . vxs : Input argument.
//*     . Vxse: External bias taking account device type(pMOS->nMOS).
//*     . Vxsc: Confined bias within a specified region. 
//*     . Vxs : Internal bias.
//*     . Y_dVxs denotes the partial derivative of Y w.r.t. Vxs.
//* 
//* (2) Device Mode
//*     . Normal mode(Vds>0 for nMOS) is assumed.
//*     . In case of reverse mode, parent routines have to properly 
//*       transform or interchange inputs and outputs except ones 
//*       related to junction diodes, which are regarded as being 
//*       fixed to the nodal S/D.
//*
//* (3) Modification for symmetry at Vds=0
//*     . Vxsz: Modified bias. (x: b|d|g)
//*     . Ps0z: Modified Ps0.
//*     . The following variables are calculated as a function of 
//*       modified biases or potential.
//*         Tox, Cox, (-- with quantum effect)
//*         Vth*, dVth*, dPpg, Igate, Igidl, Igisl. 
//*     . The following variables are calculated using a transform
//*       function.
//*         Lred
//*     
//*(4) Zones and Cases(terminology)
//* 
//*       Chi:=beta*(Ps0-Vbs)=       0    3    5
//*
//*                      Zone:    A  | D1 | D2 | D3
//*                                  |
//*                    (accumulation)|(depletion)
//*                                  |
//*                      Vgs =     Vgs_fb                Vth
//*                                              /       /
//*                      Case:    Nonconductive / Conductive
//*                                            /
//*             VgVt:=Qn0/Cox=             VgVt_small
//*
//*     . Ids is regarded as zero in zone-A.
//*     . Procedure to calculate Psl and dependent variables is 
//*       omitted in the nonconductive case. Ids and Qi are regarded
//*       as zero in this case.
//*
//*********************************************************************/
//

`include "discipline.h"

//
// Macros for the model/instance parameters
//
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//  BPRxx    both model and instance parameter real
//  BPIxx    both model and instance parameter integer
//     || 
//     cc    closed lower bound, closed upper bound bounds
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     nb    no bounds
//     sw    switch(integer only, values  0=false  and  1=true)
//     ty    switch(integer only, values -1=p-type and +1=n-type)
//
//  OPP   operating point parameter, includes units and description for printing
//
`define ALIAS(alias,paramName) aliasparam alias = paramName;
`define OPP(nam,uni,des)               (*units=uni,                             desc=des*)           real    nam;
`define MPRnb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def;
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr];
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr);
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr);
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr];
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr];
`define MPInb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def;
`define MPIsw(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:  1];
`define MPIty(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[ -1:  1] exclude 0;
`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def;
`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr];
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr);
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr);
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr];
`define IPInb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def;
`define IPIsw(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[  0:  1];
`define BPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def;
`define BPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr];
`define BPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr);
`define BPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr);
`define BPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr];
`define BPIcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[lwr:upr];
`define BPInb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def;
`define BPIsw(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[  0:  1];
`define BPIty(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def from[ -1:  1] exclude 0;

`define GMIN gminMod  = GMIN; 
`define MFACTOR_DEC mMod = $mfactor;
`define MFACTOR_USE 1.0

`define Kflic         1
`define Kwhite        1

// For Debugging print
//`define DEBUG 1
`ifdef DEBUG
`define DEBUG_PRINT(xName, x) $strobe("%s = %g", xName, 1.0*x) ;
`else
`define DEBUG_PRINT(xName, x)
`endif

`define NMOS         1                          // MOS type 
`define PMOS         -1                         // 
`define HiSIM_NORMAL_MODE 1                     // device working mode 
`define HiSIM_REVERSE_MODE -1                   // 
`define NULL         0                          // others 

//---------------------------------------------------* 
//* Numerical constants. (macro) 
//*-----------------*/
`ifdef  _FLOAT_H
`define C_EPS_M      (DBL_EPSILON)              // machine epsilon 
`else  
`define C_EPS_M      (2.2204460492503131e-16)   // 
`endif 
`define MAX_EXP      5.834617425e14             // 
`define MIN_EXP      1.713908431e-15            // 
`define EXP_THR      34.0                       // 
`define C_SQRT_2     (1.414213562373095e+00)    // sqrt(2) 
`define C_1o3        (3.333333333333333e-01)    // 1/3 
`define C_2o3        (6.666666666666667e-01)    // 2/3 
`define C_2p_1o3     (1.259921049894873e+00)    // 2^(1/3) 
`define C_Pi         (3.141592653589793)        // Pi 
`define C_Pio2       (1.570796326794897)        // 
`define C_m2cm       (1.0e2)                    // Unit change 
`define C_m2cm_p2    (1.0e4)                    // 
`define C_m2cm_p3    (1.0e6)                    // 
`define C_m2cm_p1o2  (1.0e1)                    // 
`define C_m2um       (1.0e6)                    // 
`define C_cm2m_p3    (1.0e-6)                   // 
`define C_vmax       (1.0e5)                    // 
`define C_E0_p2      (1.0e9)                    // 
`define C_cm2m       1.0e-2

//---------------------------------------------------* 
//* Physical constants/properties. (macro) 
//*-----------------*/
`define C_QE         (1.6021918e-19)            // Elemental charge 
`define C_KB         (1.3806226e-23)            // Boltzmann constant 
`define C_ESI        (1.034943e-10)             // Permittivity of Si, SiO2 and vacuum 
`define C_EOX        (3.453133e-11)             // 
`define C_VAC        (8.8541878e-12)            // 
`define C_T300       (300e+00)                  // Room temperature constants 
`define C_b300       (3.868283e+01)             // 
`define C_Nin0       (1.04e+16)                 // Intrinsic carrier density at 300K 
//---------------------------------------------------* 
//* Functions. (macro)  Take care of the arguments.
//*-----------------*/
`define Fn_Sqr(x)   ( (x)*(x) ) // x^2 */
`define Fn_Max(x,y) ( (x) >= (y) ? (x) : (y) ) // max[x,y] */
`define Fn_Min(x,y) ( (x) <= (y) ? (x) : (y) ) // min[x,y] */
`define Fn_Sgn(x)   ( (x) >= 0  ?  (1) : (-1) )    // sign[x] */
`ifdef  __STDC__
`define BINNING(UC_PARAM, PARAM, LPARAM, WPARAM, PPARAM) UC_PARAM = PARAM \
  + LPARAM / Lbin + WPARAM / Wbin \
  + PPARAM / LWbin ;
`else  
`define BINNING(UC_PARAM, PARAM, LPARAM, WPARAM, PPARAM) UC_PARAM = PARAM \
  + LPARAM / Lbin + WPARAM / Wbin \
  + PPARAM / LWbin ;
`endif 
`define RANGECHECK(param, min, max, pname)          \
  if( COERRREP &&((param) <(min) ||(param) >(max)) ) begin \
    $write("warning: (%s = %g) range [%g , %g].\n", \
           pname, (param), (min), (max) );   \
  end
`define RANGERESET(param, min, max, pname)              \
  if( COERRREP &&((param) >(max)) ) begin   \
    $write("reset  : (%s = %g to %g) range [%g , %g].\n", \
           pname, (param), (max), (min), (max) );     \
  end \
  if( COERRREP &&((param) <(min)) ) begin   \
    $write("reset  : (%s = %g to %g) range [%g , %g].\n", \
           pname, (param), (min), (min), (max) );     \
  end \
  if((param) <(min) ) begin  param  =(min); end    \
  if((param) >(max) ) begin  param  =(max); end 
`define MINCHECK(param, min, pname)    \
  if( COERRREP &&((param) <(min)) ) begin             \
    $write("warning: (%s = %g) range [%g , %g].\n", \
           pname, (param), (min), (min) );                     \
  end

`define RANGECHECKFoo(param, min, max, pname)          \
  if( ((param) <= (min) || (param) >= (max)) ) begin \
    $write("fatal(HiSIM(%m)): (%s = %g) range (%g , %g).\n", \
           pname, (param), (min*1.0), (max*1.0) );            \
    FATAL_flag = 1; \
  end
`define RANGECHECKFco(param, min, max, pname)          \
  if( ((param) <  (min) || (param) >= (max)) ) begin \
    $write("fatal(HiSIM(%m)): (%s = %g) range [%g , %g).\n", \
           pname, (param), (min*1.0), (max*1.0) );            \
    FATAL_flag = 1; \
  end
`define RANGECHECKFoc(param, min, max, pname)          \
  if( ((param) <= (min) || (param) >  (max)) ) begin \
    $write("fatal(HiSIM(%m)): (%s = %g) range (%g , %g].\n", \
           pname, (param), (min*1.0), (max*1.0) );            \
    FATAL_flag = 1; \
  end
`define RANGECHECKFcc(param, min, max, pname)          \
  if( ((param) <  (min) || (param) >  (max)) ) begin \
    $write("fatal(HiSIM(%m)): (%s = %g) range [%g , %g].\n", \
           pname, (param), (min*1.0), (max*1.0) );            \
    FATAL_flag = 1; \
  end

`define  Nsubmin     (1e15 / `C_cm2m_p3) 
`define  Nsubmin_dlt (0.01 / `C_cm2m_p3)
`define  lpext_dlt   (1e-8 / `C_m2cm) 

//---------------------------------------------------* 
//* smoothZero: flooring to zero.
//*      y = 0.5 ( x + sqrt( x^2 + 4 delta^2 ) )
//*-----------------*/
`define Fn_SZtemp( y , x , delta ) begin \
    TMF1 = sqrt ( ( x ) *  ( x ) + 4.0 * ( delta ) * ( delta) ) ; \
    y = 0.5 * ( ( x ) + TMF1 ) ; \
  end
`define Fn_SUtemp( y , x , xmax , delta ) begin \
    TMF1 = ( xmax ) - ( x ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmax ) * ( delta) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    y = ( xmax ) - 0.5 * ( TMF1 + TMF2 ) ; \
  end
`define Fn_SLtemp( y , x , xmin , delta ) begin \
    TMF1 = ( x ) - ( xmin ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmin ) * ( delta ) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    y = ( xmin ) + 0.5 * ( TMF1 + TMF2 ) ; \
  end
`define vth_dlt      1.0e-3                 
`define cclmmdf      1.0e-1                 
`define qme_dlt      1.0e-4                 
`define eef_dlt      1.0e-2 * `C_m2cm       
`define sti2_dlt     2.0e-3                 
`define pol_dlt      5.0e-2                 
`define psisti_dlt   5.0e-3                 
`define lp_s0_max    40                     
`define lp_sl_max    40                     
`define lp_se_max    150
`define Ids_tol      1.0e-10                
`define Ids_maxvar   1.0e-1                 
`define dP_max       0.1e0                  
`define ps_conv      5.0e-13                
//`define ps_conv      5.0e-12                
`define ps_conv2     1.0e-10
`define gs_conv      1.0e-8                 
`define mini_current 1.0e-15                
`define znbd3        3.0e0                  
`define znbd5        5.0e0                  
`define cn_nc3       `C_SQRT_2 / 108e0      
`define cn_nc51      0.707106781186548     // sqrt(2)/2 */
`define cn_nc52     -0.117851130197758     // -sqrt(2)/12 */
`define cn_nc53      0.0178800506338833    // (187 - 112*sqrt(2))/1600 */
`define cn_nc54     -0.00163730162779191   // (-131 + 88*sqrt(2))/4000 */
`define cn_nc55      6.36964918866352e-5   // (1509-1040*sqrt(2))/600000 */
`define cn_im53      2.9693154855770998e-1   
`define cn_im54     -7.0536542840097616e-2   
`define cn_im55      6.1152888951331797e-3   
`define c_ps0ini_2   8.0e-4                 
`define c_pslini_1   0.3e0                  
`define c_pslini_2   3.0e-2                 
`define VgVt_Small   1.0e-12                
`define Vbs_min     -30.0
`define Vds_max      10.5e0                 
`define Vgs_max      10.5e0                 
`define epsm10       10.0e0 * `C_EPS_M      
`define Small        1.0e-50                
`define Small2       1.0e-12                // for Qover */
`define pol_b        1.0                    
`define igate_dlt    1.0e-2                 
`define gidlvds_dlt  1.0e-5                 
`define gidla        100.0                  
`define c_sqrt_15    3.872983346207417e0    // sqrt(15) */
`define Cox_Small    1.0e-6                 
`define c_16o135     1.185185185185185e-1   // 16/135 */
`define delta_rd     10e-3 * `C_cm2m
`define Ra_N         20.0                   // smoothing parameter for Ra */
`define dQdrat        ( 1.0e-8 )
`define large_arg    60 // 80                     
`define SUBVERSION   ( VERSION *  10 % 10 )
`define inf          1e+300
`define C_1o6        (1.666666666666667e-01)    // 1/6

//*-----------------*/
//-----------------------------------* 
//* HiSIM constants
//*-----------------*/
`define C_sce_dlt    (1.0e-2)                   // 
`define C_gidl_delta 0.5                        // 
`define C_PSLK_DELTA 1e-3     // delta for Pslk smoothing */
`define C_PSLK_SHIFT 1.0      // constant value for temporary shift */
`define C_IDD_MIN    1.0e-15                    // 
//===========================================================* 
//* pow
//*=================*/
`ifdef  POW_TO_EXP_AND_LOG
`define Fn_Pow( x , y ) ((x==0.0) ? 0.0 : exp((y) * ln( x ) ) )
`else  
`define Fn_Pow( x , y )  ( (x==0.0) ? 0.0 : pow( x , y ))
`endif 
//===========================================================* 
//* Exp() for PGD.
//* - ExpLim(-3)=0
//*=================*/
`define Fn_ExpLim( y , x , dx ) begin \
    if((x) < -3.0 ) begin \
      dx = 0.0 ; \
      y = 0.0 ; \
    end else if((x) < 0.0 ) begin \
      dx =  1.0 + (x) * ( 2 * (1.0/3.0) + (x) * 3 * (1.0/27.0) )  ; \
      y = 1.0 + (x) * ( 1.0 + (x) * ( (1.0/3.0) + (x) * (1.0/27.0) ) ) ; \
    end else begin \
      dx =  1.0 + (x) * ( 2 * (1.0/3.0) + (x) * ( 3 * 0.0402052934513951 \
                + (x) * 4 * 0.148148111111111 ) ) ; \
      y = 1.0 + (x) * ( 1.0 + (x) * ( (1.0/3.0) + (x) * ( 0.0402052934513951 \
              + (x) * 0.148148111111111 ) ) ) ; \
    end \
end
//===========================================================* 
//* Ceiling, smoothing functions.
//*=================*/
//---------------------------------------------------* 
//* smoothUpper: ceiling.
//*      y = xmax - 0.5 ( arg + sqrt( arg^2 + 4 xmax delta ) )
//*    arg = xmax - x - delta
//*-----------------*/
`define Fn_SU( y , x , xmax , delta , dx ) begin \
    TMF1 = ( xmax ) - ( x ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmax ) * ( delta) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    dx = 0.5 * ( 1.0 + TMF1 / TMF2 ) ; \
    y = ( xmax ) - 0.5 * ( TMF1 + TMF2 ) ; \
  end
`define Fn_SU2( y , x , xmax , delta , dy_dx , dy_dxmax ) begin \
    TMF1 = ( xmax ) - ( x ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmax ) * ( delta) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    dy_dx = 0.5 * ( 1.0 + TMF1 / TMF2 ) ; \
    dy_dxmax = 0.5 * ( 1.0 - ( TMF1 + 2.0 * delta ) / TMF2 ) ; \
    y = ( xmax ) - 0.5 * ( TMF1 + TMF2 ) ; \
  end
//---------------------------------------------------* 
//* smoothLower: flooring.
//*      y = xmin + 0.5 ( arg + sqrt( arg^2 + 4 xmin delta ) )
//*    arg = x - xmin - delta
//*-----------------*/
`define Fn_SL( y , x , xmin , delta , dx ) begin \
    TMF1 = ( x ) - ( xmin ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmin ) * ( delta ) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    dx = 0.5 * ( 1.0 + TMF1 / TMF2 ) ; \
    y = ( xmin ) + 0.5 * ( TMF1 + TMF2 ) ; \
  end
//---------------------------------------------------* 
//* smoothZero: flooring to zero.
//*      y = 0.5 ( x + sqrt( x^2 + 4 delta^2 ) )
//*-----------------*/
`define Fn_SZ( y , x , delta , dx ) begin \
    TMF2 = sqrt ( ( x ) *  ( x ) + 4.0 * ( delta ) * ( delta) ) ; \
    dx = 0.5 * ( 1.0 + ( x ) / TMF2 ) ; \
    y = 0.5 * ( ( x ) + TMF2 ) ; \
    if( y < 0.0 ) begin y=0.0; dx=0.0; end \
  end
//---------------------------------------------------* 
//* smoothZero: flooring to zero.
//*      y = 0.5 ( x + sqrt( x^2 + 4 delta^2 ) )
//*-----------------*/
//---------------------------------------------------* 
//* CeilingPow: ceiling for positive x, flooring for negative x.
//*      y = x * xmax / ( x^{2m} + xmax^{2m} )^{1/(2m)}
//* note:
//*   - xmax has to be positive.
//*   - -xmax < y < xmax.
//*   - dy/dx|_{x=0} = 1.
//*-----------------*/
//---------------------------------------------------* 
//* CeilingPow: ceiling for positive x, flooring for negative x.
//*      y = x * xmax / ( x^{2m} + xmax^{2m} )^{1/(2m)}
//* note: 
//*   - xmax has to be positive.
//*   - -xmax < y < xmax.
//*   - dy/dx|_{x=0} = 1.
//*-----------------*/
`define Fn_CP( y , x , xmax , pw , dx ) begin \
  x2 = (x) * (x) ; \
  xmax2 = (xmax) * (xmax) ; \
  xp = 1.0  ;\
  xmp = 1.0 ; \
  for ( m0 = 0 ; m0 < pw ; m0 = m0 + 1 ) begin xp = xp * x2 ; xmp = xmp * xmax2 ; end \
  arg = xp + xmp ; \
  dnm = arg ; \
  if( pw == 1 || pw == 2 || pw == 4 || pw == 8 ) begin \
    if ( pw == 1 ) begin mm = 1 ; \
    end else if ( pw == 2 ) begin mm = 2 ; \
    end else if ( pw == 4 ) begin mm = 3 ; \
    end else if ( pw == 8 ) begin mm = 4 ; end \
    for ( m0 = 0 ; m0 < mm ; m0 = m0 + 1 ) begin dnm = sqrt( dnm ) ; end \
  end else begin dnm = `Fn_Pow( dnm , 1.0 / ( 2.0 * pw ) ) ; end \
  dnm = 1.0 / dnm ; \
  y = (x) * (xmax) * dnm ; \
  dx = (xmax) * xmp * dnm / arg ; \
end
`define Fn_SU_CP( y , x , xmax , delta , pw , dx ) begin \
 if(x > xmax - (delta) && (delta) >= 0.0) begin \
   TMF1 = x - (xmax) + delta ; \
   `Fn_CP( TMF0 , TMF1 , delta , pw , dx )  \
   y = xmax - (delta) + TMF0 ; \
   dx = dx ; \
 end else begin \
   y = x ; \
   dx = 1.0 ; \
 end \
end

`define Fn_SL_CP( y , x , xmin , delta , pw , dx ) begin \
 if((x) < (xmin) + (delta) && (delta) >= 0.0) begin \
   TMF1 = (xmin) + (delta) - (x) ; \
   `Fn_CP( TMF0 , TMF1 , delta , pw , dx )  \
   y = xmin + delta - TMF0 ; \
   dx = dx ; \
 end else begin \
   y = x ; \
   dx = 1.0 ; \
 end \
end


//===========================================================* 
//* Functions for symmetry.
//*=================*/
//---------------------------------------------------* 
//* Declining function using a polynomial.
//*-----------------*/
`define Fn_DclPoly4( y , x , dx ) begin \
  TMF2 = (x) * (x) ; \
  TMF3 = TMF2 * (x) ; \
  TMF4 = TMF2 * TMF2 ; \
  y = 1.0 / ( 1.0 + (x) + TMF2 + TMF3 + TMF4 ) ; \
  dx = - ( 1.0 + 2.0 * (x) + 3.0 * TMF2 + 4.0 * TMF3 )  * y * y  ; \
end 

`define Fn_SUPoly4m( y , x , xmax , dx , dxmax ) begin \
 TMF1 = (x) / xmax ; \
 `Fn_DclPoly4( TMF0 , TMF1 , dx )  \
 y = xmax * ( 1.0 - TMF0 ) ; \
 dxmax = 1.0 - TMF0 + TMF1 * dx ; \
 dx = - dx ; \
end

//---------------------------------------------------* 
//* "smoothUpper" using a polynomial
//*-----------------*/
`define Fn_SUPoly4( y , x , xmax , dx ) begin \
 TMF1 = (x) / xmax ; \
 `Fn_DclPoly4( y , TMF1 , dx ) \
 y = xmax * ( 1.0 - y ) ; \
 dx = - dx ; \
end
//---------------------------------------------------* 
//* SymAdd: evaluate additional term for symmetry.
//*-----------------*/
`define Fn_SymAdd( y , x , add0 , dx ) \
begin \
    TMF1 = 2.0 * ( x ) / ( add0 ) ; \
    TMF2 = 1.0 + TMF1 * ( (1.0/2) + TMF1 * ( (1.0/6) \
               + TMF1 * ( (1.0/24) + TMF1 * ( (1.0/120) \
               + TMF1 * ( (1.0/720) + TMF1 * (1.0/5040) ) ) ) ) ) ; \
    TMF3 = (1.0/2) + TMF1 * ( (1.0/3) \
               + TMF1 * ( (1.0/8) + TMF1 * ( (1.0/30) \
               + TMF1 * ( (1.0/144) + TMF1 * (1.0/840) ) ) ) ) ; \
    y = add0 / TMF2 ; \
    dx = - 2.0 * TMF3 / ( TMF2 * TMF2 ) ; \
end

//---------------------------------------------------* 
//* 4th order additional term for symmetry.
//*-----------------*/
`define Fn_Sym4( y , x , add0 ) \
 begin \
     TMF1 = pow( (x) , 4 ) ; \
     TMF2 = pow( (add0) , 4 ) ; \
     y = pow( (TMF1+TMF2) , 0.25 ) - pow(TMF2,0.25) ; \
 end

//===========================================================*
//* Sigmoid function
//*=================*/
`define Fn_Sigmoid( y , x ) y = 1.0 / ( 1.0 + lexp(- (x)) );

//---------------------------------------------------* 
//* Macros for body diode model.
//*-----------------*/
`define HSM2_Idio_args1(js, JS0, XTI, NJ) begin \
  js = JS0 * exp((egtnom * betatnom - Eg * beta + XTI * log_Tratio) / NJ) ; \
end

`define HSM2_Idio_args2(is_btm, is2_btm, is_sws, is2_sws, is_swg, is2_swg, PD, AD) begin \
  if( PD > weff_nf ) begin \
     is_btm  = AD * js  ; \
     is2_btm = AD * js2 ; \
     is_sws  = (PD - weff_nf) * jssw  ; \
     is2_sws = (PD - weff_nf) * jssw2 ; \
     is_swg  = weff_nf * jsswg ; \
     is2_swg = weff_nf * jsswg2 ; \
  end else begin \
     is_btm  = AD * js  ; \
     is2_btm = AD * js2 ; \
     is_sws  = 0.0 ; \
     is2_sws = 0.0 ; \
     is_swg  = PD * jsswg ; \
     is2_swg = PD * jsswg2 ; \
  end \
end

`define HSM2_Idio_args2_compat(is_btm, is2_btm, is_sws, is2_sws, is_swg, is2_swg, PD, AD) begin \
  is_btm  = AD * js  ; \
  is2_btm = AD * js2 ; \
  is_sws  = PD * jssw  ; \
  is2_sws = PD * jssw2 ; \
  is_swg  = 0.0 ; \
  is2_swg = 0.0 ; \
end

`define HSM2_Qdio_args1(czbd, czbdsw, czbdswg, PD, AD, CJD, TCJBD, CJSWD, TCJBDSW, CJSWGD, TCJBDSWG) begin \
  czbd = CJD * AD * ( 1.0 + TCJBD * Tdiff) ; \
  if(PD > weffcv_nf) begin \
    czbdsw  = CJSWD  * ( PD - weffcv_nf ) * ( 1.0 + TCJBDSW  * Tdiff) ; \
    czbdswg = CJSWGD *        weffcv_nf   * ( 1.0 + TCJBDSWG * Tdiff) ; \
  end else begin \
    czbdsw  = 0.0 ; \
    czbdswg = CJSWGD *   PD             * ( 1.0 + TCJBDSWG * Tdiff) ; \
  end \
end

`define HSM2_Idio(Idio, Vdio, is, is2,  vt_X, jd_expc_X,  T10_X, T11_X, T9_X, jd_nvtm_inv_X, UC_CISBK_X, DIVX_X) begin \
  if( is > 0 ) begin \
    T0 = is2 * T9_X ; \
    TX = - Vdio * T10_X ; \
    T2 = exp ( TX ); \
    TX = - Vdio * T11_X ; \
    T3 = exp ( TX ); \
    if( Vdio < vt_X ) begin \
      TX = Vdio * jd_nvtm_inv_X ; \
      if( TX < - 3*`EXP_THR ) begin \
        T1 = 0.0 ; \
      end else begin \
        T1 = exp ( TX ) ; \
      end \
      Idio = is * (T1 - 1.0) + T0 * (T2 - 1.0) + UC_CISBK_X * (T3 - 1.0); \
    end else begin \
      T1 = jd_expc_X ; \
      T4 = is * jd_nvtm_inv_X * T1 ; \
      Idio = is * (T1 - 1.0) + T4 * (Vdio - vt_X) + T0 * (T2 - 1.0) + UC_CISBK_X * (T3 - 1.0) ; \
    end \
  end else begin \
    Idio = 0.0 ; \
  end \
  T12 = DIVX_X * is2 ; \
  Idio = Idio + T12 * Vdio ; \
end

`define HSM2_Qdio(Qdio, Capdio, Vdio, cz, PB, MJ) begin \
  if(Vdio < 0.0) begin \
    if(cz > 0.0) begin \
      arg = 1.0 - Vdio / PB ; \
      if(MJ == 0.5) sarg = 1.0 / sqrt(arg) ; \
      else sarg = `Fn_Pow( arg , -MJ ) ; \
      Qdio = PB * cz * (1.0 - arg * sarg) / (1.0 - MJ) ; \
      Capdio = cz * sarg ; \
    end else begin \
      Qdio = 0.0 ; \
      Capdio = 0.0 ; \
    end \
  end else begin \
    T1 = cz ; \
    T2 = cz * MJ / PB ; \
    Qdio = Vdio * (T1 + Vdio * 0.5 * T2) ; \
    Capdio = T1 + Vdio * T2 ; \
  end \
end

//End of File: HSM2_macrosAndDefs.inc

//Start of HiSIM model code

//`define _AGING_
//`define __AGING_DEBUG__

// Module Definition
`ifdef _AGING_
module hisim2_va(d, g, s, b);
   voltage   idtag1 , idtag3 , vgc1 , ve1  ; // Internal Nodes for Aging
   voltage   dVfb , idtag4 ;  
   voltage   ps0    , vtraplx              ;
`else
module hisim2_va(d, g, s, b);
`endif
   inout      d, g, s, b;
   electrical d, g, s, b;  // External Nodes 
   electrical dp, gp, sp, bp, db, sb, n    ;  // Internal Nodes 
   electrical int_nqs_b, int_nqs_i         ;  // Internal Nodes for NQS

// Branch Definitions

   branch(sb,sp) BRsbs  ;
   branch(db,dp) BRdbd  ;
   branch(dp,sp) BRdpsp ;
   branch(dp,bp) BRdpbp ;
   branch(sp,bp) BRspbp ;
   branch(gp,sp) BRgpsp ;
   branch(gp,dp) BRgpdp ;
   branch(gp,bp) BRgpbp ;
   branch(g ,gp) BRggp  ;
   branch(gp,s ) BRgps  ;
   branch(gp,d ) BRgpd  ;
   branch(d ,dp) BRddp  ;
   branch(d ,s ) BRds   ;
   branch(sp,s ) BRsps  ;
   branch(bp,sp) BRbpsp ;
   branch(bp,d ) BRbpd  ;
   branch(bp,s ) BRbps  ;
   branch(sb,bp) BRsbbp ;
   branch(db,bp) BRdbbp ;
   branch(b ,bp) BRbbp  ;
   branch(b ,sb) BRbsb  ;
   branch(b ,db) BRbdb  ;
   branch(bp,dp) BRbpdp ;

//
// Parameter definitions
`MPRnb( VERSION   , 3.10      , ""                                , "Model version ")

//******* Device Parameters *******//
`IPRco( L         , 5.0E-6     , "m"                  ,  1n , inf , "Gate length ")
`IPRco( W         , 5.0E-6     , "m"                  ,  1n , inf , "Gate width ")
`IPRco( NRD       , 0.0        , "-"                  ,   0 , inf , "Number of squares in drain ")
`IPRco( NRS       , 0.0        , "-"                  ,   0 , inf , "Number of squares in source ")
`IPRco( NGCON     , 1.0        , "-"                  ,   1 , inf , "Number of gate contacts ")
`IPRnb( XGW       , 0.0        , "m"                              , "Distance from gate contact to channel edge ")
`IPRnb( XGL       , 0.0        , "m"                              , "Offset of gate length due to variation in patterning ")
`IPRco( NF        , 1.0        , "-"                  ,   1 , inf , "Number of fingers ")
`IPRco( SA        , 0.0        , "m"                  ,   0 , inf , "Distance from STI edge to Gate edge  ")
`IPRco( SB        , 0.0        , "m"                  ,   0 , inf , "Distance from STI edge to Gate edge  ")
`IPRco( SD        , 0.0        , "m"                  ,   0 , inf , "Distance from Gate edge to Gate edge  ")
`IPRnb( DTEMP     , 0.0        , "degC"                           , "Device temperature change")
`IPRnb( SCA       , 0.0        , "-"                              , "Layout characterization factor" )
`IPRnb( SCB       , 0.0        , "-"                              , "Layout characterization factor" )
`IPRnb( SCC       , 0.0        , "-"                              , "Layout characterization factor" )
`IPRoo( NSUBCDFM  , 5E17       , "1/cm^3"             ,   0 , inf , "Substrate impurity concentration for DFM")

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
`IPRco( AD        , 0.0        , "m^2"                ,   0 , inf , "Drain area ")
`IPRco( AS        , 0.0        , "m^2"                ,   0 , inf , "Source area ")
`IPRco( PD        , 0.0        , "m"                  ,   0 , inf , "Drain perimeter ")
`IPRco( PS        , 0.0        , "m"                  ,   0 , inf , "Source perimeter ")
`endif /* End of COEXTDIO */

//*** Model and Instance Parameters ***//
`BPIsw( CORG      , 0          , "-"                              , "Activate gate resistance(1) or not(0) ")
`BPIsw( CORBNET   , 0          , "-"                              , "Activate body resistance(1) or not(0) ")
`BPRco( RBPB      , 50.0       , "Ohm"                ,   0 , inf , "Substrate resistance network")
`BPRco( RBPD      , 50.0       , "Ohm"                ,   0 , inf , "Substrate resistance network")
`BPRco( RBPS      , 50.0       , "Ohm"                ,   0 , inf , "Substrate resistance network")
`BPRco( RBDB      , 50.0       , "Ohm"                ,   0 , inf , "Substrate resistance network")
`BPRco( RBSB      , 50.0       , "Ohm"                ,   0 , inf , "Substrate resistance network")
`BPRnb( MPHDFM    , -0.3       , "-"                              , "NSUBCDFM dependence of phonon scattering for DFM ")

//******* Model Flags *******//
`MPIcc( CODEP     , 0          , "-"                  ,   0 ,   3 , "Selector for depletion device ")
`MPIcc( CORSRD    , 0          , "-"                  ,  -1 ,   2 , "Handling of Rs and Rd ")
`MPIsw( COIPRV    , 0          , "-"                              , "Use ids_prv as initial guess of Ids(internal flag) ")
`MPIsw( COPPRV    , 0          , "-"                              , "not supported ")
`MPIsw( COADOV    , 1          , "-"                              , "Add overlap to intrinsic ")
`MPIsw( COISUB    , 0          , "-"                              , "Calculate isub ")
`MPIsw( COIIGS    , 0          , "-"                              , "Calculate igate ")
`MPIsw( COGIDL    , 0          , "-"                              , "Calculate igidl ")
`MPIsw( COOVLP    , 1          , "-"                              , "Calculate overlap charge on the drain side ")
`MPIsw( COFLICK   , 0          , "-"                              , "Calculate 1/f noise ")
`MPIsw( COISTI    , 0          , "-"                              , "Calculate STI ")
`MPIsw( CONQS     , 0          , "-"                              , "Calculate in nqs mode or qs mode ")
`MPIsw( COTHRML   , 0          , "-"                              , "Calculate thermal noise ")
`MPIsw( COIGN     , 0          , "-"                              , "Calculate induced gate noise ")
`MPIsw( CODFM     , 0          , "-"                              , "Calculation of model for DFM ")
`MPIsw( CORECIP   , (CODEP!=0 ? 0:1), "-"                         , "Calculate accurate capacitance reciprocity" )
`MPIsw( COQY      , 0          , "-"                              , "Calculate Qy" )
`MPIcc( COQOVSM   , 1          , "-"                  ,   0 ,   2 , "Selector for smoothing method of Qover ")
`MPIsw( COERRREP  , 1          , "-"                              , "Selector for error report ")
`MPInb( INFO      , 0          , "-"                              , "Print information")
`MPIsw( CODDLT    , 1          , "-"                              , "Selector for DDLT model ")
`MPIsw( CODIO     , 0          , "-"                              , "selector for updated diode model ")
`MPIcc( COVDSRES  , 3          , "-"                  ,  -1 ,   3 , "Vdssatres,Vdsres model switch: (-1) Vdsres=Vds; (3) Vdssatres ln(1+exp) depmos3")
`MPIcc( COPT      , 0          , "-"                  ,   0 ,   1 , "flag punchthrough ")   
`MPIsw( COPSPT    , 0          , "-"                              , "flag Ps0 method for deep punchthrough ")   
`ifdef _AGING_
`BPIsw( CODEG     , 0          , "-"                              , "Selector for Aging model ")
`BPIcc( CODEGSTEP , 0          , "-"                  ,   0 ,   2 , "Selector for Aging model ")
`BPIsw( CODEGES0  , 0          , "-"                              , "Selector for TRAPES0/TRAPGC0 ")
`endif

//******* Technology Model Parameters *******//
`MPIty( TYPE      , 1          , "-"                              , "Mosfet TYPE: 1=NMOS and -1=PMOS")
`MPRoo( VMAX      , 1E7        , "cm/s"               ,   0 , inf , "Saturation velocity  ")
`MPRnb( BGTMP1    , 90.25E-6   , "eV/K"                           , "First order temp. coeff. for band gap  ")
`MPRnb( BGTMP2    , 1.0E-7     , "eV/K^2"                         , "Second order temp. coeff. for band gap  ")
`MPRoo( EG0       , 1.1785     , "eV"                 ,   0 , inf , "Bandgap")
`MPRoo( TOX       , 3E-9       , "m"                  ,   0 , inf , "Oxide thickness  ")
`MPRco( XLD       , 0.0        , "m"                  ,   0 , inf , "Lateral diffusion of S/D under the gate  ")
`MPRco( XLDC      , XLD        , "m"                  ,   0 , inf , "Lateral diffusion of S/D under the gate (capacitance) ")
`MPRco( LOVER     , 30E-9      , "m"                  ,   0 , inf , "Overlap length")
`MPRco( DDLTMAX   , 10         , "-"                  ,   1 , inf , "Smoothing coefficient for Vds")
`MPRco( DDLTSLP   , (CODDLT==0 ?  0 : 10) , "um^-1"   ,   0 , inf , "Lgate dependence of smoothing coefficient")
`MPRnb( DDLTICT   , (CODDLT==0 ? 10 :  0) , "-"                   , "Lgate dependence of smoothing coefficient")
`MPRnb( VFBOVER   , 0.0        , "-"                              , "Flat-band voltage in overlap region")
`MPRco( NOVER     , 1E19       , "1/cm^3"             ,   0 , inf , "Impurity concentration in overlap region")
`MPRnb( XWD       , 0.0        , "m"                              , "Lateral diffusion along the width dir.  ")
`MPRnb( XWDC      , XWD        , "m"                              , "Lateral diffusion along the width dir. (capacitance) ")   
`MPRnb( XL        , 0.0        , "m"                              , "Gate length offset due to mask/etch effect  ")
`MPRnb( XW        , 0.0        , "m"                              , "Gate width offset due to mask/etch effect  ")
`MPRco( SAREF     , 1E-6       , "m"                  ,   0 , inf , "Reference distance from STI edge to Gate edge  ")
`MPRco( SBREF     , 1E-6       , "m"                  ,   0 , inf , "Reference distance from STI edge to Gate edge  ")
`MPRnb( LL        , 0.0        , "m^(LLN+1)"                      , "Gate length parameter ")
`MPRnb( LLD       , 0.0        , "m"                              , "Gate length parameter ")
`MPRnb( LLN       , 0.0        , "-"                              , "Gate length parameter ")
`MPRnb( WL        , 0.0        , "m^(WLN+1)"                      , "Gate width parameter ")
`MPRnb( WL1       , 0.0        , "-"                              , "Gate width parameter ")
`MPRnb( WL1P      , 1.0        , "-"                              , "Gate width parameter ")
`MPRnb( WL2       , 0.0        , "V"                              , "Gate width parameter ")
`MPRnb( WL2P      , 1.0        , "-"                              , "Gate width parameter ")
`MPRnb( WLD       , 0.0        , "m"                              , "Gate width parameter ")
`MPRnb( WLN       , 0.0        , "-"                              , "Gate width parameter ")
`MPRco( RSH       , 0.0        , "V/(A square)"       ,   0 , inf , "Source/drain diffusion sheet  resistance   ")
`MPRco( RSHG      , 0.0        , "V/(A square)"       ,   0 , inf , "Gate-electrode sheet resistance ")
`MPRco( XQY       , 10E-9      , "m"                  ,   0 , inf , "Distance from drain junction to maximum electric field point")
`MPRnb( XQY1      , 0.0        , "F"                              , "Vbs dependence of Qy")
`MPRnb( XQY2      , 2.0        , "-"                              , "Lgate dependence of Qy")
`MPRnb( QYRAT     , 0.5        , "-"                              , "Partitioning ratio of Qy between source and drain" )
`MPRco( RS        , 0.0        , "Ohm m"               ,  0 , inf , "Source contact resistance  ")
`MPRco( RD        , 0.0        , "Ohm m"               ,  0 , inf , "Drain contact resistance   ")
`MPRnb( VFBC      , (CODEP!=0 ? 0.2 : -1.0) , "V"                 , "Constant part of Vfb  ")
`MPRnb( VBI       , 1.1        , "V"                              , "Built-in potential  ")
`MPRoo( NSUBC     , (CODEP!=0 ? 5e16 : 5E17) , "1/cm^3" , 0 , inf , "Constant part of Nsub  ")  
`MPRnb( VFBCL     , 0.0        , "-"                              , "Channel length dependence of flat-band voltage" )
`MPRnb( VFBCLP    , 1.0        , "-"                              , "Channel length dependence of flat-band voltage" )
`MPRoo( PARL2     , 10.0E-9    , "m"                 , -inf ,   L , "Under diffusion  ")
`MPRcc( LP        ,  0         , "m"                  ,   0 ,   L , "Length of pocket potential  ")
`MPRoo( NSUBP     , (CODEP!=0 ? 1e17 : 1e18) , "1/cm^3" , 0 , inf , "Maximum pocket concentration ")
`MPRoo( NSUBPL    , 0.001      , "-"                    , 0 , inf , "Starting channel length of NSUBP reduction" )
`MPRnb( NSUBPFAC  , 1.0        , "-"                              , "Minimum factor of reduction" )
`MPRnb( NSUBPDLT  , 0.01       , "-"                              , "Delta for smoothness of the NSUBPFAC model" )
`MPRnb( NSUBPW    , 0.0        , "-"                              , "Modification of pocket concentration for narrow width" )
`MPRnb( NSUBPWP   , 1.0        , "-"                              , "Modification of pocket concentration for narrow width" )
`MPRnb( SCP1      , 1.0        , "-"                              , "Parameter for pocket  ")
`MPRnb( SCP2      , 0.0        , "1/V"                            , "Parameter for pocket  ")
`MPRnb( SCP3      , 0.0        , "m/V"                            , "Parameter for pocket  ")
`MPRnb( SC1       , 1.0        , "-"                              , "Parameter for SCE  ")
`MPRnb( SC2       , 0.0        , "1/V"                            , "Parameter for SCE  ")
`MPRnb( SC3       , 0.0        , "m/V"                            , "Parameter for SCE  ")
`MPRnb( SC4       , 0.0        , "1/V"                            , "Parameter for SCE  ")
`MPRnb( PGD1      , 0.0        , "V"                              , "Parameter for gate-poly depletion  ")
`MPRnb( PGD2      , 0.3        , "V"                              , "Parameter for gate-poly depletion  ")
`MPRnb( PGD4      , 0.0        , "-"                              , "Parameter for gate-poly depletion  ")
`MPRnb( NDEP      , 1.0        , "-"                              , "Coeff. of Qbm for Eeff  ")
`MPRnb( NDEPL     , 0.0        , "-"                              , "Coeff. of Qbm for Eeff  ")
`MPRnb( NDEPLP    , 1.0        , "-"                              , "Coeff. of Qbm for Eeff  ")
`MPRnb( NDEPW     , 0.0        , "-"                              , "Modification of extension concentration for narrow width" )
`MPRnb( NDEPWP    , 1.0        , "-"                              , "Modification of extension concentration for narrow width" )
`MPRnb( NINV      , 0.5        , "-"                              , "Coeff. of Qnm for Eeff  ")
`MPRnb( NINVD     , 0.0        , "1/V"                            , "Modification of Vdse dependence on Eeff  ")
`MPRnb( NINVDL    , 0.0        , "-"                              , "Lgate reduced resistance effect for small subVds" )
`MPRnb( NINVDLP   , 1.0        , "-"                              , "Lgate reduced resistance effect for small subVds" )
`MPRnb( MUECB0    , 190        , "cm^2/Vs"                        , "Const. part of coulomb scattering  ")
`MPRnb( MUECB1    , 30         , "cm^2/Vs"                        , "Coeff. for coulomb scattering  ")
`MPRnb( MUEPH0    , 0.3        , "-"                              , "Power of Eeff for phonon scattering  ")
`MPRoo( MUEPH1    , (TYPE>0 ? 25E3 : 3E4) , "-"       ,   0 , inf , "Phonon scattering")
`MPRnb( MUEPHW    , 0.0        , "-"                              , "Phonon related mobility reduction")
`MPRnb( MUEPWP    , 1.0        , "-"                              , "Phonon scattering parameter ")
`MPRnb( MUEPWD    , 0.0        , "-"                              , "Width dependence of phonon mobility reduction" )
`MPRnb( MUEPHL    , 0.0        , "-"                              , "Phonon scattering parameter ")
`MPRnb( MUEPLP    , 1.0        , "-"                              , "Phonon scattering parameter ")
`MPRnb( MUEPLD    , 0.0        , "-"                              , "Length dependence of phonon mobility reduction" )
`MPRnb( MUEPHS    , 0.0        , "-"                              , "Mobility modification due to small size")
`MPRnb( MUEPSP    , 1.0        , "-"                              , "Mobility modification due to small size")
`MPRnb( VTMP      , 0.0        , "-"                              , "Temperature dependence of saturation velocity")
`MPRnb( WVTH0     , 0.0        , "-"                              , "Threshold voltage shift")
`MPRnb( MUESR0    , 2.0        , "-"                              , "Power of Eeff for S.R. scattering  ")
`MPRoo( MUESR1    , (CODEP!=0 ? 5E15 : 5E14 ) , "cm^2/(V s) (V/cm)^MUESR0"  ,   0 , inf , "Coeff. for S.R. scattering  ")
`MPRnb( MUESRL    , 0.0        , "-"                              , "Surface roughness parameter ")
`MPRnb( MUESRW    , 0.0        , "-"                              , "Change of surface roughness related mobility ")
`MPRnb( MUESWP    , 1.0        , "-"                              , "Change of surface roughness related mobility ")
`MPRnb( MUESLP    , 1.0        , "-"                              , "Surface roughness parameter ")
`MPRnb( MUETMP    , 1.5        , "-"                              , "Parameter for mobility  ")
`MPRco( BB        , (TYPE>0 ? 2 : 1) , "-"            , 0.1 , inf , "Empirical mobility model coefficient  ")
`MPRnb( SUB1      , 10         , "1/V"                            , "Parameter for Isub  ")
`MPRnb( SUB2      , 25         , "V"                              , "Parameter for Isub  ")
`MPRnb( SVGS      , 0.8        , "-"                              , "Coefficient for Vg of Psislsat ")
`MPRnb( SVBS      , 0.5        , "-"                              , "Coefficient for Vbs of Psislsat ")
`MPRnb( SVBSL     , 0.0        , "-"                              , "Lgate dependence of SVBS")
`MPRnb( SVBSLP    , 1.0        , "-"                              , "Lgate dependence of SVBS")
`MPRnb( SVDS      , 0.8        , "-"                              , "Substrate current dependence on Vds")
`MPRco( SLG       , 30E-9      , "m"                  ,   0 , inf , "Substrate current dependence on Lgate")
`MPRnb( SUB1L     , 2.5E-3     , "-"                              , "Lgate dependence of SUB1")
`MPRnb( SUB1LP    , 1.0        , "-"                              , "Lgate dependence of SUB1")
`MPRnb( SUB2L     , 2E-6       , "m"                              , "Lgate dependence of SUB2")
`MPRnb( SVGSL     , 0.0        , "-"                              , "Lgate dependence of SVGS")
`MPRnb( SVGSLP    , 1.0        , "-"                              , "Lgate dependence of SVGS")
`MPRnb( SVGSWP    , 1.0        , "-"                              , "Wgate dependence of SVGS")
`MPRnb( SVGSW     , 0.0        , "-"                              , "Wgate dependence of SVGS")
`MPRnb( SLGL      , 0.0        , "-"                              , "substrate current dependence on Lgate")
`MPRnb( SLGLP     , 1.0        , "-"                              , "substrate current dependence on Lgate")
`MPRnb( SUBTMP    , 0.0        , "1/degC"                         , "temperature dependence of Isub" )
`MPRoo( NSTI      , 5.0E17     , "1/cm^3"             ,   0 , inf , "Parameter for STI  ")
`MPRnb( WSTI      , 0.0        , "m"                              , "Parameter for STI  ")
`MPRnb( WSTIL     , 0.0        , "-"                              , "Parameter for STI  ")
`MPRnb( WSTILP    , 1.0        , "-"                              , "Parameter for STI  ")
`MPRnb( WSTIW     , 0.0        , "-"                              , "Parameter for STI  ")
`MPRnb( WSTIWP    , 1.0        , "-"                              , "Parameter for STI  ")
`MPRnb( SCSTI1    , 0.0        , "-"                              , "Parameter for STI  ")
`MPRnb( SCSTI2    , 0.0        , "1/V"                            , "Parameter for STI  ")
`MPRnb( VTHSTI    , 0.0        , "V"                              , "Parameter for STI  ")
`MPRnb( VDSTI     , 0.0        , "-"                              , "Parameter for STI  ")
`MPRco( MUESTI1   , 0.0        , "m"                  ,   0 , inf , "STI Stress mobility parameter ")
`MPRoo( MUESTI2   , 0.0        , "-"                  ,  -1 , inf , "STI Stress mobility parameter ")
`MPRnb( MUESTI3   , 1.0        , "-"                              , "STI Stress mobility parameter ")
`MPRco( NSUBPSTI1 , 0.0        , "m"                  ,   0 , inf , "STI Stress pocket implant parameter ")
`MPRoo( NSUBPSTI2 , 0.0        , "-"                  ,  -1 , inf , "STI Stress pocket implant parameter ")
`MPRnb( NSUBPSTI3 , 1.0        , "-"                              , "STI Stress pocket implant parameter ")
`MPRco( NSUBCSTI1 , 0.0        , "m"                  ,   0 , inf , "Channel concentration change due to diffusion-region length between gate and STI" )
`MPRoo( NSUBCSTI2 , 0.0        , "-"                  ,  -1 , inf , "Channel concentration change due to diffusion-region length between gate and STI" )
`MPRnb( NSUBCSTI3 , 1.0        , "-"                              , "Channel concentration change due to diffusion-region length between gate and STI" )
`MPRoo( LPEXT     , 1.0E-50    , "m"                  ,  0 ,  inf , "Pocket extension ")
`MPRoo( NPEXT     , 5.0E17     , "1/cm^3"             ,  0 ,  inf , "Pocket extension ")
`MPRnb( NPEXTW    , 0.0        , "-"                              , "Modification of extension concentration for narrow width" )
`MPRnb( NPEXTWP   , 1.0        , "-"                              , "Modification of extension concentration for narrow width" )
`MPRnb( SCP21     , 0.0        , "V"                              , "Short-channel-effect modification for small Vds")
`MPRnb( SCP22     , 0.0        , "V^3"                            , "Short-channel-effect modification for small Vds")
`MPRnb( BS1       , 0.0        , "V^2"                            , "Body-coefficient modification due to impurity profile")
`MPRnb( BS2       , 0.9        , "V"                              , "Body-coefficient modification due to impurity profile")
`MPRco( TPOLY     , 200E-9     , "m"                  ,   0 , inf , "Height of poly gate on the source side ")
`MPRco( CGBO      , 0.0        , "F/m"                ,   0 , inf , "Cgbo ")
`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
`MPRnb( JS0       , 0.5E-6     , "A/m^2"                          , "Saturation current density  ")
`MPRnb( JS0SW     , 0.0        , "A/m"                            , "Side wall saturation current density  ")
`MPRnb( JS0SWG    , JS0SW      , "A/m"                            , "gate sidewall saturation current density" )
`MPRoo( NJ        , 1.0        , "-"                  ,   0 , inf , "Emission coefficient  ")
`MPRoo( NJSW      , 1.0        , "-"                  ,   0 , inf , "Sidewall emission coefficient ")
`MPRnb( NJSWG     , NJSW       , "-"                              , "Gate sidewall emission coefficient" )
`MPRnb( XTI       , 2.0        , "-"                              , "Junction current temperature exponent coefficient  ")
`MPRnb( CJ        , 5.0E-04    , "F/m^2"                          , "Bottom junction capacitance per unit area at zero bias  ")
`MPRnb( CJSW      , 5.0E-10    , "F/m"                            , "Source/drain sidewall junction capacitance grading coefficient per unit length at zero bias  ")
`MPRnb( CJSWG     , 5.0E-10    , "F/m"                            , "Source/drain gate sidewall junction capacitance per unit length at zero bias  ")
`MPRoo( MJ        , 0.5        , "-"                 , -inf ,   1 , "Bottom junction capacitance grading coefficient ")
`MPRoo( MJSW      , 0.33       , "-"                 , -inf ,   1 , "Source/drain sidewall junction capacitance grading coefficient ")
`MPRoo( MJSWG     , 0.33       , "-"                 , -inf ,   1 , "Source/drain gate sidewall junction capacitance grading coefficient ")
`MPRoo( PB        , 1.0        , "V"                 ,    0 , inf , "Bottom junction build-in potential   ")
`MPRoo( PBSW      , 1.0        , "V"                 ,    0 , inf , "Source/drain sidewall junction build-in potential  ")
`MPRoo( PBSWG     , 1.0        , "V"                 ,    0 , inf , "Source/drain gate sidewall junction build-in potential  ")
`MPRnb( TCJBD     , 0.0        , "K^-1"                           , "Temperature dependence of cjbd ")
`MPRnb( TCJBS     , 0.0        , "K^-1"                           , "Temperature dependence of cjbs ")
`MPRnb( TCJBDSW   , 0.0        , "K^-1"                           , "Temperature dependence of cjbdsw ")
`MPRnb( TCJBSSW   , 0.0        , "K^-1"                           , "Temperature dependence of cjbssw ")
`MPRnb( TCJBDSWG  , 0.0        , "K^-1"                           , "Temperature dependence of cjbdswg ")
`MPRnb( TCJBSSWG  , 0.0        , "K^-1"                           , "Temperature dependence of cjbsswg ")
`MPRnb( XTI2      , 0.0        , "-"                              , "Temperature coefficient  ")
`MPRnb( CISB      , 0.0        , "-"                              , "Reverse bias saturation current  ")
`MPRnb( CVB       , 0.0        , "-"                              , "Bias dependence coefficient of cisb  ")
`MPRnb( CTEMP     , 0.0        , "-"                              , "Temperature coefficient  ")
`MPRnb( CISBK     , 0.0        , "A"                              , "Reverse bias saturation current  ")
`MPRnb( CVBK      , CVB        , "-"                              , "Bias dependence coefficient of CISB at low temperature  ")
`MPRnb( DIVX      , 0.0        , "1/V"                            , "Reverse current coefficient")
`MPRnb( VDIFFJ    , 0.6E-3     , "V"                              , "Threshold voltage for S/D junction diode  ")
`endif /* End of COEXTDIO */
`MPRnb( CLM1      , 700.0E-3   , "-"                              , "Parameter for CLM  ")
`MPRnb( CLM2      , 2.0        , "-"                              , "Parameter for CLM  ")
`MPRnb( CLM3      , 1.0        , "-"                              , "Parameter for CLM  ")
`MPRnb( CLM5      , 1.0        , "-"                              , "Parameter for CLM  ")
`MPRnb( CLM6      , 0.0        , "-"                              , "Parameter for CLM  ")
`MPRnb( VOVER     , 0.3        , "-"                              , "Parameter for overshoot  ")
`MPRnb( VOVERP    , 0.3        , "-"                              , "Parameter for overshoot  ")
`MPRnb( WFC       , 0.0        , "F/m"                            , "Parameter for narrow channel effect  ")
`MPRnb( NSUBCW    , 0.0        , "-"                              , "Parameter for narrow channel effect  ")
`MPRnb( NSUBCWP   , 1.0        , "-"                              , "Parameter for narrow channel effect  ")
`MPRnb( NSUBCMAX  , 5E18       , "1/cm^3"                         , "Upper limit of substrate concentration for narrow width" )
`MPRnb( QME1      , 0.0        , "V m"                            , "Parameter for quantum effect  ")
`MPRnb( QME2      , 2.0        , "V"                              , "Parameter for quantum effect  ")
`MPRnb( QME3      , 0.0        , "m"                              , "Parameter for quantum effect  ")
`MPRnb( VOVERS    , 0.0        , "-"                              , "Parameter for overshoot  ")
`MPRnb( VOVERSP   , 0.0        , "-"                              , "Parameter for overshoot  ")
`MPRnb( GIDL1     , 2.0        , "V^(-3/2) s^-1 m"                , "Parameter for GIDL  ")
`MPRnb( GIDL2     , 3E7        , "V^-0.5 m^-1"                    , "Parameter for GIDL  ")
`MPRnb( GIDL3     , 0.9        , "-"                              , "Parameter for GIDL  ")
`MPRnb( GIDL4     , 0.0        , "V"                              , "Parameter for GIDL  ")
`MPRnb( GIDL5     , 0.2        , "-"                              , "Parameter for GIDL  ")
`MPRnb( GIDL6     , 0.0        , "-"                              , "Vbs dependence of the GIDL" )
`MPRnb( GIDL7     , 1.0        , "-"                              , "Correction of high-field contribution" )
`MPRnb( GLEAK1    , 50         , "V^(-3/2) s^-1"                  , "Parameter for gate current  ")
`MPRnb( GLEAK2    , 10E6       , "V^(-1/2)/m "                    , "Parameter for gate current  ")
`MPRnb( GLEAK3    , 60E-3      , "-"                              , "Parameter for gate current  ")
`MPRnb( GLEAK4    , 4.0        , "1/m"                            , "Parameter for gate current  ")
`MPRoo( GLEAK5    , 7.5E3      , "V/m"                ,   0 , inf , "Parameter for gate current  ")
`MPRnb( GLEAK6    , 250E-3     , "V"                              , "Parameter for gate current  ")
`MPRnb( GLEAK7    , 1E-6       , "m^2"                            , "Parameter for gate current  ")
`MPRnb( GLKSD1    , 1E-15      , "A*m/V^2"                        , "Parameter for gate current  ")
`MPRnb( GLKSD2    , 5E6        , "1/(V*m)"                        , "Parameter for gate current  ")
`MPRnb( GLKSD3    , -5E6       , "1/m"                            , "Parameter for gate current  ")
`MPRnb( GLKB1     , 5E-16      , "A/(V^2 m^2)"                    , "Parameter for gate current  ")
`MPRnb( GLKB2     , 1.0        , "m/V"                            , "Parameter for gate current  ")
`MPRnb( GLKB3     , 0.0       , "V"                               , "Parameter for gate current  ")
`MPRnb( EGIG      , 0.0        , "V"                              , "Parameter for gate current  ")
`MPRnb( IGTEMP2   , 0.0        , "V*K"                            , "Parameter for gate current  ")
`MPRnb( IGTEMP3   , 0.0        , "V*K^2"                          , "Parameter for gate current  ")
`MPRoo( VZADD0    , 2.0E-2     , "V"                  ,   0 , inf , "Vzadd at Vds=0   ")
`MPRoo( PZADD0    , 2.0E-2     , "V"                  ,   0 , inf , "Pzadd at Vds=0   ")
`MPRnb( NFTRP     , 10E9       , "V^-1"                           , "Ratio of trap density to attenuation coefficient")
`MPRnb( NFALP     , 1.0E-19    , "cm s"                           , "Contribution of the mobility fluctuation")
`MPRnb( NFALP1    , NFALP      , "cm s"                           , "Contribution of the mobility fluctuation")
`MPRnb( NFALP2    , NFALP      , "cm s"                           , "Contribution of the mobility fluctuation")
`MPRnb( SIDP      , 2.0        , "-"                              , "Parameter for 1/f noise ")
`MPRnb( DLNOISE   , 0.0        , "m"                              , "Parameter for 1/f noise ")
`MPRoo( FALPH     , 1.0        , "s m^3"              ,   0 , inf , "Parameter for 1/f noise ")
`MPRnb( CIT       , 0.0        , "F m^-2"                         , "Capacitance caused by the interface trapped carriers")
`MPRoo( KAPPA     , 3.90       , "-"                  ,   0 , inf , "Dielectric constant for high-k stacked gate ")
`MPRco( CGSO      , 0.0        , "F/m"                ,   0 , inf , "Cgso ")
`MPRco( CGDO      , 0.0        , "F/m"                ,   0 , inf , "Cgso ")
`MPRoo( DLY1      , 100.0E-12  , "s"                  ,   0 , inf , "Parameter for transit time  ")
`MPRnb( DLY2      , 0.7        , "m^2"                            , "Parameter for transit time  ")
`MPRoo( DLY3      , 0.8E-6     , "Ohm m^2"            ,   0 , inf , "Parameter for transforming bulk charge  ")
`MPRco( TNOM      , 27.0       , "degC"           , -273.15 , inf , "Nominal temperature  ")
`MPRnb( OVSLP     , 2.1E-7     , "m/V"                            , "coefficient for overlap capacitance")
`MPRnb( OVMAG     , 0.6        , "V"                              , "coefficient for overlap capacitance")
`MPRcc( GBMIN     , 1.0E-12    , "-"                  ,   0 , 1E4 , "Substrate resistance network")
`MPRnb( IBPC1     , 0.0        , "V/A"                            , "Parameter for impact-ionization induced bulk potential change ")
`MPRnb( IBPC2     , 0.0        , "1/A"                            , "Parameter for impact-ionization induced bulk potential change ")
`MPRnb( PTL       , 0.0        , "V^(PTP-1)"                      , "Strength of punchthrough effect")
`MPRnb( PTP       , 3.5        , "-"                              , "Strength of punchthrough effect")
`MPRnb( PT2       , 0.0        , "V^-1"                           , "Vds dependence of punchthrough effect")
`MPRnb( PTLP      , 1.0        , "-"                              , "Channel-length dependence of punchthrough effect")
`MPRnb( GDL       , 0.0        , "-"                              , "Strength of high-field effect")
`MPRnb( GDLP      , 0.0        , "-"                              , "Channel-length dependence of high-field effect")
`MPRnb( GDLD      , 0.0        , "-"                              , "Channel-length dependence of high-field effect")
`MPRnb( PT4       , 0.0        , "V^-1"                           , "Vbs dependence of punchthrough effect")
`MPRnb( PT4P      , 1.0        , "-"                              , "Vbs dependence of punchthrough effect")
`MPRnb( MUEPHL2   , 0.0        , "-"                              , "Length dependence of phonon mobility reduction" )
`MPRnb( MUEPLP2   , 1.0        , "-"                              , "Length dependence of phonon mobility reduction" )
`MPRnb( NSUBCW2   , 0.0        , "-"                              , "Modification of substrate concentration for narrow width" )
`MPRnb( NSUBCWP2  , 1.0        , "-"                              , "Modification of substrate concentration for narrow width" )
`MPRnb( MUEPHW2   , 0.0        , "-"                              , "Phonon related mobility reduction" )
`MPRnb( MUEPWP2   , 1.0        , "-"                              , "Phonon related mobility reduction" )
`MPRnb( WEB       , 0.0        , "-"                              , "Modification of layout characterization factor" )
`MPRnb( WEC       , 0.0        , "-"                              , "Modification of layout characterization factor" )
`MPRnb( NSUBCWPE  , 0.0        , "1/cm^3"                         , "Channel concentration change due to WPE" )
`MPRnb( NPEXTWPE  , 0.0        , "1/cm^3"                         , "Pocket-tail concentration change due to WPE" )
`MPRnb( NSUBPWPE  , 0.0        , "1/cm^3"                         , "Pocket concentration change due to WPE" )
`MPRnb( VGSMIN   , -5.0 * TYPE , "V"                              , "Minimal/maximal expected Vgs(NMOS/PMOS)  ")
`MPRnb( SC3VBS    , 0.0        , "-"                              , "For diminishing of impurity gradient" )
`MPRnb( MUECB0LP  , 0.0        , "-"                              , "Length dependence of Coulomb scattering" )
`MPRnb( MUECB1LP  , 0.0        , "-"                              , "Length dependence of Coulomb scattering" )
`MPRcc( GMIN      , 0.0        , "-"                  ,   0 , 1E4 , "Minimum conductance")
`MPRoo( RMIN      , 1E-4       , "-"                  ,   0 , inf , "Minimum resistance for RS / RD")
`MPRoo( TOXOV     , TOX        , "m"                  ,   0 , inf , "Oxide thickness of overlap region")
`MPRoo( OVINVDLT  , 75.00      , "-"                  ,   0 , inf , "Analytical overlap inversion when COQOVSM=2")

`MPRco( NSUBD     , NSUBC      , "1/cm^3"             ,   0 , inf , "substrate conc for Vbs effects of dVth; 0.0 (deactivate this effects) ")
`MPRnb( VSFTD     , 0          , "V"                              , "shift Vth vs sqrt(2\phi-Vbs) line for substrate ")   
`MPRnb( SC2D   , 0.0        , "1/V"                            , "Vds-dependent SCE associated with NSUBD (vertDop)")
`MPRnb( WDEPV  , 10.0       , "V^1/2"                          , "Cross point of dVthVertdnw and dVthVertd lines (vertDop)")
`MPRnb( NSUBDNW , 0.0       , "1/cm^3"                         , "substrate conc for Vbs effects of dVth; narrow W effects (vertDop)")
`MPRnb( NSUBDW , 0.0        , "-"                              , "NSUBD W-dependence coeff. (vertDop)")
`MPRnb( NSUBDWP, 1          , "-"                              , "NSUBD W-dependence exponent (vertDop)")   
`MPRnb( NSUBDW0, NSUBD      , "1/cm^3"                         , "NSUBD W-dependence const term (vertDop)")
`ifdef _AGING_
/////////////// Parameter for Aging model ///////////////
`BPRco( DEGTIME0   , 0.0        , "s"                ,   0 , inf , "aging simulation time ")
`BPRco( DEGTIME    , 0.0        , "s"                ,   0 , inf , "degradation time ")
`BPRnb( TRAPN      , 0.4        , "-"                            , "Coeff. of Qtrap for Eeff  ")

/////////////// Parameter for HC model //////////////////
`BPRnb( TRAPGC0    , 1E35       , "cm^-3eV^-1"                   , "coefficient of deep trap ")
`BPRnb( TRAPES0    , 0.1        , "eV"                           , "coefficient of deep trap ")
`BPRnb( TRAPGC1    , 1E15       , "cm^-3eV^-1"                   , "coefficient of deep trap ")
`BPRnb( TRAPES1    , 0.3        , "eV"                           , "coefficient of deep trap ")
`BPRnb( TRAPGC2    , 500        , "cm^-3eV^-1"                   , "coefficient of shallow trap ")
`BPRnb( TRAPES2    , 0.001      , "eV"                           , "coefficient of shallow trap ")
`BPRnb( TRAPLX     , 0.5        , "V"                            , "Vds dependence of deep trap")
`BPRnb( TRAPGCLIM  , 1E18       , "cm^-3eV^-1"                   , "coefficient of deep trap ")
`BPRnb( TRAPESLIM  , 5          , "eV"                           , "coefficient of deep trap ")
`BPRnb( TRAPTAUCAP , 1e-6       , "s"                            , "Time constant of trap capture")
`BPRnb( TRAPGC1MAX , 5E19       , "cm^-3eV^-1"                   , "coefficient of deep trap ")
`BPRnb( TRAPES1MAX , 0.5        , "eV*ln(TRAPESTIME1*A/m)"       , "coefficient of deep trap ")
`BPRnb( TRAPGCTIME1 , 10        , "s"                            , "coefficient of deep trap ")
`BPRnb( TRAPGCTIME2 , 1E6       , "s"                            , "coefficient of deep trap ")
`BPRnb( TRAPESTIME1 , 10        , "s"                            , "coefficient of deep trap ")
`BPRnb( TRAPESTIME2 , 100       , "s"                            , "coefficient of deep trap ")
`BPRnb( TRAPTEMP1  , 0.0        , "1/K"                          , "temperature dependence of trap")
`BPRnb( TRAPTEMP2  , 0.0        , "1/K^2"                        , "temperature dependence of trap")
/////////////// Parameter for BTI model ///////////////
`BPRnb( TRAPDVTH   , 0.0        , "V"                            , "Vfb shift dut to interface trap density")
`MPRnb( TRAPA      , 0.0        , "V"                            , "coefficient of existing interface trap density")
`MPRnb( TRAPB      , 4E-9       , "m/V"                          , "coefficient of existing interface trap density")
`BPRnb( TRAPBTI    , 1e7        , "s"                            , "coefficient for duration time dependence")
`endif

/* Parameter for depletion device */
`MPRcc( DEPRBR        , 1          , "-"              ,   0 ,   1 , "parameter for resistance effect along substrate (for minority carrier)") //CODEP=3
`MPRoo( NDEPM         , 1E17       , "cm^-3"              ,   0 , inf , "impurity concentration of the surface N^- layer")
`MPRnb( NDEPML        , 0.0        , "-"                          , "Lgate dependence of impurity concentration of the surface N^- layer" )
`MPRnb( NDEPMLP       , 1.0        , "-"                          , "Lgate dependence of impurity concentration of the surface N^- layer" )
`MPRoo( TNDEP         , 0.2E-6     , "m"              ,   0 , inf , "Thickness of the surface N^- layer")
`MPRoo( TNDEPMIN  , (TNDEP*1e-6) , "m"     , (TNDEP*1e-9) , TNDEP , "minumum thickness of the surface layer (CODEP=3)")
`MPRnb( DEPNINVD      , NINVD      , "1/V"                        , "NINVD for Mu_res  depmos3") // 3.0.0 compatible
`MPRnb( DEPNINVDC ,   0        , "1/V"                           , "Modification of Vdse dependence on Eeff (for Mu_res) (CODEP=3)") // 3.0.1 or later 
`MPRnb( DEPNINVDH ,   0        , "1/V"                           , "Modification of Vdse dependence on Eeff (for Mu_res) (CODEP=3)") // 3.0.1 or later
`MPRnb( DEPNINVDL  , 0.0       , "-"                             , "Coeff of modification of Vdse dependence on Eeff; Mu_res (CODEP=3)")
`MPRnb( DEPNINVDLP , 1.0       , "-"                             , "Coeff of modification of Vdse dependence on Eeff; Mu_res (CODEP=3)")
`MPRnb( DEPNINVDW  , 0.0       , "-"                             , "Coeff of modification of Vdse dependence on Eeff; Mu_res (CODEP=3)")
`MPRnb( DEPNINVDWP , 1.0       , "-"                             , "Coeff of modification of Vdse dependence on Eeff; Mu_res (CODEP=3)")
`MPRnb( DEPMUE0       , 1E3        , "cm^2V^-1s^-1"               , "Coulomb scattering in the resistor region")
`MPRnb( DEPMUE0L      , 0.0        , "-"                          , "Lgate dependence of the Coulomb scattering in the resistor region" )
`MPRnb( DEPMUE0LP     , 1.0        , "-"                          , "Lgate dependence of the Coulomb scattering in the resistor region" )
`MPRnb( DEPMUEBACK0   , 100        , "cm^2V^-1s^-1"               , "Coulomb scattering in the back region") //CODEP=1
`MPRnb( DEPMUEBACK0L  , 0.0        , "-"                          , "Lgate dependence of the Coulomb scattering in the back region" ) //CODEP=1
`MPRnb( DEPMUEBACK0LP , 1.0        , "-"                          , "Lgate dependence of the Coulomb scattering in the back region" ) //CODEP=1
`MPRnb( DEPMUEBACK1   , 0.0        , "-"                          , "Coulomb scattering in the back region") //CODEP=1
`MPRnb( DEPMUEBACK1L  , 0.0        , "-"                          , "Lgate dependence of the Phonon scattering in the back region" ) //CODEP=1
`MPRnb( DEPMUEBACK1LP , 1.0        , "-"                          , "Lgate dependence of the Phonon scattering in the back region" ) //CODEP=1
`MPRnb( DEPMUEPH0     , 0.3        , "-"                          , "Phonon scattering in the resistor region") //CODEP=1,3
`MPRoo( DEPMUEPH1     , 5E3        , "cm^2V^-1s^-1"  ,   0 , inf , "Phonon scattering in the resistor region") //CODEP=1,3
`MPRoo( DEPVMAX       , 3E7        , "cm/s"          ,   0 , inf , "Saturation velocity in the resistor region")
`MPRnb( DEPVMAXL      , 0.0        , "-"                          , "Lgate dependence of the saturation velocity in the resistor region" )
`MPRnb( DEPVMAXLP     , 1.0        , "-"                          , "Lgate dependence of the saturation velocity in the resistor region" )
`MPRnb( DEPLEAK       , 0.0        , "V"                          , "leakage current coefficient") //CODEP=1,2
`MPRnb( DEPLEAKL      , 0.0        , "-"                          , "Lgate dependence of leakage current coefficient" )
`MPRnb( DEPLEAKLP     , 1.0        , "-"                          , "Lgate dependence of leakage current coefficient" )
`MPRnb( DEPETA        , 0.0        , "1/V"                        , "Vds dependence of the threshold voltage shift") //CODEP=1
`MPRnb( DEPMUE1       , 0.0        , "cm^2V^-1s^-1"               , "Coulomb scattering in the resistor region") //CODEP=1,3
`MPRnb( DEPMUE1L      , 0.0        , "-"                          , "Lgate dependence of the Phonon scattering in the resistor region" )
`MPRnb( DEPMUE1LP     , 1.0        , "-"                          , "Lgate dependence of the Phonon scattering in the resistor region" )
`MPRoo( DEPMUE2       , 1E3        , "cm^2V^-1s^-1"   ,   0 , inf , "Coulomb scattering of the resistor part") //CODEP=2
`MPRco( DEPBB         , 1.0        , "-"              , 0.03 , inf, "High-field-mobility degradation in the resistor region")
`MPRnb( DEPVDSEF1     , 2.0        , "V"                          , "Effective drain potential coefficient-1 in the resistor region") //CODEP=1
`MPRnb( DEPVDSEF1L    , 0.0        , "-"                          , "Lgate dependence of the effective drain potential coefficient-1" ) //CODEP=1
`MPRnb( DEPVDSEF1LP   , 1.0        , "-"                          , "Lgate dependence of the effective drain potential coefficient-1" ) //CODEP=1
`MPRnb( DEPVDSEF2     , 0.5        , "-"                          , "Effective drain potential coefficient-2 in the resistor region") //CODEP=1
`MPRnb( DEPVDSEF2L    , 0.0        , "-"                          , "Lgate dependence of the effective drain potential coefficient-2" ) //CODEP=1
`MPRnb( DEPVDSEF2LP   , 1.0        , "-"                          , "Lgate dependence of the effective drain potential coefficient-2" ) //CODEP=1
`MPRcc( DEPDDLT       , 3.0        , "-"              , 0.5 ,  32 , "Smoothing coefficient for Vds,res")
`MPRnb( DEPMUETMP     , 1.5        , "-"                          , "Temperature dependence of the phonon scattering in the resistor region")//CODEP=1,3
`MPRnb( DEPMUE0TMP    , 0.0        , "-"                          , "Temperature dependence of DEPmue0")
`MPRnb( DEPMUE2TMP    , 0.0        , "-"                          , "Temperature dependence of DEPmue2")//CODEP=2
`MPRnb( DEPVTMP       , 0.0        , "-"                          , "Temperature dependence of DEPVMAX")
`MPRnb( TNDEPV        , 0.0        , "1/V"                          , "Vds dependence of TNDEP  CODEP=2")
`MPRnb( TNDEPVB       , 0.0        , "-"                          , "Vbs dependence of TNDEPV CODEP=2")
`MPRnb( DEPMUEA1      , 0.0        , "-"                          , "Modification of mures CODEP=1,2")
`MPRnb( DEPVFBC       , VFBC       , "V"                          , "Flat-band voltage of the resistor part CODEP=2")
`MPRnb( DEPDVFBC  , 0.1        , "V"                             , "delta of Flat-band voltage of the resistor part (CODEP=3)") //CODEP = 3
`MPRco( DEPSUBSL  , 2.0        , "-"                , 1e-8 , inf , "Factor of the sub-threshold slope (CODEP=2,3)")             //CODEP = 2, 3
`MPRco( DEPSUBSL0 , DEPSUBSL   , "-"                , 1e-8 , inf , "Factor of the sub-threshold slope (CODEP=2,3)")             //CODEP = 3   
`MPRco( DEPVGPSL  , ((CODEP < 3) ? 0.0:0.2) , "V"  ,     0 , inf , "Smoothing coefficient for gm (CODEP=2,3)")        //CODEP = 2, 3   
`MPRnb( DEPVSATA  , 0.0        , "V", " Vdssat shift depmos3") // 20171004
`MPRnb( DEPVSATR      , 0.0        , "-"                          , "Vbs dependence of subVds,sat of the resistor part CODEP=2,3")
`MPRnb( DEPCAR        , 0.0        , "m/V"                          , "coefficient for Ndrift,res CODEP=3")
`MPRnb( DEPRDRDL1     , 0.0        , "m"                         , "RDRDL1 for resistor layer CODEP=3")
`MPRnb( DEPRDRDL2     , 0.0        , "m"                         , "Pinch-off length in resistor layer CODEP=3")   
`MPRnb( DEPPS     , 0.01       , "V"                             , "Ps_delta for smoothing charge (CODEP=3)")         //CODEP = 3
`MPRcc( DEPQF     , 0.01       , "V"                , 1e-8 ,   8 , "smoothing param for Vdseff (CODEP=3)")            //CODEP = 3
`MPRcc( DEPFDPD   , 0.2        , "V"                , 1e-8 ,   4 , "smoothing param for FD/PD transition (CODEP=3)")  //CODEP = 3
`MPRcc( DEPPB0    ,0.5         , "V"                ,0     , 0.5 , "Flooring for Eeff for Mu_res depmos3") // 3.0.0 compatible



`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
`MPRnb( JS0D      , JS0        , "A/m^2"                         , "Saturation current density for drain junction  ")
`MPRnb( JS0SWD    , JS0SW      , "A/m"                           , "Side wall saturation current density for drain junction  ")
`MPRnb( JS0SWGD   , JS0SWG     , "A/m"                           , "Gate side wall saturation current density for drain junction  ")
`MPRoo( NJD       , NJ         , "-"                 ,   0 , inf , "Emission coefficient for drain junction  ")
`MPRoo( NJSWD     , NJSW       , "-"                 ,   0 , inf , "Sidewall emission coefficient for drain junction  ")
`MPRoo( NJSWGD    , NJSWG      , "-"                 ,   0 , inf , "Gate sidewall emission coefficient for drain junction  ")
`MPRnb( XTID      , XTI        , "-"                             , "Junction current temperature exponent coefficient for drain junction  ")
`MPRnb( CJD       , CJ         , "F/m^2"                         , "Bottom junction capacitance per unit area at zero bias for drain junction  ")
`MPRnb( CJSWD     , CJSW       , "F/m"                           , "Sidewall junction capacitance grading coefficient per unit length at zero bias for drain junction  ")
`MPRnb( CJSWGD    , CJSWG      , "F/m"                           , "Gate sidewall junction capacitance per unit length at zero bias for drain junction  ")
`MPRoo( MJD       , MJ         , "-"                , -inf ,   1 , "Bottom junction capacitance grading coefficient for drain junction  ")
`MPRoo( MJSWD     , MJSW       , "-"                , -inf ,   1 , "Sidewall junction capacitance grading coefficient for drain junction  ")
`MPRoo( MJSWGD    , MJSWG      , "-"                , -inf ,   1 , "Gate sidewall junction capacitance grading coefficient for drain junction  ")
`MPRoo( PBD       , PB         , "V"                ,   0  , inf , "Bottom junction build-in potential  for drain junction   ")
`MPRoo( PBSWD     , PBSW       , "V"                ,   0  , inf , "Sidewall junction build-in potential for drain junction  ")
`MPRoo( PBSWGD    , PBSWG      , "V"                ,   0  , inf , "Gate sidewall junction build-in potential for drain junction  ")
`MPRnb( XTI2D     , XTI2       , "-"                             , "Temperature coefficient for drain junction  ")
`MPRnb( CISBD     , CISB       , "-"                             , "Reverse bias saturation current for drain junction  ")
`MPRnb( CVBD      , CVB        , "-"                             , "Bias dependence coefficient of cisb for drain junction   ")
`MPRnb( CTEMPD    , CTEMP      , "-"                             , "Temperature coefficient for drain junction  ")
`MPRnb( CISBKD    , CISBK      , "A"                             , "Reverse bias saturation current for drain junction  ")
`MPRnb( DIVXD     , DIVX       , "1/V"                           , "Reverse coefficient coefficient for drain junction  ")
`MPRnb( VDIFFJD   , VDIFFJ     , "V"                             , "Threshold voltage for junction diode for drain junction  ")

`MPRnb( JS0S      , JS0D       , "A/m^2"                         , "Saturation current density for source junction  ")
`MPRnb( JS0SWS    , JS0SWD     , "A/m"                           , "Side wall saturation current density for source junction  ")
`MPRnb( JS0SWGS   , JS0SWGD    , "A/m"                           , "Gate side wall saturation current density for source junction  ")
`MPRoo( NJS       , NJD        , "-"                 ,   0 , inf , "Emission coefficient for source junction  ")
`MPRoo( NJSWS     , NJSWD      , "-"                  ,   0 , inf , "Sidewall emission coefficient for source junction  ")
`MPRoo( NJSWGS    , NJSWGD     , "-"                  ,   0 , inf , "Gate sidewall emission coefficient for source junction  ")
`MPRnb( XTIS      , XTID       , "-"                             , "Junction current temperature exponent coefficient for source junction  ")
`MPRnb( CJS       , CJD        , "F/m^2"                         , "Bottom junction capacitance per unit area at zero bias for source junction  ")
`MPRnb( CJSWS     , CJSWD      , "F/m"                           , "Sidewall junction capacitance grading coefficient per unit length at zero bias for source junction  ")
`MPRnb( CJSWGS    , CJSWGD     , "F/m"                           , "Gate sidewall junction capacitance per unit length at zero bias for source junction  ")
`MPRoo( MJS       , MJD        , "-"                 , -inf ,   1 , "Bottom junction capacitance grading coefficient for source junction  ")
`MPRoo( MJSWS     , MJSWD      , "-"                 , -inf ,   1 , "Sidewall junction capacitance grading coefficient for source junction  ")
`MPRoo( MJSWGS    , MJSWGD     , "-"                 , -inf ,   1 , "Gate sidewall junction capacitance grading coefficient for source junction  ")
`MPRoo( PBS       , PBD        , "V"                 ,   0 , inf , "Bottom junction build-in potential  for source junction   ")
`MPRoo( PBSWS     , PBSWD      , "V"                 ,   0 , inf , "Sidewall junction build-in potential for source junction  ")
`MPRoo( PBSWGS    , PBSWGD     , "V"                 ,   0 , inf , "Gate sidewall junction build-in potential for source junction  ")
`MPRnb( XTI2S     , XTI2D      , "-"                             , "Temperature coefficient for source junction  ")
`MPRnb( CISBS     , CISBD      , "-"                             , "Reverse bias saturation current for source junction  ")
`MPRnb( CVBS      , CVBD       , "-"                             , "Bias dependence coefficient of cisb for source junction   ")
`MPRnb( CTEMPS    , CTEMPD     , "-"                             , "Temperature coefficient for source junction  ")
`MPRnb( CISBKS    , CISBKD     , "A"                             , "Reverse bias saturation current for source junction  ")
`MPRnb( DIVXS     , DIVXD      , "1/V"                           , "Reverse coefficient coefficient for source junction  ")
`MPRnb( VDIFFJS   , VDIFFJD    , "V"                             , "Threshold voltage for junction diode for source junction  ")


`endif /* End of COEXTDIO */

   
//*** Binning Parameters ***
`MPRnb( LMIN       , 0.0        , "m"                             , "Minimum length for the model ")
`MPRnb( LMAX       , 1.0        , "m"                             , "Maximum length for the model ")
`MPRnb( WMIN       , 0.0        , "m"                             , "Minimum width for the model ")
`MPRnb( WMAX       , 1.0        , "m"                             , "Maximum width for the model ")
`MPRnb( LBINN      , 1.0        , "-"                             , "L modulation coefficient for binning ")
`MPRnb( WBINN      , 1.0        , "-"                             , "W modulation coefficient for binning ")
`MPRnb( LVMAX      , 0.0        , "-"                             , "Length dependence of vmax ")
`MPRnb( LBGTMP1    , 0.0        , "-"                             , "Length dependence of bgtmp1 ")
`MPRnb( LBGTMP2    , 0.0        , "-"                             , "Length dependence of bgtmp2 ")
`MPRnb( LEG0       , 0.0        , "-"                             , "Length dependence of eg0 ")
`MPRnb( LLOVER     , 0.0        , "-"                             , "Length dependence of lover" )
`MPRnb( LVFBOVER   , 0.0        , "-"                             , "Length dependence of vfbover ")
`MPRnb( LNOVER     , 0.0        , "-"                             , "Length dependence of nover ")
`MPRnb( LWL2       , 0.0        , "-"                             , "Length dependence of wl2 ")
`MPRnb( LVFBC      , 0.0        , "-"                             , "Length dependence of vfbc ")
`MPRnb( LNSUBC     , 0.0        , "-"                             , "Length dependence of nsubc ")
`MPRnb( LNSUBP     , 0.0        , "-"                             , "Length dependence of nsubp ")
`MPRnb( LSCP1      , 0.0        , "-"                             , "Length dependence of scp1 ")
`MPRnb( LSCP2      , 0.0        , "-"                             , "Length dependence of scp2 ")
`MPRnb( LSCP3      , 0.0        , "-"                             , "Length dependence of scp3 ")
`MPRnb( LSC1       , 0.0        , "-"                             , "Length dependence of sc1 ")
`MPRnb( LSC2       , 0.0        , "-"                             , "Length dependence of sc2 ")
`MPRnb( LSC3       , 0.0        , "-"                             , "Length dependence of sc3 ")
`MPRnb( LSC4       , 0.0        , "-"                             , "Length dependence of sc4 " )
`MPRnb( LPGD1      , 0.0        , "-"                             , "Length dependence of pgd1 ")
`MPRnb( LNDEP      , 0.0        , "-"                             , "Length dependence of ndep ")
`MPRnb( LNINV      , 0.0        , "-"                             , "Length dependence of ninv ")
`MPRnb( LMUECB0    , 0.0        , "-"                             , "Length dependence of muecb0 ")
`MPRnb( LMUECB1    , 0.0        , "-"                             , "Length dependence of muecb1 ")
`MPRnb( LMUEPH1    , 0.0        , "-"                             , "Length dependence of mueph1 ")
`MPRnb( LVTMP      , 0.0        , "-"                             , "Length dependence of vtmp ")
`MPRnb( LWVTH0     , 0.0        , "-"                             , "Length dependence of wvth0 ")
`MPRnb( LMUESR1    , 0.0        , "-"                             , "Length dependence of muesr1 ")
`MPRnb( LMUETMP    , 0.0        , "-"                             , "Length dependence of muetmp ")
`MPRnb( LSUB1      , 0.0        , "-"                             , "Length dependence of sub1 ")
`MPRnb( LSUB2      , 0.0        , "-"                             , "Length dependence of sub2 ")
`MPRnb( LSVDS      , 0.0        , "-"                             , "Length dependence of svds ")
`MPRnb( LSVBS      , 0.0        , "-"                             , "Length dependence of svbs ")
`MPRnb( LSVGS      , 0.0        , "-"                             , "Length dependence of svgs ")
`MPRnb( LNSTI      , 0.0        , "-"                             , "Length dependence of nsti ")
`MPRnb( LWSTI      , 0.0        , "-"                             , "Length dependence of wsti ")
`MPRnb( LSCSTI1    , 0.0        , "-"                             , "Length dependence of scsti1 ")
`MPRnb( LSCSTI2    , 0.0        , "-"                             , "Length dependence of scsti2 ")
`MPRnb( LVTHSTI    , 0.0        , "-"                             , "Length dependence of vthsti ")
`MPRnb( LMUESTI1   , 0.0        , "-"                             , "Length dependence of muesti1 ")
`MPRnb( LMUESTI2   , 0.0        , "-"                             , "Length dependence of muesti2 ")
`MPRnb( LMUESTI3   , 0.0        , "-"                             , "Length dependence of muesti3 ")
`MPRnb( LNSUBPSTI1 , 0.0        , "-"                             , "Length dependence of nsubpsti1 ")
`MPRnb( LNSUBPSTI2 , 0.0        , "-"                             , "Length dependence of nsubpsti2 ")
`MPRnb( LNSUBPSTI3 , 0.0        , "-"                             , "Length dependence of nsubpsti3 ")
`MPRnb( LNSUBCSTI1 , 0.0        , "-"                             , "Length dependence of nsubcst1 ")
`MPRnb( LNSUBCSTI2 , 0.0        , "-"                             , "Length dependence of nsubcst2 ")
`MPRnb( LNSUBCSTI3 , 0.0        , "-"                             , "Length dependence of nsubcst2 ")
`MPRnb( LCGSO      , 0.0        , "-"                             , "Length dependence of cgso ")
`MPRnb( LCGDO      , 0.0        , "-"                             , "Length dependence of cgdo ")
`MPRnb( LCLM1      , 0.0        , "-"                             , "Length dependence of clm1 ")
`MPRnb( LCLM2      , 0.0        , "-"                             , "Length dependence of clm2 ")
`MPRnb( LCLM3      , 0.0        , "-"                             , "Length dependence of clm3 ")
`MPRnb( LWFC       , 0.0        , "-"                             , "Length dependence of wfc ")
`MPRnb( LGIDL1     , 0.0        , "-"                             , "Length dependence of gidl1 ")
`MPRnb( LGIDL2     , 0.0        , "-"                             , "Length dependence of gidl2 ")
`MPRnb( LGLEAK1    , 0.0        , "-"                             , "Length dependence of gleak1 ")
`MPRnb( LGLEAK2    , 0.0        , "-"                             , "Length dependence of gleak2 ")
`MPRnb( LGLEAK3    , 0.0        , "-"                             , "Length dependence of gleak3 ")
`MPRnb( LGLEAK6    , 0.0        , "-"                             , "Length dependence of gleak6 ")
`MPRnb( LGLKSD1    , 0.0        , "-"                             , "Length dependence of glksd1 ")
`MPRnb( LGLKSD2    , 0.0        , "-"                             , "Length dependence of glksd2 ")
`MPRnb( LGLKB1     , 0.0        , "-"                             , "Length dependence of glkb1 ")
`MPRnb( LGLKB2     , 0.0        , "-"                             , "Length dependence of glkb2 ")
`MPRnb( LNFTRP     , 0.0        , "-"                             , "Length dependence of nftrp ")
`MPRnb( LNFALP     , 0.0        , "-"                             , "Length dependence of nfalp ")
`MPRnb( LIBPC1     , 0.0        , "-"                             , "Length dependence of ibpc1 ")
`MPRnb( LIBPC2     , 0.0        , "-"                             , "Length dependence of ibpc2 ")
`MPRnb( WVMAX      , 0.0        , "-"                             , "Width dependence of vmax ")
`MPRnb( WBGTMP1    , 0.0        , "-"                             , "Width dependence of bgtmp1 ")
`MPRnb( WBGTMP2    , 0.0        , "-"                             , "Width dependence of bgtmp2 ")
`MPRnb( WEG0       , 0.0        , "-"                             , "Width dependence of eg0 ")
`MPRnb( WLOVER     , 0.0        , "-"                             , "Width dependence of lover " )
`MPRnb( WVFBOVER   , 0.0        , "-"                             , "Width dependence of vfbover ")
`MPRnb( WNOVER     , 0.0        , "-"                             , "Width dependence of nover ")
`MPRnb( WWL2       , 0.0        , "-"                             , "Width dependence of wl2 ")
`MPRnb( WVFBC      , 0.0        , "-"                             , "Width dependence of vfbc ")
`MPRnb( WNSUBC     , 0.0        , "-"                             , "Width dependence of nsubc ")
`MPRnb( WNSUBP     , 0.0        , "-"                             , "Width dependence of nsubp ")
`MPRnb( WSCP1      , 0.0        , "-"                             , "Width dependence of scp1 ")
`MPRnb( WSCP2      , 0.0        , "-"                             , "Width dependence of scp2 ")
`MPRnb( WSCP3      , 0.0        , "-"                             , "Width dependence of scp3 ")
`MPRnb( WSC1       , 0.0        , "-"                             , "Width dependence of sc1 ")
`MPRnb( WSC2       , 0.0        , "-"                             , "Width dependence of sc2 ")
`MPRnb( WSC3       , 0.0        , "-"                             , "Width dependence of sc3 ")
`MPRnb( WSC4       , 0.0        , "-"                             , "Width dependence of sc4 " )
`MPRnb( WPGD1      , 0.0        , "-"                             , "Width dependence of pgd1 ")
`MPRnb( WNDEP      , 0.0        , "-"                             , "Width dependence of ndep ")
`MPRnb( WNINV      , 0.0        , "-"                             , "Width dependence of ninv ")
`MPRnb( WMUECB0    , 0.0        , "-"                             , "Width dependence of muecb0 ")
`MPRnb( WMUECB1    , 0.0        , "-"                             , "Width dependence of muecb1 ")
`MPRnb( WMUEPH1    , 0.0        , "-"                             , "Width dependence of mueph1 ")
`MPRnb( WVTMP      , 0.0        , "-"                             , "Width dependence of vtmp ")
`MPRnb( WWVTH0     , 0.0        , "-"                             , "Width dependence of wvth0 ")
`MPRnb( WMUESR1    , 0.0        , "-"                             , "Width dependence of muesr1 ")
`MPRnb( WMUETMP    , 0.0        , "-"                             , "Width dependence of muetmp ")
`MPRnb( WSUB1      , 0.0        , "-"                             , "Width dependence of sub1 ")
`MPRnb( WSUB2      , 0.0        , "-"                             , "Width dependence of sub2 ")
`MPRnb( WSVDS      , 0.0        , "-"                             , "Width dependence of svds ")
`MPRnb( WSVBS      , 0.0        , "-"                             , "Width dependence of svbs ")
`MPRnb( WSVGS      , 0.0        , "-"                             , "Width dependence of svgs ")
`MPRnb( WNSTI      , 0.0        , "-"                             , "Width dependence of nsti ")
`MPRnb( WWSTI      , 0.0        , "-"                             , "Width dependence of wsti ")
`MPRnb( WSCSTI1    , 0.0        , "-"                             , "Width dependence of scsti1 ")
`MPRnb( WSCSTI2    , 0.0        , "-"                             , "Width dependence of scsti2 ")
`MPRnb( WVTHSTI    , 0.0        , "-"                             , "Width dependence of vthsti ")
`MPRnb( WMUESTI1   , 0.0        , "-"                             , "Width dependence of muesti1 ")
`MPRnb( WMUESTI2   , 0.0        , "-"                             , "Width dependence of muesti2 ")
`MPRnb( WMUESTI3   , 0.0        , "-"                             , "Width dependence of muesti3 ")
`MPRnb( WNSUBPSTI1 , 0.0        , "-"                             , "Width dependence of nsubpsti1 ")
`MPRnb( WNSUBPSTI2 , 0.0        , "-"                             , "Width dependence of nsubpsti2 ")
`MPRnb( WNSUBPSTI3 , 0.0        , "-"                             , "Width dependence of nsubpsti3 ")
`MPRnb( WNSUBCSTI1 , 0.0        , "-"                             , "Width dependence of nsubcsti1 ")
`MPRnb( WNSUBCSTI2 , 0.0        , "-"                             , "Width dependence of nsubcsti2 ")
`MPRnb( WNSUBCSTI3 , 0.0        , "-"                             , "Width dependence of nsubcsti3 ")
`MPRnb( WCGSO      , 0.0        , "-"                             , "Width dependence of cgso ")
`MPRnb( WCGDO      , 0.0        , "-"                             , "Width dependence of cgdo ")
`MPRnb( WCLM1      , 0.0        , "-"                             , "Width dependence of clm1 ")
`MPRnb( WCLM2      , 0.0        , "-"                             , "Width dependence of clm2 ")
`MPRnb( WCLM3      , 0.0        , "-"                             , "Width dependence of clm3 ")
`MPRnb( WWFC       , 0.0        , "-"                             , "Width dependence of wfc ")
`MPRnb( WGIDL1     , 0.0        , "-"                             , "Width dependence of gidl1 ")
`MPRnb( WGIDL2     , 0.0        , "-"                             , "Width dependence of gidl2 ")
`MPRnb( WGLEAK1    , 0.0        , "-"                             , "Width dependence of gleak1 ")
`MPRnb( WGLEAK2    , 0.0        , "-"                             , "Width dependence of gleak2 ")
`MPRnb( WGLEAK3    , 0.0        , "-"                             , "Width dependence of gleak3 ")
`MPRnb( WGLEAK6    , 0.0        , "-"                             , "Width dependence of gleak6 ")
`MPRnb( WGLKSD1    , 0.0        , "-"                             , "Width dependence of glksd1 ")
`MPRnb( WGLKSD2    , 0.0        , "-"                             , "Width dependence of glksd2 ")
`MPRnb( WGLKB1     , 0.0        , "-"                             , "Width dependence of glkb1 ")
`MPRnb( WGLKB2     , 0.0        , "-"                             , "Width dependence of glkb2 ")
`MPRnb( WNFTRP     , 0.0        , "-"                             , "Width dependence of nftrp ")
`MPRnb( WNFALP     , 0.0        , "-"                             , "Width dependence of nfalp ")
`MPRnb( WIBPC1     , 0.0        , "-"                             , "Width dependence of ibpc1 ")
`MPRnb( WIBPC2     , 0.0        , "-"                             , "Width dependence of ibpc2 ")
`MPRnb( PVMAX      , 0.0        , "-"                             , "Cross-term dependence of vmax ")
`MPRnb( PBGTMP1    , 0.0        , "-"                             , "Cross-term dependence of bgtmp1 ")
`MPRnb( PBGTMP2    , 0.0        , "-"                             , "Cross-term dependence of bgtmp2 ")
`MPRnb( PEG0       , 0.0        , "-"                             , "Cross-term dependence of eg0 ")
`MPRnb( PLOVER     , 0.0        , "-"                             , "Cross-term dependence of lover " )
`MPRnb( PVFBOVER   , 0.0        , "-"                             , "Cross-term dependence of vfbover ")
`MPRnb( PNOVER     , 0.0        , "-"                             , "Cross-term dependence of nover ")
`MPRnb( PWL2       , 0.0        , "-"                             , "Cross-term dependence of wl2 ")
`MPRnb( PVFBC      , 0.0        , "-"                             , "Cross-term dependence of vfbc ")
`MPRnb( PNSUBC     , 0.0        , "-"                             , "Cross-term dependence of nsubc ")
`MPRnb( PNSUBP     , 0.0        , "-"                             , "Cross-term dependence of nsubp ")
`MPRnb( PSCP1      , 0.0        , "-"                             , "Cross-term dependence of scp1 ")
`MPRnb( PSCP2      , 0.0        , "-"                             , "Cross-term dependence of scp2 ")
`MPRnb( PSCP3      , 0.0        , "-"                             , "Cross-term dependence of scp3 ")
`MPRnb( PSC1       , 0.0        , "-"                             , "Cross-term dependence of sc1 ")
`MPRnb( PSC2       , 0.0        , "-"                             , "Cross-term dependence of sc2 ")
`MPRnb( PSC3       , 0.0        , "-"                             , "Cross-term dependence of sc3 ")
`MPRnb( PSC4       , 0.0        , "-"                             , "Cross-term dependence of sc4 " )
`MPRnb( PPGD1      , 0.0        , "-"                             , "Cross-term dependence of pgd1 ")
`MPRnb( PNDEP      , 0.0        , "-"                             , "Cross-term dependence of ndep ")
`MPRnb( PNINV      , 0.0        , "-"                             , "Cross-term dependence of ninv ")
`MPRnb( PMUECB0    , 0.0        , "-"                             , "Cross-term dependence of muecb0 ")
`MPRnb( PMUECB1    , 0.0        , "-"                             , "Cross-term dependence of muecb1 ")
`MPRnb( PMUEPH1    , 0.0        , "-"                             , "Cross-term dependence of mueph1 ")
`MPRnb( PVTMP      , 0.0        , "-"                             , "Cross-term dependence of vtmp ")
`MPRnb( PWVTH0     , 0.0        , "-"                             , "Cross-term dependence of wvth0 ")
`MPRnb( PMUESR1    , 0.0        , "-"                             , "Cross-term dependence of muesr1 ")
`MPRnb( PMUETMP    , 0.0        , "-"                             , "Cross-term dependence of muetmp ")
`MPRnb( PSUB1      , 0.0        , "-"                             , "Cross-term dependence of sub1 ")
`MPRnb( PSUB2      , 0.0        , "-"                             , "Cross-term dependence of sub2 ")
`MPRnb( PSVDS      , 0.0        , "-"                             , "Cross-term dependence of svds ")
`MPRnb( PSVBS      , 0.0        , "-"                             , "Cross-term dependence of svbs ")
`MPRnb( PSVGS      , 0.0        , "-"                             , "Cross-term dependence of svgs ")
`MPRnb( PNSTI      , 0.0        , "-"                             , "Cross-term dependence of nsti ")
`MPRnb( PWSTI      , 0.0        , "-"                             , "Cross-term dependence of wsti ")
`MPRnb( PSCSTI1    , 0.0        , "-"                             , "Cross-term dependence of scsti1 ")
`MPRnb( PSCSTI2    , 0.0        , "-"                             , "Cross-term dependence of scsti2 ")
`MPRnb( PVTHSTI    , 0.0        , "-"                             , "Cross-term dependence of vthsti ")
`MPRnb( PMUESTI1   , 0.0        , "-"                             , "Cross-term dependence of muesti1 ")
`MPRnb( PMUESTI2   , 0.0        , "-"                             , "Cross-term dependence of muesti2 ")
`MPRnb( PMUESTI3   , 0.0        , "-"                             , "Cross-term dependence of muesti3 ")
`MPRnb( PNSUBPSTI1 , 0.0        , "-"                             , "Cross-term dependence of nsubpsti1 ")
`MPRnb( PNSUBPSTI2 , 0.0        , "-"                             , "Cross-term dependence of nsubpsti2 ")
`MPRnb( PNSUBPSTI3 , 0.0        , "-"                             , "Cross-term dependence of nsubpsti3 ")
`MPRnb( PNSUBCSTI1 , 0.0        , "-"                             , "Cross-term dependence of nsubcsti1 " )
`MPRnb( PNSUBCSTI2 , 0.0        , "-"                             , "Cross-term dependence of nsubcsti2 " )
`MPRnb( PNSUBCSTI3 , 0.0        , "-"                             , "Cross-term dependence of nsubcsti3 " )
`MPRnb( PCGSO      , 0.0        , "-"                             , "Cross-term dependence of cgso ")
`MPRnb( PCGDO      , 0.0        , "-"                             , "Cross-term dependence of cgdo ")
`MPRnb( PCLM1      , 0.0        , "-"                             , "Cross-term dependence of clm1 ")
`MPRnb( PCLM2      , 0.0        , "-"                             , "Cross-term dependence of clm2 ")
`MPRnb( PCLM3      , 0.0        , "-"                             , "Cross-term dependence of clm3 ")
`MPRnb( PWFC       , 0.0        , "-"                             , "Cross-term dependence of wfc ")
`MPRnb( PGIDL1     , 0.0        , "-"                             , "Cross-term dependence of gidl1 ")
`MPRnb( PGIDL2     , 0.0        , "-"                             , "Cross-term dependence of gidl2 ")
`MPRnb( PGLEAK1    , 0.0        , "-"                             , "Cross-term dependence of gleak1 ")
`MPRnb( PGLEAK2    , 0.0        , "-"                             , "Cross-term dependence of gleak2 ")
`MPRnb( PGLEAK3    , 0.0        , "-"                             , "Cross-term dependence of gleak3 ")
`MPRnb( PGLEAK6    , 0.0        , "-"                             , "Cross-term dependence of gleak6 ")
`MPRnb( PGLKSD1    , 0.0        , "-"                             , "Cross-term dependence of glksd1 ")
`MPRnb( PGLKSD2    , 0.0        , "-"                             , "Cross-term dependence of glksd2 ")
`MPRnb( PGLKB1     , 0.0        , "-"                             , "Cross-term dependence of glkb1 ")
`MPRnb( PGLKB2     , 0.0        , "-"                             , "Cross-term dependence of glkb2 ")
`MPRnb( PNFTRP     , 0.0        , "-"                             , "Cross-term dependence of nftrp ")
`MPRnb( PNFALP     , 0.0        , "-"                             , "Cross-term dependence of nfalp ")
`MPRnb( PIBPC1     , 0.0        , "-"                             , "Cross-term dependence of ibpc1 ")
`MPRnb( PIBPC2     , 0.0        , "-"                             , "Cross-term dependence of ibpc2 ")

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
`MPRnb( LJS0      , 0.0        , "-"                             , "Length dependence of js0 ")
`MPRnb( LJS0SW    , 0.0        , "-"                             , "Length dependence of js0sw ")
`MPRnb( LNJ       , 0.0        , "-"                             , "Length dependence of nj ")
`MPRnb( LCISBK    , 0.0        , "-"                             , "Length dependence of cisbk ")
`MPRnb( LVDIFFJ   , 0.0        , "-"                             , "Length dependence of vdiffj ")
`MPRnb( LJS0D     , LJS0       , "-"                             , "Length dependence of js0d ")
`MPRnb( LJS0SWD   , LJS0SW     , "-"                             , "Length dependence of js0swd ")
`MPRnb( LNJD      , LNJ        , "-"                             , "Length dependence of njd ")
`MPRnb( LCISBKD   , LCISBK     , "-"                             , "Length dependence of cisbkd ")
`MPRnb( LVDIFFJD  , LVDIFFJ    , "-"                             , "Length dependence of vdiffjd ")
`MPRnb( LJS0S     , LJS0D      , "-"                             , "Length dependence of js0s ")
`MPRnb( LJS0SWS   , LJS0SWD    , "-"                             , "Length dependence of js0sws ")
`MPRnb( LNJS      , LNJD       , "-"                             , "Length dependence of njs ")
`MPRnb( LCISBKS   , LCISBKD    , "-"                             , "Length dependence of cisbks ")
`MPRnb( LVDIFFJS  , LVDIFFJD   , "-"                             , "Length dependence of vdiffjs ")
`MPRnb( WJS0      , 0.0        , "-"                             , "Width dependence of js0 ")
`MPRnb( WJS0SW    , 0.0        , "-"                             , "Width dependence of js0sw ")
`MPRnb( WNJ       , 0.0        , "-"                             , "Width dependence of nj ")
`MPRnb( WCISBK    , 0.0        , "-"                             , "Width dependence of cisbk ")
`MPRnb( WVDIFFJ   , 0.0        , "-"                             , "Width dependence of vdiffj ")
`MPRnb( WJS0D     , WJS0       , "-"                             , "Wength dependence of js0d ")
`MPRnb( WJS0SWD   , WJS0SW     , "-"                             , "Wength dependence of js0swd ")
`MPRnb( WNJD      , WNJ        , "-"                             , "Wength dependence of njd ")
`MPRnb( WCISBKD   , WCISBK     , "-"                             , "Wength dependence of cisbkd ")
`MPRnb( WVDIFFJD  , WVDIFFJ    , "-"                             , "Wength dependence of vdiffjd ")
`MPRnb( WJS0S     , WJS0D      , "-"                             , "Wength dependence of js0s ")
`MPRnb( WJS0SWS   , WJS0SWD    , "-"                             , "Wength dependence of js0sws ")
`MPRnb( WNJS      , WNJD       , "-"                             , "Wength dependence of njs ")
`MPRnb( WCISBKS   , WCISBKD    , "-"                             , "Wength dependence of cisbks ")
`MPRnb( WVDIFFJS  , WVDIFFJD   , "-"                             , "Wength dependence of vdiffjs ")
`MPRnb( PJS0      , 0.0        , "-"                             , "Cross-term dependence of js0 ")
`MPRnb( PJS0SW    , 0.0        , "-"                             , "Cross-term dependence of js0sw ")
`MPRnb( PNJ       , 0.0        , "-"                             , "Cross-term dependence of nj ")
`MPRnb( PCISBK    , 0.0        , "-"                             , "Cross-term dependence of cisbk ")
`MPRnb( PVDIFFJ   , 0.0        , "-"                             , "Cross-term dependence of vdiffj ")
`MPRnb( PJS0D     , PJS0       , "-"                             , "Cross-term dependence of js0d ")
`MPRnb( PJS0SWD   , PJS0SW     , "-"                             , "Cross-term dependence of js0swd ")
`MPRnb( PNJD      , PNJ        , "-"                             , "Cross-term dependence of njd ")
`MPRnb( PCISBKD   , PCISBK     , "-"                             , "Cross-term dependence of cisbkd ")
`MPRnb( PVDIFFJD  , PVDIFFJ    , "-"                             , "Cross-term dependence of vdiffjd ")
`MPRnb( PJS0S     , PJS0D      , "-"                             , "Cross-term dependence of js0s ")
`MPRnb( PJS0SWS   , PJS0SWD    , "-"                             , "Cross-term dependence of js0sws ")
`MPRnb( PNJS      , PNJD       , "-"                             , "Cross-term dependence of njs ")
`MPRnb( PCISBKS   , PCISBKD    , "-"                             , "Cross-term dependence of cisbks ")
`MPRnb( PVDIFFJS  , PVDIFFJD   , "-"                             , "Cross-term dependence of vdiffjs )")
`endif /* End of COEXTDIO */

// for deep punchthrough model
//`MPIcc( COPT       , 0          , "-"                 ,   0 ,   1 , "flag punchthrough ")   
//`MPIsw( COPSPT     , 0          , "-"                             , "flag Ps0 method for deep punchthrough ")   
`MPRoc( XJPT       , 3E-8       , "m"                 ,   0 ,   1 , "Junction depth; deep punchthrough ") 
`MPRoo( NJUNC      , 1e20       , "cm-3"              ,   0 , inf , "Junction doping conc; deep punchthrough  ")
`MPRcc( MUPT       , 0.0        , "m^2/V/s"           ,   0 , inf , "mobility for deep punchthrough ")
`MPRnb( VFBPT      , 0.0        , "V"                             , "dVfb for deep punchthrough ")
`MPRnb( PSLIMPT    , 0.0        , "V"                             , "Ps0 limit for deep punchthrough ")

   
// Output Physical Values in operating point analysis //
`OPP( idse        , "A"         , "Drain-Source current")
`OPP( IdsAcc      , "A"         , "Accumlation current of Depletion mode MOSFET")
`OPP( IdsRes      , "A"         , "Resistor current of Depletion mode MOSFET")
`OPP( Rdde        , "Ohm"       , "Drift Resistance on Drain side")
`OPP( Rsde        , "Ohm"       , "Drift Resistance on Source side")
`OPP( Isuba       , "A"         , "Substrate current")
`OPP( igidle      , "A"         , "Gate-Induced Drain Leakage current")
`OPP( igisle      , "A"         , "Gate-Induced Source Leakage current")
`OPP( igde        , "A"         , "Gate-Drain current")
`OPP( igse        , "A"         , "Gate-Source current")
`OPP( igbe        , "A"         , "Gate-Substrate current")
`OPP( ggm         , "S"         , "Transconductance")
`OPP( ggds        , "S"         , "Channel conductance")
`OPP( ggmbs       , "S"         , "Body effect(Back gate) transconductance")
`OPP( vone        , "V"         , "Threshold voltage")
`OPP( vdsate      , "V"         , "Saturation voltage")
`OPP( qge         , "C"         , "Gate charge")
`OPP( qde         , "C"         , "Drain charge")
`OPP( qse         , "C"         , "Bulk charge")
`OPP( cggbd       , "F"         , "g-g MOSFET capacitance")
`OPP( cgdbd       , "F"         , "g-d MOSFET capacitance")
`OPP( cgsbd       , "F"         , "g-s MOSFET capacitance")
`OPP( cbgbd       , "F"         , "b-g MOSFET capacitance")
`OPP( cbsbd       , "F"         , "b-s MOSFET capacitance")
`OPP( cbdbd       , "F"         , "b-d MOSFET capacitance")
`OPP( cdgbd       , "F"         , "d-g MOSFET capacitance")
`OPP( cddbd       , "F"         , "d-d MOSFET capacitance")
`OPP( cdsbd       , "F"         , "d-s MOSFET capacitance")
`OPP( TK          , "K"         , "Actual device temperature")
`OPP( IdsPT       , "A"         , "Punchthrough current ")
`OPP( IdsPT0      , "A"         , "Punchthrough current ")
`OPP( IdsPT1      , "A"         , "Punchthrough current ")

   
`ifdef _AGING_
`OPP( DVTBTI      , "C"         , "threshold voltage shift of trap")
`OPP( NTRAP0      , "C"         , "trap charge on source side")
`OPP( NTRAPL      , "C"         , "trap charge on drain side")
`endif

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
`OPP( ibdb      , "A"   , " b-d Diode current")
`OPP( ibsb      , "A"   , " b-s Diode current")
`OPP( ibdbi     , "A"   , " b-dp Diode current")
`OPP( ibsbi     , "A"   , " b-sp Diode current")
`OPP( Gbd       , "S"   , " b-d Diode conductance")
`OPP( Gbs       , "S"   , " b-s Diode conductance")
`OPP( capbdb    , "F"   , " b-d Diode capacitance")
`OPP( capbsb    , "F"   , " b-s Diode capacitance")
`OPP( capbdbi   , "F"   , " b-dp Diode capacitance")
`OPP( capbsbi   , "F"   , " b-sp Diode capacitance")
`OPP( Qbd       , "C"   , " b-d Diode charge")
`OPP( Qbs       , "C"   , " b-s Diode charge")
`OPP( Qbdi      , "C"   , " b-dp Diode charge")
`OPP( Qbsi      , "C"   , " b-sp Diode charge")
`endif /* End of COEXTDIO */
// End of Output Physical Values //

// limited exp function (lexp)
`define CEXP_THRES 80.0
`define CMAX_EXP 5.540622384e+34
`define CMIN_EXP 1.804851387e-35
analog function real lexp;
       input x; 
       real x;
       begin
         if(x > `CEXP_THRES) begin
                 lexp = `CMAX_EXP * ( 1.0 + (x) -`CEXP_THRES);
         end else if(x < -`CEXP_THRES) begin
                 lexp = `CMIN_EXP;
         end else begin
                 lexp = exp(x);
         end
       end
endfunction

//===========================================================*
//* Exp() for large input value.
//*=================*/
`define D_EXP_THRESHOLD (500.0)                //exp(710)=inf
`define D_MAX_EXP       (1.403592217853e+217)  //exp(500.0)
`define C_UNIT_EXP_ARG  (60.0)                 //exp(60.0) may touch the Verilog-A limit
`define C_UNIT_EXP_RES  (1.14200738981568e+26) //exp(60.0)
`define Fn_DExp( y , x , dx) begin \
  if ((x) >= `D_EXP_THRESHOLD) begin \
    y  = `D_MAX_EXP * (1 + (x) - `D_EXP_THRESHOLD); \
    dx = `D_MAX_EXP ; \
  end else begin \
    TMF1 = (x); \
    y = 1.0; \
    while (TMF1 >= `C_UNIT_EXP_ARG ) begin \
      y = y * `C_UNIT_EXP_RES; \
      TMF1 = TMF1 - `C_UNIT_EXP_ARG; \
    end \
    y = y * exp(TMF1); dx = y; \
  end \
end

//---------------------------------------------------* 
//* Macros for aging model.
//*-----------------*/
`define SU_TRAP_delta 1e-3
`define Fn_calc_TRAP( N00 , N01 , N02, N03, N04, ps , pds ) begin \
    efn_ec = ps - ( - keT *ln(2.5e25/Nsub)+pds) - EG0 ; \
    TMF4 = lexp( efn_ec / MKS_TRAPES1 ) ; \
    y1 = N01 * TMF4 ; \
    `Fn_SLtemp( y1 , y1 , 1 , 1 ) \
    TMF4 = lexp( efn_ec / TRAPES2 ) ; \
    y2 = N02 * TMF4 ; \
    `Fn_SLtemp( y2 , y2 , 1 , 1 ) \
    TMF5 = log(y1) ; \
    TMF4 = lexp( efn_ec / TRAPESLIM ) ; \
    y6 = N04 * TMF4 ;  TMF8 = log(y6) ; \
    if( CODEGES0 ) begin \
      TMF4 = lexp( efn_ec / TRAPES0 ) ; \
      y3 = N03 * TMF4 ; \
      `Fn_SLtemp( y3 , y3 , 1 , 1 ) \
      TMF8 = log(y3) ; \
      `Fn_SUtemp( TMF6 , TMF8 , TMF5 , `SU_TRAP_delta )  \
    end else begin \
      `Fn_SUtemp( TMF6 , TMF5 , TMF8 , `SU_TRAP_delta*0.1 )  \
    end \
    y4 = pow(10,TMF6) ; \
    y5 = y4 * lexp( - Vtraplx_prv / TRAPLX ) ; \
    TMF5 = log(y5) ; TMF6 = log(y2) ; \
    `Fn_SLtemp( TMF7 , TMF6 , TMF5 , `SU_TRAP_delta*0.1 )  \
    N00 = pow(10,TMF7) ; \
 end

`define Fn_calcNKT(NtK,gc,es) begin \
    delta = ( `C_Pi * keT ) / es ; \
    NtK   = abs( gc * es * ( delta / sin( delta ))) ; \
 end

//--------------------------------------------------
//
// Local variables.
//




`ifdef _AGING_
// ** Aging model ***************//
`define pretime  1e-12
   integer fno ;
   real pretime0 ;
   real TMF5, TMF6, TMF7, TMF8 ;
   real MKS_TRAPGC1 , MKS_TRAPGC2 , MKS_TRAPES1 , MKS_GC1MAX ;
   real MKS_TRAPGCLIM ;
   real keT, delta, NtK1, NtK10, NtK20 ;
   real efn_ec ;
   real gc1 , e1 , Isub_trap , abstime ;
   real MKS_TRAPGC0, NtK30, NtK40, y1, y2, y3, y4, y5, y6  ;
   real Ps0_prv , Vtraplx_prv ;
   real nt0s , ntls ;
   real Nt0s_temp ;
   real dVth_bti , ts_bti , tcycle , Eox ;
   real ontime , Vgsonave , Vgpon ;
   real ftr0_qs, ftr0_qs_dPs0 ;
   real ftrl_qs, ftrl_qs_dPsl ;
   real exp_time , Nt_max0 , Nt_maxl ;
   real Qt0 ;
   real Tdiff_2 ;
`endif
   
// Constants ----------------------- //
// double ps_conv=1.0e-13 ;//
// depletion *//
// 5-degree , contact:Chi=5 //
// inversion *//
// 3-degree polynomial approx for ( exp[Chi]-1 )^{1/2} //
// initial guess *//
   real Vbs_max ;
   real Vbs_bnd, Gdsmin, Gjmin ;
// Internal flags --------------------//
// integer flg_err ;
   integer flg_rsrd , flg_rd , flg_rs ;
   integer flg_pprv ;
   integer flg_noqi ;
   integer flg_conv ;
   integer flg_qme ;
   integer flg_qy ;
// flag for NQS calculation //
   integer flg_nqs ;
// Important Variables in HiSIM -------//
// external bias //
   real Vbse, Vdse, Vgse ;
// confine bias //
   real Vbsc, Vdsc, Vgsc, dVbsc ;
// internal bias //
   real Vbs, Vds, Vgs, Vdb, Vsb, Vgp, Vgs_fb ;
// Ps0 : surface potential at the source side //
   real Ps0, Ps0_ini, Ps0_iniA, Ps0_iniB ;
// Psl : surface potential at the drain side //
   real Psl, Psl_lim, dPlim ;
// Pds :=Psl - Ps0 //
   real Pds, Pds_ini, Pds_max , Pdsz ;
// iteration numbers of Ps0 and Psl equations. //
   integer lp_s0, lp_sl ;
// Xi0 :=beta * ( Ps0 - Vbs ) - 1. //
   real Xi0, Xi0p12, Xi0p32, wk_Xi0p12 ;
// Xil :=beta * ( Psl - Vbs ) - 1. //
   real Xilp12, Xilp32, Xil ;
// modified bias and potential for sym.//
   real Vbsz, Vdsz, Vgsz, Vzadd, Ps0z, Pzadd ;
   real Vgpz ;
// IBPC //
   real dVbsIBPC, betaWL, dG3, dG4, dIdd ;
// Chi :=beta * ( Ps{0/l} - Vbs ) //
   real Chi ;
// Rho :=beta * ( Psl - Vds ) //
   real Rho ;
// threshold voltage //
   real Vth, Vth0 ;
// variation of threshold voltage //
   real dVth, dVth0, dVthSC, Pb20b, dVthW ;
// dVthVert 20180306 20180704(sc) 20180706(nw)
   real dVthVert , q_Nsubd , Nsubd , Pb20d ;
   real wdVthVert , dVthVerts , dVthVertd , wdpld , dVthVertdnw;
   real UC_NSUBD, UC_SC2W, dVSFTDsc, UC_NSUBDNW, UC_NSUBDW0, Nsubdnw,q_Nsubdnw,wdpldnw,Pb20dnw, wk_gammad,wk_gamma3, wk_vsftdnw;


// Alpha and related parameters //
   real Alpha, Achi, VgVt, Pslsat, Vdsat, VdsatS, Delta ;

   
// Q_B and capacitances //
   real Qb, Qbu ;
// Q_I and capacitances //
   real Qi, Qiu ;
// Q_D and capacitances //
   real Qd ;
// channel current //
   real Ids, Ids0 , Idsorg ;
// STI //
   real dVthSCSTI, Vgssti, costi0, costi1, costi3, costi4, costi5, costi6 ;
   real costi7, Psasti, Psbsti, Psab, Psti, sq1sti, sq2sti, Qn0sti, Idssti ;
// constants //
   real beta, beta_inv, beta2, Pb2, Pb20, Pb2c, Vfb, c_eox, Leff, Leff_cv, Weff, Weff_cv ;
   real q_Nsub ;
   real C2_esi_p_q ;
// PART-1 //
// Accumulation zone //
   real Psa ;
// CLM//
   real Psdl, Lred, Lch, Wd, Aclm ;
// Pocket Implant //
   real Vthp, dVthLP, bs12, Qbmm, dqb, Vdx, Vdx2, Pbsum, sqrt_Pbsum ;
// Poly-Depletion Effect //
   real dPpg ;
// Quantum Effect //
   real Toxe, dTox, Cox, Cox_inv, Tox0, Cox0, Cox0_inv, Vthq ;
// Igate , Igidl , Igisl //
   real Psdlz, Egp12, Egp32, E1, Qb0Cox, Etun, Egidl, Egisl, Igate, Igs ;
   real Igd, Igb, Igidl, Igisl ;
// connecting function //
   real FD2, FMDVDS, cnst0, cnst1, cnstCoxi, fac1, fac1p2, fs01, fs01_dPs0 ;
   real fs02, fs02_dPs0, fsl1, fsl1_dPsl ;
   real fsl2, fsl2_dPsl ;
   real cfs1, fb, fb_dChi, fi, fi_dChi, exp_Chi, exp_Rho, exp_bVbs, exp_bVbsVds ;
   real Fs0, Fsl, Fs0_dPs0, Fsl_dPsl, dPs0, dPsl, Qn0, Qb0, DtPds ;
   real Qinm, Qidn, Qdnm, Qddn, Quot, Qdrat, Idd, Fdd, Eeff, Rns, Mu, Muun ;
   real Ey, Em, Vmaxe, Eta, Eta1, Eta1p12, Eta1p32, Zeta12, Zeta32 ;
   real F00, F10, Ps0_min, Acn, Acd, Ac1, Ac2, Ac3, Ac4 ;
   real Ac31, Ac41 ;
   real Qbnm , F11 , F30 , Zeta52 , Eta1p52  ;
// PART-2 (Isub) //
   real Isub, Psislsat, Psisubsat ;
// PART-3 (overlap) //
   real cov_slp, cov_mag, covvg, Lov, Qgos, Qgod ;
   integer flg_overgiven ;
   real Qgbo, Cgdoe, Cgsoe, Cgbo_loc ;
   real Cox0ov, Cox0ov_inv ;
// fringing capacitance //
   real Cf, Qfd, Qfs ;
// Cqy //
   real Ec, Pslk, Qy, Qys ;
// PART-4 (junction diode) //
// junction capacitance //
   real arg ;
// PART-5 (NQS) //
   real tau, Qi_nqs, taub, Qb_nqs ;
// PART-6 (noise) //
// 1/f //
   real NFalp1, NFalp2 ;
   real NFtrpe, Cite, Nflic ;
   real Qiu_noi, Qi_noi ;
// thermal //
   real Eyd, Mu_Ave, Nthrml, Mud_hoso ;
// induced gate noise ( Part 0/3 ) //
   real kusai00, kusaidd, kusaiL, kusai00L ;
   integer flg_ign ;
   real sqrtkusaiL, kusai_ig, gds0_ign, gds0_h2, GAMMA, crl_f ;
   real Nign0, MuModA, MuModB, correct_w1 ;
// Bias iteration accounting Rs/Rd //
   real Rsd, Rdd ;
// temporary vars. //
   real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TX, TY ;
   integer flg_zone ;
// Vdseff //
   real Vdseff, Vdsorg ;
// G/S and G/D Overlap Charges: Qovs/Qovd //
   real Qovd, Qovs ;
   integer lcover, flg_ovloops, flg_ovloopd, flg_overs, flg_overd ;
   real VgpLD, QbdLD, QbsLD, QbuLD, QsuLD, QiuLD, Ps0LD ;
   integer flg_ovzone ;
// Vgsz for SCE and PGD //
   real Vbsz2 ;
// Mode flag (=0 | 1 ) //
   real ModeNML, ModeRVS ;
// For Gate Leak Current Partitioning //
   real GLPART1 ;
// IBPC //
   real IdsIBPC ;
// Overlap Charge: Qover //
   real Vbsgmt, Vdsgmt, Vgsgmt, Vdbgmt, Vgbgmt, Vsbgmt, Vxbgmt, Vxbgmtcl ;
// Qover Iterative and Analytical Model //
   integer lp_ld ;
   real Vgb_fb_LD, VgpLD_shift, Ta, Tb, Tc, Tp, Td, Tq, Tu, Tv, exp_bPs0 ;
   real cnst1over, gammaChi, Chi_A, Chi_B, Chi_1, psi ;
// SCE LOOP //
   real A ;
   integer NNN ;
   real PS0Z_SCE ;
// double arg0=0.01 , arg1=0.04 ; //
   real arg0, arg2 ;
   integer MAX_LOOP_SCE, codqb, START_OF_SCE_LOOP, end_of_part_1 ;
// modify Qy in accumulation region //
   real Aclm_eff, Idd1, TTEMP, PS0_SCE_tol, A_dPS0Z, dqb_dPS0Z, dVth_dPS0Z ;
   real dVth0_dPS0Z, dVthLP_dPS0Z, dVthSC_dPS0Z, Qbmm_dPS0Z ;
   real Vgp_dPS0Z, Vthp_dPS0Z, Vth0_dPS0Z, T1_dPS0Z, T3_dPS0Z ;
   real T4_dPS0Z, T5_dPS0Z, T6_dPS0Z, T7_dPS0Z, T8_dPS0Z, T9_dPS0Z, T10_dPS0Z ;
   real TX_dPS0Z, Ac1_dPS0Z, Ac2_dPS0Z, Ac3_dPS0Z, Ac31_dPS0Z, Acd_dPS0Z ;
   real Acn_dPS0Z, Chi_dPS0Z, Psa_dPS0Z, Fs0_dPS0Z, Fsl_dPS0Z, Ps0_dPS0Z ;
   real Psl_dPS0Z, Pds_dPS0Z, Pzadd_dPS0Z, Ps0z_dPS0Z, G, delta_PS0Z_SCE ;
   real Vgs_min ;
// UC_*** Vars. for Device and Model Parameters
   integer UC_CORECIP ;
   real UC_VMAX     , UC_BGTMP1   , UC_BGTMP2   , UC_EG0      , UC_LOVER    ;
   real UC_VFBOVER  , UC_NOVER    , UC_WL2      , UC_VFBC     , UC_NSUBC    , UC_NJUNC  ; 
   real UC_NSUBP    , UC_SCP1     , UC_SCP2     , UC_SCP3     , UC_SC1      ;
   real UC_SC2      , UC_SC3      , UC_SC4      , UC_PGD1     , UC_NDEP     ;
   real UC_NINV     , UC_MUECB0   , UC_MUECB1   , UC_MUEPH1   , UC_VTMP     ;
   real UC_WVTH0    , UC_MUESR1   , UC_MUETMP   , UC_SUB1     , UC_SUB2     ;
   real UC_SVDS     , UC_SVBS     , UC_SVGS     , UC_NSTI     , UC_WSTI     ;
   real UC_SCSTI1   , UC_SCSTI2   , UC_VTHSTI   , UC_MUESTI1  , UC_MUESTI2  ;
   real UC_MUESTI3  , UC_NSUBPSTI1 , UC_NSUBPSTI2 , UC_NSUBPSTI3 , UC_NSUBCSTI1 ;
   real UC_NSUBCSTI2 , UC_NSUBCSTI3 , UC_CGSO     , UC_CGDO   ;
   real UC_CLM1     , UC_CLM2     ;
   real UC_CLM3     , UC_WFC      , UC_GIDL1    , UC_GIDL2    , UC_GLEAK1   ;
   real UC_GLEAK2   , UC_GLEAK3   , UC_GLEAK6   , UC_GLKSD1   , UC_GLKSD2   ;
   real UC_GLKB1    , UC_GLKB2    , UC_NFTRP    , UC_NFALP    ;
   real UC_IBPC1    , UC_IBPC2    , UC_NSUBPFAC , UC_NSUBPDLT ;
   real UC_NFALP1   , UC_NFALP2   ;
// Vars. for hsm2temp.c 
   real Tdiff ;
   real mueph  , dL     , LG     , dW     , WG     , WLG    , Lgate  , Wgate , dLc, dWc ;
   real Nsubpp , Nsubps , Nsub   , Nsubb  , Lod_half , Lod_half_ref , Eg     , Nin    ;
   real Denom  , sc3lim , sc3Vgs , term1  ;
   real term2  , term3  , term4  , Lbin   , Wbin   , LWbin ;
   real Ninvde ;
   //real NinvdeRES; // 20170323 for Mu_res (CODEP=3) (3.0.0)
   real ninvd0RES; // (3.0.0)
   real ninvd0cRES , ninvd0hRES ; // (3.0.1 or later)
   real NinvdecRES , NinvdehRES ; // (3.0.0, 3.0.1 or later)
   real log_Tratio;
// here->HSM2_ Vars. for hsm2eval.c 
   integer flg_pgd;
   real qnsub_esi2 , egtnom , cecox  , msc    , clmmod;
   real EF_MUEPH1 , EF_NSUBP , EF_NSUBC , NSUBCDFM_GIVEN , muesr ;
   real ndep_o_esi , ninv_o_esi , lgatesm , dVthsm , weff_nf, weffcv_nf , qnsub_esi;
   real ptovr0 , costi00 , nsti_p2 , vmax0  , cnstpgd , grg   ;
   real Rde    , Rse    , drainConductance , sourceConductance , grbdb ;
   real grbpb  , grbps  , grbsb  , grbpd  , DDLTe   , vg2const;
   real xvbs   , xgate  , xsub1  , xsub2  , cfrng  , cqyb0 ;
   real ptl0   , pt40   , gdl0   , betatnom;
   real mphn0  , ptovr  , VMAXeff , cnst0over , wdpl   , wdplp ;
   real costi0_p2 , cgsb  ;
   real isube  , noiflick , noithrml , noiigate;
   real noicross;
// Local Vars. for hsm2eval.c 
   integer m0     , mm    ;
   integer i      ; 
   real x2     , xmax2  , xp     , xmp    , dnm    , KTNOM  ;
   real flg_qmetemp , BYPASS_ENABLE , CGSO_GIVEN , CGDO_GIVEN;
   real qbe    , ggdss  , Mfactor , TMF0 , TMF1 , TMF2 , TMF3 , TMF4 , mMod   ;
   real gminMod , Npexte  , ivds   , ivgs   , ivgd   , ivbs   , ivbd ;
   real Qg     , Qs     , Isubs  , UC_GDLD   , UC_MUEPWD , UC_MUEPLD ;
   real cgbbd  , cdbbd  , csgbd  , csdbd  , cssbd  , csbbd  , cbbbd  , ggbbs  ;
   real ggbds  , ggbgs  , whi_noise , MKS_NPEXT , MKS_NSUBCWPE , MKS_NSUBPWPE ;
   real MKS_NPEXTWPE , MKS_LL , MKS_WL , MKS_SVGSL , MKS_SVGSW , MKS_SVBSL , MKS_SLGL , MKS_SUB1L ;
   real MKS_SLG , MKS_SUB2L , MKS_NSUBCMAX , MKS_GLKSD3 , MKS_GLEAK4 , MKS_GLEAK5 , MKS_GLEAK7 , MKS_CIT ;
   real MKS_OVSLP , MKS_DLY3 , MKS_NSUBCDFM , Ps0dVbs , T6dVb  , dVth0dVb , T9dVb  , T3dVb  ;
   real dVthLPdVb , T8dVb  , limVgpdVbs;
   
`ifdef COEXTDIO
             /* for External Diode Model */
`else
   real UC_JS0D     , UC_JS0SWD   , UC_NJD      , UC_CISBKD   , UC_VDIFFJD  ;
   real UC_JS0S     , UC_JS0SWS   , UC_NJS      , UC_CISBKS   , UC_VDIFFJS  ;
   real js     , jssw   , js2    , jssw2  , czbd   , czbdsw , czbdswg , czbs   ;
   real jsswg, jsswg2 ;
   real czbssw , czbsswg , sarg  ;
   real isbd   , vbdt   , exptempd , jd_nvtm_invd , jd_expcd;
   real isbs   , vbst   , exptemps , jd_nvtm_invs , jd_expcs;
   real vsbs   , vdbd   , vbs_jct , vbd_jct , Ibd    , Ibs    , Capbs , Capbd  ;
   real vbpsp  , vbpdp  , vbsi_jct, vbdi_jct, Ibdi   , Ibsi   , Capbsi, Capbdi ;
   real isbd_btm, isbd2_btm, isbd_sws, isbd2_sws, isbd_swg, isbd2_swg ;
   real isbs_btm, isbs2_btm, isbs_sws, isbs2_sws, isbs_swg, isbs2_swg ;
   real Ibd_btm, Ibs_btm, Ibd_sws, Ibs_sws, Ibd_swg, Ibs_swg ;
   real Qbd_btm, Qbs_btm, Qbd_sws, Qbs_sws, Qbd_swg, Qbs_swg ;
   real Capbd_btm, Capbs_btm, Capbd_sws, Capbs_sws, Capbd_swg, Capbs_swg ;
`endif
// Others
// integer flg_brk1, flg_brk2, flg_brk3 ;
   integer start_of_loopl, start_of_mobility , lp_s0_max ;
   integer mode , FATAL_flag ;
   real ci, sid, sigrat, sigrat_s, sigrat_d ;
   real I_nqs_b, I_nqs_i, NQS_CAPACITOR ;

/* for depletion mode MOS */
   integer UC_CODEP ;
   real UC_NDEPM , UC_DEPTHN ;
   real UC_DEPMUE0, UC_DEPMUE1, UC_DEPMUE2, UC_DEPLEAK, UC_DEPVMAX , UC_SUBTMP ;
   real UC_DEPMUEBACK0, UC_DEPMUEBACK1 ;
   real UC_DEPVDSEF1, UC_DEPVDSEF2 ;
   real Pb2n , Vbipn , xsubtmp ;  // will use Vbipn for non-depletion mode MOS; see new punchthrough model. 20180204

   real depmphn0 ;
   real Ws , Ids_acc , Ids_res ,  Ps0DEP ;
   real Tratio ; 
   real Vds_res , Qn_res , Vdssat_res;
   real Mu_acc , Mu_res ;
   real kjuncpn , W_res ;

/* new pt */
   real dphi_vds , phim , WK_JNPT_A ;
//`define dbgpt
`ifdef dbgpt
   real Vbspt , Ps0pt , Ecpt , Vgppt , TYpt , wkpt , Wdeppt ;
`endif


  //================ Start of executable code.=================//

//start_of_routine
   analog begin
     
     // Initial Settings
     FATAL_flag = 0 ;
     lp_s0_max  = `lp_s0_max ;
     Ids0 = 0 ;
     
     begin : initializeModel
      
       `GMIN          // 
       `MFACTOR_DEC   // 
       Mfactor = `MFACTOR_USE ;
       Gdsmin  = 0.0 ; Gjmin = gminMod ; 
       TMF1    = 0.0 ; TMF2  = 0.0 ; 
       TMF3    = 0.0 ; TMF4  = 0.0 ; 
//     BYPASS_ENABLE = 1 ;
       BYPASS_ENABLE = 0 ;
       
       //-----------------------------------------------------------*
       //* Range check of model parameters
       //*-----------------//        
       if(COERRREP) begin
       `MINCHECK(TOX,        0.0, "TOX") 
       `MINCHECK(TOXOV,      0.0, "TOXOV") 
       if((XLD     < 0.0   || XLD     > 50.0e-9) ) $write("warning: (XLD = %g) range [0.0 , 50.0e-9].\n",XLD);
       if((XLDC    < 0.0   || XLDC    > 50.0e-9) ) $write("warning: (XLDC = %g) range [0.0 , 50.0e-9].\n",XLDC);
       if((XWD  < -10.0e-9 || XWD     > 100.0e-9) ) $write("warning: (XWD = %g) range [-10.0e-9 , 100.0e-9].\n",XWD);
       if((XWDC < -10.0e-9 || XWDC    > 100.0e-9) ) $write("warning: (XWDC = %g) range [-10.0e-9 , 100.0e-9].\n",XWDC);   
       if((RSH     < 0.0   || RSH     > 200.0) ) $write("warning: (RSH = %g) range [0.0 , 200.0].\n",RSH);
       if((RSHG    < 0.0   || RSHG    > 100.0) ) $write("warning: (RSHG = %g) range [0.0 , 100.0].\n",RSHG);
       if((XQY   < 10.0e-9 || XQY     > 50.0e-9) ) $write("warning: (XQY = %g) range [10.0e-9 , 50.0e-9].\n",XQY);
       if((RS      < 0.0   || RS      > 10.0e-3) ) $write("warning: (RS = %g) range [0.0 , 10.0e-3].\n",RS);
       if((RD      < 0.0   || RD      > 10.0e-3) ) $write("warning: (RD = %g) range [0.0 , 10.0e-3].\n",RD);
       if((VBI     < 1.0   || VBI     > 1.2  ) ) $write("warning: (VBI = %g) range [1.0 , 1.2].\n",VBI);
       if((PARL2   < 0.0   || PARL2   > 50.0e-9) ) $write("warning: (PARL2 = %g) range [0.0 , 50.0e-9].\n",PARL2);
       if((LP      < 0.0   || LP      > 300.0e-9) ) $write("warning: (LP = %g) range [0.0 , 300.0e-9].\n",LP);
       if((PGD2    < 0.0   || PGD2    > 1.5  ) ) $write("warning: (PGD2 = %g) range [0.0 , 1.5].\n",PGD2);
       if((PGD4    < 0.0   || PGD4    > 3.0  ) ) $write("warning: (PGD4 = %g) range [0.0 , 3.0].\n",PGD4);
       if((MUECB0LP < 0.0  || MUECB0LP > 2.0  ) ) $write("warning: (MUECB0LP = %g) range [0.0 , 2.0].\n",MUECB0LP);
       if((MUECB1LP < 0.0  || MUECB1LP > 2.0  ) ) $write("warning: (MUECB1LP = %g) range [0.0 , 2.0].\n",MUECB1LP);
       if((MUEPH0  < 0.25  || MUEPH0  > 0.35 ) ) $write("warning: (MUEPH0 = %g) range [0.25 , 0.35].\n",MUEPH0);
       if((MUESR0  < 1.8   || MUESR0  > 2.2  ) ) $write("warning: (MUESR0 = %g) range [1.8 , 2.2].\n",MUESR0);
       if((LPEXT < 1.0e-50 || LPEXT   > 10.0e-6) ) $write("warning: (LPEXT = %g) range [1.0e-50 , 10.0e-6].\n",LPEXT);
       if((NPEXT  < 1.0e16 || NPEXT   > 1.0e18) ) $write("warning: (NPEXT = %g) range [1.0e16 , 1.0e18].\n",NPEXT);
       if((SCP21   < 0.0   || SCP21   > 5.0  ) ) $write("warning: (SCP21 = %g) range [0.0 , 5.0].\n",SCP21);
       if((SCP22   < 0.0   || SCP22   > 0.0  ) ) $write("warning: (SCP22 = %g) range [0.0 , 0.0].\n",SCP22);
       if((BS1    < -1.0   || BS1     > 50.0e-3) ) $write("warning: (BS1 = %g) range [-1.0 , 50.0e-3].\n",BS1);
       if((BS2     < 0.5   || BS2     > 1.0  ) ) $write("warning: (BS2 = %g) range [0.5 , 1.0].\n",BS2);
       `MINCHECK(CGBO,       0.0, "CGBO") 
       if((CLM5    < 0.0   || CLM5    > 2.0  ) ) $write("warning: (CLM5 = %g) range [0.0 , 2.0].\n",CLM5);
       if((CLM6    < 0.0   || CLM6    > 20.0 ) ) $write("warning: (CLM6 = %g) range [0.0 , 20.0].\n",CLM6);
       if((VOVER   < 0.0   || VOVER   > 50.0 ) ) $write("warning: (VOVER = %g) range [0.0 , 50.0].\n",VOVER);
       if((VOVERP  < 0.0   || VOVERP  > 2.0  ) ) $write("warning: (VOVERP = %g) range [0.0 , 2.0].\n",VOVERP);
       if((QME1    < 0.0   || QME1    > 300.0e-9) ) $write("warning: (QME1 = %g) range [0.0 , 300.0e-9].\n",QME1);
       if((QME2    < 1.0   || QME2    > 3.0  ) ) $write("warning: (QME2 = %g) range [1.0 , 3.0].\n",QME2);
       if((QME3    < 0.0   || QME3    > 1.0e-9) ) $write("warning: (QME3 = %g) range [0.0 , 1.0e-9].\n",QME3);
       if((TNOM    < 22.0  || TNOM    > 32.0 ) ) $write("warning: (TNOM = %g) range [22.0 , 32.0].\n",TNOM);
       if((DDLTMAX < 1.0   || DDLTMAX > 20.0 ) ) $write("warning: (DDLTMAX = %g) range [1.0 , 20.0].\n",DDLTMAX);
       if((DDLTICT < -3.0  || DDLTICT > 20.0 ) ) $write("warning: (DDLTICT = %g) range [-3.0 , 20.0].\n",DDLTICT);
       if((DDLTSLP < 0.0   || DDLTSLP > 20.0 ) ) $write("warning: (DDLTSLP = %g) range [0.0 , 20.0].\n",DDLTSLP);
       if((SC3VBS  < -3.0  || SC3VBS  > 0.0  ) ) $write("warning: (SC3VBS = %g) range [-3.0 , 0.0].\n",SC3VBS);

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
         if( CVB     < -0.1  || CVB     > 0.2 ) $write("warning(HiSIM2(%m)): (CVB = %g) range [-0.1 , 0.2].\n",CVB);
       if((CVBK    < -0.1  || CVBK    > 0.2  ) ) $write("warning: (CVBK = %g) range [-0.1 , 0.2].\n",CVBK);
         if( CVBD    < -0.1  || CVBD    > 0.2 ) $write("warning(HiSIM2(%m)): (CVBD = %g) range [-0.1 , 0.2].\n",CVBD);
         if( CVBS    < -0.1  || CVBS    > 0.2 ) $write("warning(HiSIM2(%m)): (CVBS = %g) range [-0.1 , 0.2].\n",CVBS);
`endif

       end

/* for depletion mode MOS */
       UC_CODEP = CODEP ;
       UC_CORECIP = CORECIP ;
       UC_NDEPM  = NDEPM ;
       UC_DEPTHN = TNDEP ;
       UC_DEPVDSEF1 = DEPVDSEF1 ;
       UC_DEPVDSEF2 = DEPVDSEF2 ;

       if( UC_CODEP != 0 )  begin

         `RANGERESET(UC_NDEPM,      5e15,      1e18,  "NDEPM" )
         `RANGERESET(UC_DEPTHN,     1e-8,      1e-6,  "TNDEP" )
         if( UC_DEPVDSEF2 < 0.1 ) 
         begin $write("reset  : (DEPVDSEF2 = %g to 0.1) range [0.1, 2].\n",UC_DEPVDSEF2); UC_DEPVDSEF2 = 0.1; end
         if( UC_DEPVDSEF2 > 2.0 )  
         begin $write("reset  : (DEPVDSEF2 = %g to 2.0) range [0.1, 2].\n",UC_DEPVDSEF2); UC_DEPVDSEF2 = 2.0; end

         if(COERRREP) begin
         if( NSUBC > NDEPM * 5.0 ) begin
            $write("warning(HiSIM2): NSUBC(%e) is too high compared to NDEPM(%e), please check model parameter and convergence\n",NSUBC,NDEPM);
         end
         
         if( UC_CORECIP ) begin
           $write("warning(HiSIM2): The CORECIP is not supported yet in Depletion mode model, reset to 0.\n");
           UC_CORECIP = 0 ;
         end
         if( COISTI ) begin
           $write("warning(HiSIM2): The STI leak model is not supported yet in Depletion mode model, skipped\n");
         end
         if( COTHRML ) begin
           $write("warning(HiSIM2): The Thermal noise model is not supported yet in Depletion mode model, skipped\n");
         end
         if( COIGN ) begin
           $write("warning(HiSIM2): The Induced gate noise model is not supported yet in Depletion mode model, skipped\n");
         end
         end

       end
       if( COPPRV ) begin
         $write("warning(HiSIM2): The COPPRV is not supported yet in VA code.\n");
       end

       UC_NSUBPFAC = NSUBPFAC ;
       UC_NSUBPDLT = NSUBPDLT ;
       `RANGERESET(UC_NSUBPFAC,   0.2,      1.0, "NSUBPFAC") 
       `RANGERESET(UC_NSUBPDLT, 1E-50,      0.1, "NSUBPDLT") 
               
       //-----------------------------------------------------------*
       //* Conversion to MKS unit for model parameters.
       //*-----------------//
       MKS_NPEXT     = NPEXT     / `C_cm2m_p3 ;
       MKS_NSUBCWPE  = NSUBCWPE  / `C_cm2m_p3 ;
       MKS_NSUBPWPE  = NSUBPWPE  / `C_cm2m_p3 ;
       MKS_NPEXTWPE  = NPEXTWPE  / `C_cm2m_p3 ;
       MKS_LL        = LL        / pow( `C_m2cm , LLN ) ;
       MKS_WL        = WL        / pow( `C_m2cm , WLN ) ;
       MKS_SVGSL     = SVGSL     / pow( `C_m2cm , SVGSLP ) ;
       MKS_SVGSW     = SVGSW     / pow( `C_m2cm , SVGSWP ) ;
       MKS_SVBSL     = SVBSL     / pow( `C_m2cm , SVBSLP ) ;
       MKS_SLGL      = SLGL      / pow( `C_m2cm , SLGLP ) ;
       MKS_SUB1L     = SUB1L     / pow( `C_m2cm , SUB1LP ) ;
       MKS_SLG       = SLG       / `C_m2cm ;
       MKS_SUB2L     = SUB2L     / `C_m2cm ;
       MKS_NSUBCMAX  = NSUBCMAX  / `C_cm2m_p3 ;
       MKS_GLKSD3    = GLKSD3    * `C_m2cm ;
       MKS_GLEAK4    = GLEAK4    * `C_m2cm ;
       MKS_GLEAK5    = GLEAK5    * `C_m2cm ;
       MKS_GLEAK7    = GLEAK7    / `C_m2cm_p2 ;
       MKS_CIT       = CIT       * `C_m2cm_p2 ;
       MKS_OVSLP     = OVSLP     / `C_m2cm ;
       MKS_DLY3      = DLY3      / `C_m2cm_p2 ;
       UC_NDEPM      = UC_NDEPM  / `C_cm2m_p3 ;

                     
       //-----------------------------------------------------------*
       //* Change unit into Kelvin.
       //*-----------------//
       KTNOM = TNOM + 273.15 ; // [C] -> [K] //
             
       // Quantum Mechanical Effect //
       if(( QME1 == 0.0 && QME3 == 0.0 ) || QME2 == 0.0 ) begin
         flg_qmetemp = 0 ;
       end else begin
         flg_qmetemp = 1 ;
       end

       // Isub Model //
       UC_SUBTMP  = SUBTMP ;
       `RANGERESET(UC_SUBTMP ,    0.0 ,     5.0e-3, "SUBTMP"   ) 
               
       //
               
     end // initializeModel
             
     begin : initializeInstance

       NSUBCDFM_GIVEN = ($param_given(NSUBCDFM));
       CGDO_GIVEN = ($param_given(CGDO));
       CGSO_GIVEN = ($param_given(CGSO));
       grbdb = 0.0; grbpb = 0.0; grbpd = 0.0; grbps = 0.0; grbsb = 0.0; grg = 0.0;

       //-----------------------------------------------------------*
       //* Range check of instance parameters
       //*-----------------//
       if(COERRREP) begin
       if( (L       < LMIN  || L       > LMAX ) ) $write("warning: (L = %g) range [LMIN , LMAX].\n",L);
       if( (W/NF    < WMIN  || W/NF    > WMAX ) ) $write("warning: (W/NF = %g) range [WMIN , WMAX].\n",W/NF);
       if( (MPHDFM  < -3.0  || MPHDFM  > 3.0  ) ) $write("warning: (MPHDFM = %g) range [-3.0 , 3.0].\n",MPHDFM);
       end
                  
       // Calculate & check the Lgate and Wgate 
       Lgate = L + XL ;
       Wgate = W / NF  + XW ;
       `RANGECHECKFoo( Lgate     , 0.0, `inf, "Lgate")
       `RANGECHECKFoo( Wgate     , 0.0, `inf, "Wgate")
       `RANGECHECKFoo( Lgate-XGL , 0.0, `inf, "Lgate-XGL" )
       `RANGECHECKFco( Lgate+LLD , 0.0, `inf, "Lgate+LLD" )
       `RANGECHECKFco( Wgate+WLD , 0.0, `inf, "Wgate+WLD")
       `RANGECHECKFco( Lgate+GDLD, 0.0, `inf, "Lgate+GDLD")
            
       // binning calculation //
       LG = Lgate * `C_m2um ;
       WG = Wgate * `C_m2um ;
       Lbin = pow(LG, LBINN) ;
       Wbin = pow(WG, WBINN) ;
       LWbin = Lbin * Wbin ;
             
       `BINNING(UC_VMAX, VMAX, LVMAX, WVMAX, PVMAX) 
       `BINNING(UC_BGTMP1, BGTMP1, LBGTMP1, WBGTMP1, PBGTMP1) 
       `BINNING(UC_BGTMP2, BGTMP2, LBGTMP2, WBGTMP2, PBGTMP2) 
       `BINNING(UC_EG0, EG0, LEG0, WEG0, PEG0) 
       `BINNING(UC_LOVER, LOVER, LLOVER, WLOVER, PLOVER) 
       `BINNING(UC_VFBOVER, VFBOVER, LVFBOVER, WVFBOVER, PVFBOVER) 
       `BINNING(UC_NOVER, NOVER, LNOVER, WNOVER, PNOVER) 
       `BINNING(UC_WL2, WL2, LWL2, WWL2, PWL2) 
       `BINNING(UC_VFBC, VFBC, LVFBC, WVFBC, PVFBC) 
       `BINNING(UC_NSUBC, NSUBC, LNSUBC, WNSUBC, PNSUBC) 
       `BINNING(UC_NSUBP, NSUBP, LNSUBP, WNSUBP, PNSUBP) 
       `BINNING(UC_SCP1, SCP1, LSCP1, WSCP1, PSCP1) 
       `BINNING(UC_SCP2, SCP2, LSCP2, WSCP2, PSCP2) 
       `BINNING(UC_SCP3, SCP3, LSCP3, WSCP3, PSCP3) 
       `BINNING(UC_SC1, SC1, LSC1, WSC1, PSC1) 
       `BINNING(UC_SC2, SC2, LSC2, WSC2, PSC2) 
       `BINNING(UC_SC3, SC3, LSC3, WSC3, PSC3) 
       `BINNING(UC_SC4, SC4, LSC4, WSC4, PSC4) 
       `BINNING(UC_PGD1, PGD1, LPGD1, WPGD1, PPGD1) 
       `BINNING(UC_NDEP, NDEP, LNDEP, WNDEP, PNDEP) 
       `BINNING(UC_NINV, NINV, LNINV, WNINV, PNINV) 
       `BINNING(UC_MUECB0, MUECB0, LMUECB0, WMUECB0, PMUECB0) 
       `BINNING(UC_MUECB1, MUECB1, LMUECB1, WMUECB1, PMUECB1) 
       `BINNING(UC_MUEPH1, MUEPH1, LMUEPH1, WMUEPH1, PMUEPH1) 
       `BINNING(UC_VTMP, VTMP, LVTMP, WVTMP, PVTMP) 
       `BINNING(UC_WVTH0, WVTH0, LWVTH0, WWVTH0, PWVTH0) 
       `BINNING(UC_MUESR1, MUESR1, LMUESR1, WMUESR1, PMUESR1) 
       `BINNING(UC_MUETMP, MUETMP, LMUETMP, WMUETMP, PMUETMP) 
       `BINNING(UC_SUB1, SUB1, LSUB1, WSUB1, PSUB1) 
       `BINNING(UC_SUB2, SUB2, LSUB2, WSUB2, PSUB2) 
       `BINNING(UC_SVDS, SVDS, LSVDS, WSVDS, PSVDS) 
       `BINNING(UC_SVBS, SVBS, LSVBS, WSVBS, PSVBS) 
       `BINNING(UC_SVGS, SVGS, LSVGS, WSVGS, PSVGS) 
       `BINNING(UC_NSTI, NSTI, LNSTI, WNSTI, PNSTI) 
       `BINNING(UC_WSTI, WSTI, LWSTI, WWSTI, PWSTI) 
       `BINNING(UC_SCSTI1, SCSTI1, LSCSTI1, WSCSTI1, PSCSTI1) 
       `BINNING(UC_SCSTI2, SCSTI2, LSCSTI2, WSCSTI2, PSCSTI2) 
       `BINNING(UC_VTHSTI, VTHSTI, LVTHSTI, WVTHSTI, PVTHSTI) 
       `BINNING(UC_MUESTI1, MUESTI1, LMUESTI1, WMUESTI1, PMUESTI1) 
       `BINNING(UC_MUESTI2, MUESTI2, LMUESTI2, WMUESTI2, PMUESTI2) 
       `BINNING(UC_MUESTI3, MUESTI3, LMUESTI3, WMUESTI3, PMUESTI3) 
       `BINNING(UC_NSUBPSTI1, NSUBPSTI1, LNSUBPSTI1, WNSUBPSTI1, PNSUBPSTI1) 
       `BINNING(UC_NSUBPSTI2, NSUBPSTI2, LNSUBPSTI2, WNSUBPSTI2, PNSUBPSTI2) 
       `BINNING(UC_NSUBPSTI3, NSUBPSTI3, LNSUBPSTI3, WNSUBPSTI3, PNSUBPSTI3) 
       `BINNING(UC_NSUBCSTI1, NSUBCSTI1, LNSUBCSTI1, WNSUBCSTI1, PNSUBCSTI1) 
       `BINNING(UC_NSUBCSTI2, NSUBCSTI2, LNSUBCSTI2, WNSUBCSTI2, PNSUBCSTI2) 
       `BINNING(UC_NSUBCSTI3, NSUBCSTI3, LNSUBCSTI3, WNSUBCSTI3, PNSUBCSTI3) 
       `BINNING(UC_CGSO, CGSO, LCGSO, WCGSO, PCGSO) 
       `BINNING(UC_CGDO, CGDO, LCGDO, WCGDO, PCGDO) 
       `BINNING(UC_CLM1, CLM1, LCLM1, WCLM1, PCLM1) 
       `BINNING(UC_CLM2, CLM2, LCLM2, WCLM2, PCLM2) 
       `BINNING(UC_CLM3, CLM3, LCLM3, WCLM3, PCLM3) 
       `BINNING(UC_WFC, WFC, LWFC, WWFC, PWFC) 
       `BINNING(UC_GIDL1, GIDL1, LGIDL1, WGIDL1, PGIDL1) 
       `BINNING(UC_GIDL2, GIDL2, LGIDL2, WGIDL2, PGIDL2) 
       `BINNING(UC_GLEAK1, GLEAK1, LGLEAK1, WGLEAK1, PGLEAK1) 
       `BINNING(UC_GLEAK2, GLEAK2, LGLEAK2, WGLEAK2, PGLEAK2) 
       `BINNING(UC_GLEAK3, GLEAK3, LGLEAK3, WGLEAK3, PGLEAK3) 
       `BINNING(UC_GLEAK6, GLEAK6, LGLEAK6, WGLEAK6, PGLEAK6) 
       `BINNING(UC_GLKSD1, GLKSD1, LGLKSD1, WGLKSD1, PGLKSD1) 
       `BINNING(UC_GLKSD2, GLKSD2, LGLKSD2, WGLKSD2, PGLKSD2) 
       `BINNING(UC_GLKB1, GLKB1, LGLKB1, WGLKB1, PGLKB1) 
       `BINNING(UC_GLKB2, GLKB2, LGLKB2, WGLKB2, PGLKB2) 
       `BINNING(UC_NFTRP, NFTRP, LNFTRP, WNFTRP, PNFTRP) 
       `BINNING(UC_NFALP, NFALP, LNFALP, WNFALP, PNFALP) 
       `BINNING(UC_IBPC1, IBPC1, LIBPC1, WIBPC1, PIBPC1) 
       `BINNING(UC_IBPC2, IBPC2, LIBPC2, WIBPC2, PIBPC2) 

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
       `BINNING(UC_JS0D, JS0D, LJS0D, WJS0D, PJS0D) 
       `BINNING(UC_JS0SWD, JS0SWD,  LJS0SWD, WJS0SWD, PJS0SWD) 
       `BINNING(UC_NJD, NJD, LNJD, WNJD, PNJD) 
       `BINNING(UC_CISBKD, CISBKD, LCISBKD, WCISBKD, PCISBKD) 
       `BINNING(UC_VDIFFJD, VDIFFJD, LVDIFFJD, WVDIFFJD, PVDIFFJD) 
       `BINNING(UC_JS0S, JS0S, LJS0S, WJS0S, PJS0S) 
       `BINNING(UC_JS0SWS, JS0SWS,  LJS0SWS, WJS0SWS, PJS0SWS) 
       `BINNING(UC_NJS, NJS, LNJS, WNJS, PNJS) 
       `BINNING(UC_CISBKS, CISBKS, LCISBKS, WCISBKS, PCISBKS) 
       `BINNING(UC_VDIFFJS, VDIFFJS, LVDIFFJS, WVDIFFJS, PVDIFFJS) 
`endif /* End of COEXTDIO */

       // Check the binned parameters 
       if(NSUBC     != UC_NSUBC)     `RANGECHECKFoo( UC_NSUBC    ,  0.0, `inf, "NSUBC@binned")
       if(MUESTI1   != UC_MUESTI1)   `RANGECHECKFco( UC_MUESTI1  ,  0.0, `inf, "MUESTI1@binned")
       if(NSUBPSTI1 != UC_NSUBPSTI1) `RANGECHECKFco( UC_NSUBPSTI1,  0.0, `inf, "NSUBPSTI1@binned")
       if(NSUBCSTI1 != UC_NSUBCSTI1) `RANGECHECKFco( UC_NSUBCSTI1,  0.0, `inf, "NSUBCSTI1@binned")
       if(FATAL_flag) $finish(0);

       if(UC_CORECIP) begin 
          UC_SCP2 = 0.0; UC_SC2 = 0.0; UC_SC4 = 0.0;
                flg_qy = 0;
       end else flg_qy = COQY;

       UC_SC2W = SC2D; // 20180704 Vds-dependent SCE associated with NSUBD. (vertDop)
        
       //-----------------------------------------------------------*
       //* Range check of binning parameters
       //*-----------------//
       if(COERRREP) begin
       if( (UC_VMAX < 1.0e5 || UC_VMAX > 20.0e6) ) $write("warning: (VMAX = %g) range [1.0e5 , 20.0e6].\n",UC_VMAX);
       if( (UC_BGTMP1 < 50.0e-6 || UC_BGTMP1 > 1.0e-3) ) $write("warning: (BGTMP1 = %g) range [50.0e-6 , 1.0e-3].\n",UC_BGTMP1);
       if( (UC_BGTMP2 < -1.0e-6 || UC_BGTMP2 > 1.0e-6) ) $write("warning: (BGTMP2 = %g) range [-1.0e-6 , 1.0e-6].\n",UC_BGTMP2);
       if( (UC_EG0  < 1.0   || UC_EG0  > 1.3  ) ) $write("warning: (EG0 = %g) range [1.0 , 1.3].\n",UC_EG0);
       if(UC_CODEP!=0) begin if( (UC_VFBC < -1.2  || UC_VFBC >  0.8 ) ) $write("warning: (VFBC = %g) range [-1.2 , 0.8].\n",UC_VFBC); end
                  else begin if( (UC_VFBC < -1.2  || UC_VFBC >  0.0 ) ) $write("warning: (VFBC = %g) range [-1.2 , 0.0].\n",UC_VFBC); end
       if( (UC_VFBOVER < -0.2  || UC_VFBOVER > 0.2  ) ) $write("warning: (VFBOVER = %g) range [-0.2 , 0.2].\n",UC_VFBOVER);
       if( (UC_NSUBC < 1.0e16 || UC_NSUBC > 1.0e19) ) $write("warning: (NSUBC = %g) range [1.0e16 , 1.0e19].\n",UC_NSUBC);
       if( (UC_NSUBP < 1.0e16 || UC_NSUBP > 1.0e19) ) $write("warning: (NSUBP = %g) range [1.0e16 , 1.0e19].\n",UC_NSUBP);
       if( (UC_SCP1 < 0.0   || UC_SCP1 > 20.0 ) ) $write("warning: (SCP1 = %g) range [0.0 , 20.0].\n",UC_SCP1);
       if( (UC_SCP2 < 0.0   || UC_SCP2 > 2.0  ) ) $write("warning: (SCP2 = %g) range [0.0 , 2.0].\n",UC_SCP2);
       if( (UC_SCP3 < 0.0   || UC_SCP3 > 100.0e-9) ) $write("warning: (SCP3 = %g) range [0.0 , 100.0e-9].\n",UC_SCP3);
       if( (UC_SC1  < 0.0   || UC_SC1  > 20.0 ) ) $write("warning: (SC1 = %g) range [0.0 , 20.0].\n",UC_SC1);
       if( (UC_SC2  < 0.0   || UC_SC2  > 2.0  ) ) $write("warning: (SC2 = %g) range [0.0 , 2.0].\n",UC_SC2);
       if( (UC_SC3  < 0.0   || UC_SC3  > 200.0e-9) ) $write("warning: (SC3 = %g) range [0.0 , 200.0e-9].\n",UC_SC3);
       if( (UC_PGD1 < 0.0   || UC_PGD1 > 50.0e-3) ) $write("warning: (PGD1 = %g) range [0.0 , 50.0e-3].\n",UC_PGD1);
       if( (UC_NDEP < 0.0   || UC_NDEP > 1.0  ) ) $write("warning: (NDEP = %g) range [0.0 , 1.0].\n",UC_NDEP);
       if( (UC_NINV < 0.0   || UC_NINV > 1.0  ) ) $write("warning: (NINV = %g) range [0.0 , 1.0].\n",UC_NINV);
       if( (UC_MUECB0 < 10.0  || UC_MUECB0 > 100.0e3) ) $write("warning: (MUECB0 = %g) range [10.0 , 100.0e3].\n",UC_MUECB0);
       if( (UC_MUECB1 < 5.0   || UC_MUECB1 > 1.0e4) ) $write("warning: (MUECB1 = %g) range [5.0 , 1.0e4].\n",UC_MUECB1);
       if( (UC_MUEPH1 < 2.0e3 || UC_MUEPH1 > 35.0e3) ) $write("warning: (MUEPH1 = %g) range [2.0e3 , 35.0e3].\n",UC_MUEPH1);
       if( (UC_VTMP < -5.0  || UC_VTMP > 1.0  ) ) $write("warning: (VTMP = %g) range [-5.0 , 1.0].\n",UC_VTMP);
       if( (UC_MUESR1 < 1.0e13 || UC_MUESR1 > 1.0e16) ) $write("warning: (MUESR1 = %g) range [1.0e13 , 1.0e16].\n",UC_MUESR1);
       if( (UC_MUETMP < 0.5   || UC_MUETMP > 2.0  ) ) $write("warning: (MUETMP = %g) range [0.5 , 2.0].\n",UC_MUETMP);
       if( (UC_CLM1 < 0.5   || UC_CLM1 > 1.0  ) ) $write("warning: (CLM1 = %g) range [0.5 , 1.0].\n",UC_CLM1);
       if( (UC_CLM2 < 1.0   || UC_CLM2 > 4.0  ) ) $write("warning: (CLM2 = %g) range [1.0 , 4.0].\n",UC_CLM2);
       if( (UC_CLM3 < 0.5   || UC_CLM3 > 5.0  ) ) $write("warning: (CLM3 = %g) range [0.5 , 5.0].\n",UC_CLM3);
       if( (UC_WFC  < -5.0e-15 || UC_WFC  > 1.0e-6) ) $write("warning: (WFC = %g) range [-5.0e-15 , 1.0e-6].\n",UC_WFC);
       if( (UC_CGSO < 0.0   || UC_CGSO > 100e-9*100*`C_VAC*KAPPA/TOX*`C_m2cm) ) $write("warning: (CGSO = %g) range [0.0 , 100e-9*100*`C_VAC*KAPPA/TOX*C_m2cm].\n",UC_CGSO);
       if( (UC_CGDO < 0.0   || UC_CGDO > 100e-9*100*`C_VAC*KAPPA/TOX*`C_m2cm) ) $write("warning: (CGDO = %g) range [0.0 , 100e-9*100*`C_VAC*KAPPA/TOX*C_m2cm].\n",UC_CGDO);
       if( (UC_IBPC1 < 0.0   || UC_IBPC1 > 1.0e12) ) $write("warning: (IBPC1 = %g) range [0.0 , 1.0e12].\n",UC_IBPC1);
       if( (UC_IBPC2 < 0.0   || UC_IBPC2 > 1.0e12) ) $write("warning: (IBPC2 = %g) range [0.0 , 1.0e12].\n",UC_IBPC2);
       if( (UC_NSTI < 1.0e16 || UC_NSTI > 1.0e19) ) $write("warning: (NSTI = %g) range [1.0e16 , 1.0e19].\n",UC_NSTI);
       end
             
       //-----------------------------------------------------------*
       //* Lg dependence of binning parameters
       //*-----------------//
             
       // Vfbc  //
       UC_VFBC = UC_VFBC *(1.0e0 +(VFBCL / pow(LG, VFBCLP))) ;

               
       //-----------------------------------------------------------*
       //* Conversion to MKS unit for instance parameters.
       //*-----------------//
       MKS_NSUBCDFM  = NSUBCDFM / `C_cm2m_p3 ;
       UC_NSUBC      = UC_NSUBC  / `C_cm2m_p3 ;
       UC_NJUNC      = NJUNC     / `C_cm2m_p3 ; // 20180204 new punchthough
       UC_NSUBP      = UC_NSUBP  / `C_cm2m_p3 ;
       UC_NSTI       = UC_NSTI   / `C_cm2m_p3 ;
       UC_NOVER      = UC_NOVER  / `C_cm2m_p3 ;
       UC_NSUBPSTI1  = UC_NSUBPSTI1 / `C_m2cm ;
       UC_NSUBCSTI1  = UC_NSUBCSTI1 / `C_m2cm ;
       UC_MUESTI1    = UC_MUESTI1 / `C_m2cm ;
       UC_VMAX       = UC_VMAX   / `C_m2cm ;
       UC_WFC        = UC_WFC    * `C_m2cm_p2 ;
       UC_GLKSD1     = UC_GLKSD1 / `C_m2cm ;
       UC_GLKSD2     = UC_GLKSD2 * `C_m2cm ;
       UC_GLEAK2     = UC_GLEAK2 * `C_m2cm ;
       UC_GLKB2      = UC_GLKB2  * `C_m2cm ;
       UC_GIDL1      = UC_GIDL1  / `C_m2cm_p1o2 ;
       UC_GIDL2      = UC_GIDL2  * `C_m2cm ;
       UC_NFALP      = UC_NFALP  / `C_m2cm ;
       UC_NFTRP      = UC_NFTRP  * `C_m2cm_p2 ;
       UC_NFALP1     = ($param_given(NFALP1)) ? NFALP1 / `C_m2cm : UC_NFALP  ;
       UC_NFALP2     = ($param_given(NFALP2)) ? NFALP2 / `C_m2cm : UC_NFALP  ;

       // 
       WLG = WG * LG ;
       UC_MUEPWD = MUEPWD * `C_m2um ;
       UC_MUEPLD = MUEPLD * `C_m2um ;
              
       // Band gap //
       egtnom = UC_EG0 - KTNOM    
              * ( 90.25e-6 + KTNOM * 1.0e-7 ) ;
              
       // C_EOX //
       cecox = `C_VAC * KAPPA ;
             
       // Vth reduction for Small Vds //
       msc = SCP22  ;
           
       // Poly-Si Gate Depletion //
       if( UC_PGD1 == 0.0 ) begin
         flg_pgd = 0 ;
       end else begin
         flg_pgd = 1 ;
       end
               
       // CLM5 & CLM6 //
       clmmod = 1e0 + pow( LG , CLM5 ) * CLM6 ;
              
       // Half length of diffusion //
       T1 = 1.0 / (SAREF + 0.5 * L)
          + 1.0 / (SBREF + 0.5 * L);
       Lod_half_ref = 2.0 / T1 ;
                    
       if(SA > 0.0 && SB > 0.0 &&
         (NF == 1.0 || (NF > 1.0 && SD > 0.0))) begin
         T1 = 0.0;
         for (i = 0; i < NF; i= i + 1) begin
           T1 = T1 + 1.0 / (SA + 0.5 * L
              + i * (SD + L))
              + 1.0 / (SB + 0.5 * L
              + i * (SD + L));
         end
         Lod_half = 2.0 * NF / T1;
       end else begin
         Lod_half = 0.0;
       end
       Npexte = MKS_NPEXT * ( 1.0 + NPEXTW / pow( WG, NPEXTWP ) ); // new //
       EF_MUEPH1 = UC_MUEPH1 ;
       EF_NSUBP  = UC_NSUBP ;
       EF_NSUBC  = UC_NSUBC ;
                 
       // DFM //
       if( CODFM == 1 && NSUBCDFM_GIVEN ) begin
         if(COERRREP&&(NSUBCDFM < 1.0e16 || NSUBCDFM > 1.0e19) ) $write("warning: (NSUBCDFM = %g) range [1.0e16 , 1.0e19].\n",NSUBCDFM);
         EF_MUEPH1 = EF_MUEPH1 * ( MPHDFM
                    *( ln(MKS_NSUBCDFM) - ln(EF_NSUBC) ) + 1.0 ) ;
         EF_NSUBP  = EF_NSUBP  + MKS_NSUBCDFM - EF_NSUBC ;
         Npexte = Npexte + MKS_NSUBCDFM - EF_NSUBC ;
         EF_NSUBC = MKS_NSUBCDFM ;
       end
                
       // WPE //
       T0 = MKS_NSUBCWPE * ( SCA + WEB * SCB + WEC * SCC ) ;
       EF_NSUBC  = EF_NSUBC + T0 ;
       `Fn_SLtemp( EF_NSUBC , EF_NSUBC , `Nsubmin, `Nsubmin_dlt) 
       T0 = MKS_NSUBPWPE * ( SCA + WEB * SCB + WEC * SCC ) ;
       EF_NSUBP  = EF_NSUBP + T0 ;
       `Fn_SLtemp( EF_NSUBP , EF_NSUBP , `Nsubmin, `Nsubmin_dlt) 
       T0 = MKS_NPEXTWPE * ( SCA + WEB * SCB + WEC * SCC ) ;
       Npexte = Npexte + T0 ;
       `Fn_SLtemp( Npexte , Npexte , `Nsubmin, `Nsubmin_dlt) 
       // WPE end //
             
       // Coulomb Scattering //
       UC_MUECB0 = UC_MUECB0 * pow( LG, MUECB0LP );
       UC_MUECB1 = UC_MUECB1 * pow( LG, MUECB1LP );
                 
       // Phonon Scattering(temperature-independent part) //
       mueph = EF_MUEPH1  
             * (1.0e0 + (MUEPHW / pow( WG + UC_MUEPWD , MUEPWP))) 
             * (1.0e0 + (MUEPHL / pow( LG + UC_MUEPLD , MUEPLP))) 
             * (1.0e0 + (MUEPHW2 / pow( WG, MUEPWP2))) 
             * (1.0e0 + (MUEPHL2 / pow( LG, MUEPLP2))) 
             * (1.0e0 + (MUEPHS / pow( WLG, MUEPSP)));  
       if(Lod_half > 0.0) begin
         T1 = 1.0e0 / (1.0e0 + UC_MUESTI2) ;
         T2 = pow (UC_MUESTI1 / Lod_half, UC_MUESTI3) ;
         T3 = pow (UC_MUESTI1 / Lod_half_ref, UC_MUESTI3) ;
         mueph = mueph * (1.0e0 + T1 * T2) / (1.0e0 + T1 * T3); 
       end
             
       // Surface Roughness Scattering //
       muesr = MUESR0 
             *(1.0e0 +(MUESRL / pow(LG, MUESLP))) 
             *(1.0e0 +(MUESRW / pow(WG, MUESWP))) ;
             
       // Coefficients of Qbm for Eeff //
       T1 = pow( LG, NDEPLP ) ;
       T2 = pow( WG, NDEPWP ) ; // new //
       T3 = T1 + NDEPL ;
       T4 = T2 + NDEPW ;
       if( T3 < 1e-8 )  T3 = 1e-8;  
       if( T4 < 1e-8 )  T4 = 1e-8;  
       ndep_o_esi = ( UC_NDEP * T1 ) / T3  * T2 / T4
                  / `C_ESI ;
       ninv_o_esi = UC_NINV / `C_ESI ;
        
       Ninvde = NINVD * ( 1.0 + NINVDL/pow( LG, NINVDLP ) ) ;
       T1 = ( 1.0 + (DEPNINVDL / pow( LG, DEPNINVDLP))) * ( 1.0 + (DEPNINVDW / pow( WG, DEPNINVDWP))) ;
       //NinvdeRES = DEPNINVD * T1 ; // CODEP=3 only
       ninvd0RES  = DEPNINVD * T1 ; // CODEP=3 only (3.0.0 compatible)
       ninvd0cRES = ninvd0RES ; // (3.0.0 compatible)
       ninvd0hRES = ninvd0RES ; // (3.0.0 compatible)
       if ($param_given(DEPNINVDC) || $param_given(DEPNINVDH)) begin
          ninvd0cRES = DEPNINVDC * T1; // (3.0.1 or later) overiding DEPNINVD.
          ninvd0hRES = DEPNINVDH * T1; // (3.0.1 or later) overiding DEPNINVD.
       end 
                   
       // Metallurgical channel geometry //
       dL = XLD  +(MKS_LL / pow(Lgate + LLD, LLN)) ;
       dW = XWD  +(MKS_WL / pow(Wgate + WLD, WLN)) ;
       dLc = XLDC  +(MKS_LL / pow(Lgate + LLD, LLN)) ;
       dWc = XWDC  +(MKS_WL / pow(Wgate + WLD, WLN)) ;          
       Leff    = Lgate - 2.0 * dL ;
       Leff_cv = Lgate - 2.0 * dLc;
       if( Leff <= 1.0e-9 ) begin   
         $write("HiSIM2: MOSFET(%M): An effective channel length is Smaller than 1nm\n");
       end
       if( Leff_cv <= 1.0e-9 ) begin   
         $write("HiSIM2: MOSFET(%M): An effective channel length (capacitance) is Smaller than 1nm\n");
       end
                 
       // Wg dependence for short channel devices //
       lgatesm = Lgate + WL1 / pow( WLG , WL1P ) ;
       dVthsm = UC_WL2 / pow( WLG , WL2P ) ;
              
       // Lg dependence of wsti //
       T1 = 1.0e0 + WSTIL / pow( lgatesm * `C_m2um , WSTILP ) ;
       T2 = 1.0e0 + WSTIW / pow( WG , WSTIWP ) ;
       UC_WSTI = UC_WSTI * T1 * T2 ;
       Weff    = Wgate - 2.0 * dW ;
       Weff_cv = Wgate - 2.0 * dWc ;
        
       if( Weff <= 0.0 ) begin   
         $write("HiSIM2: MOSFET(%M): An effective channel width is negative or 0\n");
       end
       if( Weff_cv <= 0.0 ) begin   
         $write("HiSIM2: MOSFET(%M): An effective channel width (capacitance) is negative or 0\n");
       end
       weff_nf = Weff * NF ;
       weffcv_nf = Weff_cv * NF;
        
       // Surface impurity profile //
       // Nsubp //
       if(UC_NSUBPFAC < 1.0) begin
         T1 = 2.0 * ( 1.0 - UC_NSUBPFAC ) / NSUBPL * LG + 2.0 * UC_NSUBPFAC - 1.0 ;
         `Fn_SUtemp( T1 , T1 , 1 , UC_NSUBPDLT ) 
         `Fn_SLtemp( T1 , T1 , UC_NSUBPFAC  , UC_NSUBPDLT ) 
         EF_NSUBP = EF_NSUBP * T1 ;
       end
                
       // Note: Sign Changed --> //
       Nsubpp = EF_NSUBP   *(1.0e0 +(NSUBPW / pow(WG, NSUBPWP))) ;
       // <-- Note: Sign Changed //
       if(Lod_half > 0.0) begin
         T1 = 1.0e0 / (1.0e0 + UC_NSUBPSTI2) ;
         T2 = pow (UC_NSUBPSTI1 / Lod_half, UC_NSUBPSTI3) ;
         T3 = pow (UC_NSUBPSTI1 / Lod_half_ref, UC_NSUBPSTI3) ;
         Nsubps = Nsubpp * (1.0e0 + T1 * T2) / (1.0e0 + T1 * T3) ;
       end else begin
         Nsubps = Nsubpp ;
       end

       T2 = 1.0e0 + ( NSUBCW / pow ( WG, NSUBCWP )) ;
       T2 = T2 * ( 1.0e0 + ( NSUBCW2 / pow ( WG, NSUBCWP2 )) ) ;
       T3 = MKS_NSUBCMAX / EF_NSUBC ;
       `Fn_SUtemp( T1 , T2 , T3 , 0.01 ) 
       EF_NSUBC = EF_NSUBC * T1 ;

       if(Lod_half > 0.0) begin
         T1 = 1.0e0 / (1.0e0 + UC_NSUBCSTI2) ;
         T2 = pow (UC_NSUBCSTI1 / Lod_half, UC_NSUBCSTI3) ;
         T3 = pow (UC_NSUBCSTI1 / Lod_half_ref, UC_NSUBCSTI3) ;
         EF_NSUBC = EF_NSUBC * (1.0e0 + T1 * T2) / (1.0e0 + T1 * T3) ;
       end

       if( EF_NSUBC <= 0.0 ) begin
         $write("*** warning(HiSIM2): actual NSUBC value is negative -> reset to 1E+15.\n" ) ;
         $write("    The model parameter  NSUBCW/NSUBCWP and/or NSUBCW2/NSUBCW2P might be wrong.\n" ) ;
         EF_NSUBC = 1e15 / `C_cm2m_p3 ;
       end
       if( UC_CODEP == 0 ) begin
         if(COERRREP && (Npexte < EF_NSUBC || Npexte > EF_NSUBP)) begin
           $write("*** warning(HiSIM2): actual NPEXT value is Smaller than NSUBC and/or greater than NSUBP.\n" ) ;
           $write("    ( Npexte = %e , NSUBC = %e , NSUBP = %e ) \n",Npexte,EF_NSUBC,EF_NSUBP);
           $write("    The model parameter  NPEXTW and/or NPEXTWP might be wrong.\n" ) ;
         end
       end
       if( Lgate > LP ) begin
         Nsub = (EF_NSUBC * (Lgate - LP) 
              +  Nsubps  * LP) / Lgate ;
       end else begin
         Nsub = Nsubps
              + (Nsubps - EF_NSUBC) * (LP - Lgate) 
              / LP ;
       end
       T3 = 0.5e0 * Lgate - LP ;
       `Fn_SZtemp( T3 , T3 , `lpext_dlt) 
       T1 = `Fn_Max(0.0e0, LPEXT ) ;
       T3 = T3 * T1 / ( T3 + T1 ) ;
       Nsub = Nsub + T3 * (Npexte - EF_NSUBC) / Lgate ;

       q_Nsub   = `C_QE * Nsub ;
       qnsub_esi = q_Nsub * `C_ESI ;
       qnsub_esi2 = 2.0 * qnsub_esi ;
                  
       // Pocket Overlap(temperature-independent part) //
       if( Lgate <= 2.0e0 * LP ) begin
         Nsubb = 2.0e0 * Nsubps 
               - (Nsubps - EF_NSUBC) * Lgate 
               / LP - EF_NSUBC ;
         ptovr0 = ln (Nsubb / EF_NSUBC) ;
       end else begin
         ptovr0 = 0.0e0 ;
       end
              
       // costi0 and costi1 for STI transistor model(temperature-independent part) //
       costi00 = sqrt (2.0 * `C_QE * UC_NSTI * `C_ESI ) ;
       nsti_p2 = 1.0 / ( UC_NSTI * UC_NSTI ) ;
               
       // Velocity Temperature Dependence(Temperature-dependent part will be multiplied later.) //
       vmax0 =(1.0e0 +(VOVER / pow(LG, VOVERP)))
             *(1.0e0 +(VOVERS / pow(WLG, VOVERSP))) ;
             
       // 2 phi_B(temperature-independent) //
       // @300K, with pocket //
       Pb20 = 2.0e0 / `C_b300 * ln (Nsub / `C_Nin0) ;
       // @300K, w/o pocket //
       Pb2c = 2.0e0 / `C_b300 * ln (EF_NSUBC / `C_Nin0) ;
            
       // constant for Poly depletion //
       cnstpgd = pow( 1e0 + 1e0 / LG , PGD4 ) 
               * UC_PGD1 ;
               
       // Gate resistance //
       if( CORG == 1 ) begin
         T1 = XGW + Weff / (3.0e0 * NGCON);
         T2 = Lgate - XGL;
         grg = RSHG * T1 / (NGCON * T2 * NF);
         if (grg > 1.0e-3) grg = Mfactor / grg;
           else begin
           grg = Mfactor * 1.0e3;
           if(COERRREP)  $write("warning(HiSIM2): The gate conductance reset to 1.0e3 mho.\n");
           end
       end
           
       // Process source/drain series resistance //
       Rde = 0.0;
       if( RSH > 0.0 ) begin
         Rde = Rde + RSH * NRD ;
       end 
       if( RD > 0.0 ) begin
         Rde = Rde + RD / weff_nf ;
       end
       Rse = 0.0;
       if( RSH > 0.0 ) begin
         Rse = Rse + RSH * NRS ;
       end
       if( RS > 0.0 ) begin
         Rse = Rse + RS / weff_nf ;
       end
       Rse = ( Rse < RMIN || CORSRD == 0 ) ? RMIN : Rse ;
       Rde = ( Rde < RMIN || CORSRD == 0 ) ? RMIN : Rde ;
       if(CORSRD < 0) begin
           if( Rde > 0.0 ) begin
           drainConductance = Mfactor / Rde ;
         end else begin
           drainConductance = 0.0;
         end
         if( Rse > 0.0 ) begin
           sourceConductance = Mfactor / Rse ;
         end else begin
           sourceConductance = 0.0;
         end
       end else begin
         drainConductance = 0.0 ;
         sourceConductance = 0.0 ;
       end
                         
       // Body resistance //
       if( CORBNET == 1 ) begin
         if (RBDB < 1.0e-3) grbdb = Mfactor * 1.0e3 ; // in mho //
         else grbdb = Mfactor * ( GBMIN + 1.0 / RBDB ) ;
         if (RBPB < 1.0e-3) grbpb = Mfactor * 1.0e3 ;
         else grbpb = Mfactor * ( GBMIN + 1.0 / RBPB ) ;
         if (RBPS < 1.0e-3) grbps = Mfactor * 1.0e3 ;
         else grbps = Mfactor * ( GBMIN + 1.0 / RBPS ) ;
         if (RBSB < 1.0e-3) grbsb = Mfactor * 1.0e3 ;
         else grbsb = Mfactor * ( GBMIN + 1.0 / RBSB ) ;
         if (RBPD < 1.0e-3) grbpd = Mfactor * 1.0e3 ;
         else grbpd = Mfactor * ( GBMIN + 1.0 / RBPD ) ;
       end
                         
       // Vdseff //
       if( CODDLT==0 ) begin
         T1 = DDLTSLP * LG + DDLTICT ;
         DDLTe = T1 * DDLTMAX / ( T1 + DDLTMAX ) + 1.0 ;
       end else begin
         T1 = DDLTSLP * LG ;
         DDLTe = T1 * DDLTMAX / ( T1 + DDLTMAX ) + DDLTICT + `Small ;
       end
            
       // Isub //
       T2 = pow( Weff , SVGSWP ) ;
       vg2const = UC_SVGS
                * ( 1.0e0
                + MKS_SVGSL / pow( Lgate , SVGSLP ) )
                * ( T2 / ( T2 + MKS_SVGSW ) ) ; 
       xvbs = UC_SVBS  * ( 1.0e0 + MKS_SVBSL / pow( Lgate , SVBSLP ) ) ;
       xgate = MKS_SLG * ( 1.0 + MKS_SLGL  / pow( Lgate , SLGLP ) ) ;
       xsub1 = UC_SUB1 * ( 1.0 + MKS_SUB1L / pow( Lgate , SUB1LP ) ) ;
       xsub2 = UC_SUB2 * ( 1.0 + MKS_SUB2L / Lgate ) ;
             
       // Fringing capacitance //
       cfrng = `C_EOX / ( `C_Pi / 2.0e0 ) * weffcv_nf 
             * ln( 1.0e0 + TPOLY / TOX ) ; 
             
       // Additional term of lateral-field-induced capacitance //
       cqyb0 = `C_m2um * weffcv_nf * XQY1 / pow( LG , XQY2 ) ;
             
       // Parasitic component of the channel current //
       UC_GDLD = GDLD * `C_m2um ;
       ptl0 = PTL * pow( LG        , - PTLP ) ;
       pt40 = PT4 * pow( LG        , - PT4P ) ;
       gdl0 = GDL * pow( LG + UC_GDLD , - GDLP ) ;
            
       //-----------------------------------------------------------*
       //* Temperature dependent constants. 
       //*-----------------//
       TTEMP = $temperature + DTEMP ;
             
       // Band gap //
       Tdiff = TTEMP -  KTNOM ;
       T2 = TTEMP * TTEMP - KTNOM * KTNOM ;
       Eg = egtnom - UC_BGTMP1 * Tdiff - UC_BGTMP2 * T2 ;
       T1 = 1.0 / TTEMP ;
       T2 = 1.0 / KTNOM ;
       T3 = egtnom + EGIG
          + IGTEMP2 * ( T1 - T2 )
          + IGTEMP3 * ( T1 * T1 - T2 * T2 ) ;
       Egp12 = sqrt ( T3 ) ;
       Egp32 = T3 * Egp12 ;
             
       // Inverse of the thermal voltage //
       beta  = `C_QE / (`C_KB * TTEMP) ;
       beta_inv = 1.0 / beta ;
       beta2 = beta * beta ;
       betatnom = `C_QE / (`C_KB * KTNOM) ;

       Tratio = TTEMP / KTNOM ;
       log_Tratio = ln(Tratio) ;
                
       // Intrinsic carrier concentration //
       Nin = `C_Nin0 * pow(Tratio, 1.5e0)
           * exp(- Eg / 2.0e0 * beta + egtnom / 2.0e0 * betatnom) ;
             
       // Phonon Scattering(temperature-dependent part) //
       T1 =  pow (Tratio, UC_MUETMP) ;
       mphn0 = T1 / mueph ;

             
       // Pocket Overlap(temperature-dependent part) //
       ptovr = ptovr0 / beta ;
             
       // Velocity Temperature Dependence //
       VMAXeff = vmax0 * UC_VMAX 
               / (1.8 + 0.4 * Tratio + 0.1 * Tratio * Tratio - UC_VTMP * (1.0e0 - Tratio)) ;
               
`ifdef _AGING_
       // Trap Temperature Dependence //
       Tdiff_2 = TTEMP * TTEMP - KTNOM * KTNOM ;
       Nt0s_temp  = TRAPTEMP1 * Tdiff + TRAPTEMP2 * Tdiff_2 ;
`endif
        
       // Coefficient of the F function for bulk charge //
       if( UC_CODEP != 0 ) begin
         // depletion MOS  //
         T3 = pow( LG, NDEPMLP ) ;
         UC_NDEPM = UC_NDEPM*(1.0+NDEPML/T3) ;
         if( UC_NDEPM < 1e21 ) UC_NDEPM = 1e21 ;

         if ( UC_CODEP == 1  ) begin
           cnst0 = sqrt ( 2.0 * `C_ESI * `C_QE * UC_NDEPM / beta ) ;
         end else begin  // Bugfix in 2.9.0
           q_Nsub   = `C_QE * UC_NDEPM ;
           qnsub_esi = q_Nsub * `C_ESI ;
           qnsub_esi2 = 2.0 * qnsub_esi ;
           cnst0 = sqrt ( qnsub_esi2 / beta ) ;
         end

         cnst1 = Nin*Nin/UC_NDEPM/UC_NDEPM ;
         Pb2n =  2.0e0 / beta * ln (UC_NDEPM / Nin) ;
         Vbipn = 1.0/beta*ln(UC_NDEPM*EF_NSUBC/Nin/Nin) ;
         T1 =  pow (Tratio, DEPMUETMP) ;
         depmphn0 = T1/DEPMUEPH1 ;

         T0 = ($param_given(DEPVTMP)) ? 1.8 + 0.4 * Tratio + 0.1 * Tratio * Tratio - DEPVTMP * ( 1.0 - Tratio ) : 1.0 ;
         UC_DEPVMAX = DEPVMAX / T0 / `C_m2cm ;

         // LG dependence DEPVMAX
         T3 = pow( LG,  DEPVMAXLP ) ;
         UC_DEPVMAX = UC_DEPVMAX * (1.0 + DEPVMAXL / T3) ;

         //LG dependence DEPLEAK  
         T3 = pow( LG,  DEPLEAKLP ) ;
         UC_DEPLEAK = DEPLEAK * (1.0 + DEPLEAKL / T3) ;
         if( UC_DEPLEAK < 0.0 ) UC_DEPLEAK = 0.0 ;

         // LG dependence DEPMUE0 & DEPMUE1
         T3 = pow( LG,  DEPMUE0LP ) ;
         UC_DEPMUE0 = DEPMUE0 * (1.0 + DEPMUE0L / T3) ;
         if( UC_DEPMUE0 < 1.0 ) UC_DEPMUE0 = 1.0 ;
         T3 = pow( LG,  DEPMUE1LP ) ;
         UC_DEPMUE1 = DEPMUE1 * (1.0 + DEPMUE1L / T3) ;
         if( UC_DEPMUE1 < 0.0 ) UC_DEPMUE1 = 0.0 ;

         // LG dependence DEPMUEBACK0 & DEPMUEBACK1
         T3 = pow( LG,  DEPMUEBACK0LP ) ;
         UC_DEPMUEBACK0 = DEPMUEBACK0 * (1.0 + DEPMUEBACK0L / T3) ;
         if( UC_DEPMUEBACK0 < 0.0 ) UC_DEPMUEBACK0 = 0.0 ;
         T3 = pow( LG,  DEPMUEBACK1LP ) ;
         UC_DEPMUEBACK1 = DEPMUEBACK1 * (1.0 + DEPMUEBACK1L / T3) ;
         if( UC_DEPMUEBACK1 < 0.0 ) UC_DEPMUEBACK1 = 0.0 ;

         // LG dependence DEPVDSEF1 & DEPVDSEF2
         T3 = pow( LG,  DEPVDSEF1LP ) ;
         UC_DEPVDSEF1 = UC_DEPVDSEF1 * (1.0 + DEPVDSEF1L / T3) ;
         T3 = pow( LG,  DEPVDSEF2LP ) ;
         UC_DEPVDSEF2 = UC_DEPVDSEF2 * (1.0 + DEPVDSEF2L / T3) ;
         if( UC_DEPVDSEF2 < 0.1 ) UC_DEPVDSEF2 = 0.1 ;

         // Temp. dependence of DEPMUE0 & DEPMUE2
         UC_DEPMUE0 = UC_DEPMUE0 / pow (Tratio, DEPMUE0TMP) ;
         UC_DEPMUE2 =    DEPMUE2 / pow (Tratio, DEPMUE2TMP) ;
          
         if ($param_given(DEPNINVD)) begin
             NinvdecRES = ninvd0RES;
             NinvdehRES = ninvd0RES;
         end
         else begin
            NinvdecRES = ninvd0cRES;
            NinvdehRES = ninvd0hRES;
         end
       end else begin
         // normal MOS  //
         cnst0 = sqrt ( 2.0 * `C_ESI * `C_QE * Nsub / beta ) ;
         // cnst1: n_{p0} / p_{p0} //
         T1 = Nin / Nsub ;
         cnst1 = T1 * T1 ;
         Pb2n  = 0.0 ;
         Vbipn = beta_inv * ln(UC_NJUNC/Nin * Nsub/Nin); //  All conc here in 1/m^3.
         
         depmphn0 = 0.0 ;
         UC_DEPLEAK = 0.0 ; 
         UC_DEPMUE0 = 0.0 ; UC_DEPMUE1 = 0.0 ;
         UC_DEPVMAX = 0.0 ; UC_DEPMUE2 = 0.0 ;
         UC_DEPVDSEF1 = 0.0 ; UC_DEPVDSEF2 = 0.0 ;
         UC_DEPMUEBACK0 = 0.0 ; UC_DEPMUEBACK1 = 0.0 ;

         NinvdecRES = 0.0;
         NinvdehRES = 0.0; 
       end
                 
       // 2 phi_B(temperature-dependent) //
       // @temp, with pocket //
       Pb2 = 2.0e0 / beta * ln (Nsub / Nin) ;
       if( UC_NOVER != 0.0) begin
         cnst0over = sqrt( 2.0 * `C_ESI * `C_QE * UC_NOVER / beta ) ;     
       end else begin
         cnst0over = 0.0 ;
       end
               
       // Depletion Width //
       C2_esi_p_q = 2.0e0 * `C_ESI / `C_QE ;
       wdpl = sqrt ( C2_esi_p_q / Nsub ) ;
       wdplp = sqrt( C2_esi_p_q / EF_NSUBP ) ; 
             
                
       // costi0 and costi1 for STI transistor model(temperature-dependent part) //
       costi0 = costi00 * sqrt(beta_inv) ;
       costi0_p2 = costi0 * costi0 ; 
       costi1 = Nin * Nin * nsti_p2 ;

       // check if SC3 is too large //
       if(UC_SC3 && SC3VBS < 0.0) begin
                
`ifdef _AGING_
         Vfb      = UC_VFBC + V(dVfb)  + TRAPDVTH ;
`else
         Vfb      = UC_VFBC ;
`endif
         c_eox    = cecox ;
         Toxe     = TOX ;
         Cox      = c_eox / Toxe ;
         Cox_inv  = 1.0 / Cox ;
         fac1     = cnst0 * Cox_inv ;
         Vgs_min  = TYPE * VGSMIN ;
         sc3Vgs   = 2.0 ;
         Ps0_min  = 2.0 * beta_inv * ln (-Vgs_min/fac1) ;
                  
         // approximate solution of Poisson equation for large
         //Vgs and negative Vbs(3 iterations!)//
         Vgp = sc3Vgs - Vfb;
         Denom = fac1*sqrt(cnst1);
         Ps0 = 2.0 * beta_inv * ln (Vgp/Denom);
         Ps0 = 2.0 * beta_inv * ln ((Vgp-Ps0)/Denom);
         Ps0 = 2.0 * beta_inv * ln ((Vgp-Ps0)/Denom);
         Ps0 = 2.0 * beta_inv * ln ((Vgp-Ps0)/Denom);
         Ps0dVbs = 0.0;
         T1   = qnsub_esi2 ;
         Qb0  = sqrt ( T1 ) ;
         Vthp = Ps0 + Vfb + Qb0 * Cox_inv + ptovr ;
         T1   = 2.0 * `C_QE * EF_NSUBC * `C_ESI ;
         T2   = sqrt( T1 ) ;
         Vth0 = Ps0 + Vfb + T2 * Cox_inv ;
         T1   = `C_ESI * Cox_inv ;
         T2   = wdplp ;
         T4   = 1.0e0 / ( LP * LP ) ;
         T3   = 2.0 * ( VBI - Pb20 ) * T2 * T4 ;
         T5   = T1 * T3 ;
         T6   = Ps0 - SC3VBS ;
         T6dVb = Ps0dVbs - 1.0 ;
         dVth0 = T5 * sqrt( T6 ) ;
         dVth0dVb = T5 * 0.5 / sqrt( T6 ) * T6dVb;
         T1   = Vthp - Vth0 ;
         T9   = Ps0 - SC3VBS ;
         T9dVb = Ps0dVbs - 1.0 ;
         T3   = UC_SCP1 + UC_SCP3 * T9 / LP;
         T3dVb = UC_SCP3 * T9dVb / LP ;
         dVthLP = T1 * dVth0 * T3 ;
         dVthLPdVb = T1 * dVth0dVb * T3 + T1 * dVth0 * T3dVb;
         T3 = Lgate - PARL2 ;
         T4 = 1.0e0 / ( T3 * T3 ) ;
         T0 = `C_ESI * wdpl * 2.0e0 * ( VBI - Pb20 ) * T4 ;
         T2 = T0 * Cox_inv ;
         T5 = UC_SC3 / Lgate ;
         T6 = UC_SC1 + T5 * ( Ps0 - SC3VBS ) ;
         T1 = T6 ;
         A  = T2 * T1 ;
         T9 = Ps0 - SC3VBS + Ps0_min ;
         T9dVb = Ps0dVbs - 1.0 ;
         T8 = sqrt( T9 ) ;
         T8dVb = 0.5 * T9dVb / T8 ;
         dVthSC = A * T8 ;
         T1 = 1.0 / Cox ;
         T3 = 1.0 / ( Cox + UC_WFC / Weff_cv ) ;
         T5 = T1 - T3 ;
         dVthW = Qb0 * T5 + UC_WVTH0 / WG ;
         dVth = dVthSC + dVthLP + dVthW + dVthsm ;
         dPpg = 0.0 ;
         Vgp = sc3Vgs - Vfb + dVth - dPpg ;
             
         // Recalculation of Ps0, using more accurate Vgp //
         Ps0 = 2.0 * beta_inv * ln (Vgp/Denom);
         Ps0 = 2.0 * beta_inv * ln ((Vgp-Ps0)/Denom);
         Ps0 = 2.0 * beta_inv * ln ((Vgp-Ps0)/Denom);
         Ps0 = 2.0 * beta_inv * ln ((Vgp-Ps0)/Denom);
         term1 = Vgp - Ps0;
         term2 = sqrt(beta*(Ps0-SC3VBS)-1.0);
         term3 = term1 + fac1 * term2;
         term4 = cnst1 * exp(beta*Ps0);
         limVgpdVbs = - beta * (term3 + 0.5*fac1 * term4/term2)
                    / (2.0*term1/fac1/fac1*term3 - term4);
         T2     = T0 * Cox_inv ;
         sc3lim = Lgate / T2 
                * (limVgpdVbs - dVthLPdVb - T2*UC_SC1*T8dVb)
                / ((Ps0-SC3VBS)*T8dVb +(Ps0dVbs-1.0)*T8);
         if(sc3lim < 1.0e-20)
            sc3lim = 1e-20 ;
         if(sc3lim < UC_SC3 * 0.999) 
            UC_SC3 = sc3lim;
       end
       // 
     end // initializeInstance
            
//   Initial Setting for hidden states. 
     begin
       Vth        = 0.0 ;
       fac1       = 0.0 ;
       Vdseff     = 0.0 ;
       Rdd        = 0.0;
       Rsd        = 0.0;
       start_of_loopl = 0;
       start_of_mobility = 0;
       flg_ign    = 0;
       flg_noqi   = 0;
       flg_rsrd   = 0;
       tau        = 0.0;
       taub       = 0.0;
       Alpha      = 0.0;
       Ec         = 0.0;
       FD2        = 0.0;
       Fs0_dPs0   = 0.0;
       Idd        = 0.0;
       Lch        = 0.0;
       Lred       = 0.0;
       Mud_hoso   = 0.0;
       Muun       = 0.0;
       PS0Z_SCE   = 0.0;
       Pds_ini    = 0.0;
       Ps0        = 0.0;
       Ps0_ini    = 0.0;
       Ps0z       = 0.0;
       Psdl       = 0.0;
       Psl        = 0.0;
       Psl_lim    = 0.0;
       Qb_nqs     = 0.0;
       Qi_nqs     = 0.0;
       Vthp_dPS0Z = 0.0;
       Xi0        = 0.0;
       Xi0p12     = 0.0;
       wk_Xi0p12  = 0.0;
       Xi0p32     = 0.0;
       Xil        = 0.0;
       Xilp12     = 0.0;
       Xilp32     = 0.0;
       betaWL     = 0.0;
       codqb      = 0.0;
       crl_f      = 0.0;
       dVthLP_dPS0Z = 0.0;
       dVthSC_dPS0Z = 0.0;
       fb         = 0.0;
       flg_conv   = 0;
       gds0_ign   = 0.0;
       kusai00    = 0.0;
       kusai00L   = 0.0;
       kusaiL     = 0.0;
       kusai_ig   = 0.0;
       mm         = 0.0;
       sqrtkusaiL = 0.0;
       flg_zone   = 0;
       Qb0Cox     = 0.0;

       Vbs_max    = 0.8e0;
       Vbs_bnd    = 0.4e0;

       dVbsc      = 1.0;
       Pds        = 0.0;
       VgVt       = 0.0;
       Qbu        = 0.0;
       Qiu        = 0.0;
       Qn0        = 0.0e0;
       Qdrat      = 0.5;
       Mu         = 0.0;
       Ey         = 0e0;
       Qgos       = 0.0;
       Qgod       = 0.0;
       Qovd       = 0.0;
       Qovs       = 0.0;
       QbdLD      = 0.0;
       QbsLD      = 0.0;
       IdsIBPC    = 0.0;
       Ta         = 9.3868e-3;
       Tb         = -0.1047839;
       arg0       = 0.01;
       arg2       = qnsub_esi2*1.0e-4;
       START_OF_SCE_LOOP = 1;
       end_of_part_1 = 0 ;
       PS0_SCE_tol = 4.0e-7;

       Vgp       = 0.0 ;
       Vgpz      = 0.0 ;
       Vgp_dPS0Z = 0.0 ;
       Vbsz      = 0.0 ;
       Vdsz      = 0.0 ;
       Vgsz      = 0.0 ;
       Vbsz2     = 0.0 ;
       Pb20b     = 0.0 ;
       sqrt_Pbsum = 0.0 ;
       Qb0       = 0.0 ;
       Qiu_noi   = 0.0 ;
       Chi       = 0.0 ;
       dVth      = 0.0 ;
       dVthSC    = 0.0 ;
       dVthLP    = 0.0 ;
       dPpg      = 0.0 ;
       Cox       = 0.0 ;
       Cox_inv   = 0.0 ;
       FMDVDS    = 0.0 ;
       fs01      = 0.0 ;
       fs02      = 0.0 ;
       Fsl_dPsl  = 0.0 ;
       Ids_acc   = 0.0 ;
       Ids_res   = 0.0 ;
       W_res     = 0.0 ;

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
     js         = 0.0;
     jssw       = 0.0;
     js2        = 0.0;
     jssw2      = 0.0;
     Ibs        = 0.0;
     Gbs        = 0.0;
     Ibd        = 0.0;
     Gbd        = 0.0;
     Ibsi       = 0.0;
     Ibdi       = 0.0;
     Qbs        = 0.0;
     Qbd        = 0.0;
     Qbsi       = 0.0;
     Qbdi       = 0.0;
     czbd       = 0.0;
     czbdsw     = 0.0;
     czbdswg    = 0.0;
     czbs       = 0.0;
     czbssw     = 0.0;
     czbsswg    = 0.0;
     sarg       = 0.0;
     vsbs       = 0.0;
     vdbd       = 0.0;
     vbs_jct    = 0.0;
     vbd_jct    = 0.0;
     vbpsp      = 0.0;
     vbpdp      = 0.0;
     vbsi_jct   = 0.0;
     vbdi_jct   = 0.0;
     Capbd      = 0.0;
     Capbs      = 0.0;
     exptempd   = 0.0;
     exptemps   = 0.0;
     isbd       = 0.0;
     isbs       = 0.0;
     jd_expcd   = 0.0;
     jd_expcs   = 0.0;
     vbdt       = 0.0;
     vbst       = 0.0;
     jd_nvtm_invd  = 0.0;
     jd_nvtm_invs  = 0.0;
`endif /* End of COEXTDIO */

       IdsPT     = 0.0 ;
       IdsPT0    = 0.0 ;
       IdsPT1    = 0.0 ;
       dVthVert  = 0.0 ;
       dVthVerts = 0.0 ;
       dVthVertd = 0.0 ;
       dVSFTDsc  = 0.0 ;

     end
                 
     flg_nqs  = CONQS ;
              
     if(INFO >= 4) begin
       $write("//******* DEVICE PARAMETERS ***********//\n");
       $write("  L          = %12.5e  W          = %12.5e  TYPE       = %d\n"    ,L       ,W      ,TYPE);
       $write("  NRD        = %12.5e  NRS        = %12.5e  NGCON      = %12.5e\n",NRD     ,NRS    ,NGCON);
       $write("  XGW        = %12.5e  XGL        = %12.5e  NF         = %12.5e\n",XGW     ,XGL    ,NF); 
       $write("  SA         = %12.5e  SB         = %12.5e  SD         = %12.5e\n",SA      ,SB     ,SD);
       $write("  DTEMP      = %12.5e  M          = %12.5e  NSUBCDFM   = %12.5e\n",DTEMP   ,mMod   ,NSUBCDFM);

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
         $write("  AD         = %12.5e  PD         = %12.5e\n",AD      ,PD);
         $write("  AS         = %12.5e  PS         = %12.5e\n",AS      ,PS);
`endif /* End of COEXTDIO */

       $write("//******* FLAG PARAMETERS *************//\n");
       $write("  CORSRD     = %d  CORG       = %d  COIPRV     = %d\n",CORSRD ,CORG   ,COIPRV);
       $write("  COPPRV     = %d  COADOV     = %d  COISUB     = %d\n",COPPRV ,COADOV ,COISUB);
       $write("  COIIGS     = %d  COGIDL     = %d  COOVLP     = %d\n",COIIGS ,COGIDL ,COOVLP);
       $write("  CODFM      = %d  COFLICK    = %d  COISTI     = %d\n",CODFM  ,COFLICK,COISTI);
       $write("  CONQS      = %d  COTHRML    = %d  COIGN      = %d\n",CONQS  ,COTHRML,COIGN );
       $write("  CODFM      = %d  CORBNET    = %d                 \n",CODFM  ,CORBNET       );
       $write("//******* TECHNOLOGY PARAMETERS *******//\n");
       $write("  VERSION    = %.2f \n"                               ,VERSION );
       $write("  gminMod    = %12.5e  mMod       = %12.5e  \n"       ,gminMod ,mMod);
     end // end of printing


`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
//=============================== `include "HSM2_temp_eval_dio.inc" =============================== BEGIN


T0 = Tratio * Tratio ;


// for substrate-drain junction diode. //
`HSM2_Idio_args1(js,     UC_JS0D,    XTID,  UC_NJD)
`HSM2_Idio_args1(jssw,   UC_JS0SWD,  XTID,  NJSWD)
`HSM2_Idio_args1(jsswg,  JS0SWGD,    XTID,  NJSWGD)
`HSM2_Idio_args1(js2,    UC_JS0D,    XTI2D, UC_NJD)
`HSM2_Idio_args1(jssw2,  UC_JS0SWD,  XTI2D, NJSWD)
`HSM2_Idio_args1(jsswg2, JS0SWGD,    XTI2D, NJSWGD)

if ( CODIO > 0 ) begin //new model:
   `HSM2_Idio_args2(isbd_btm, isbd2_btm, isbd_sws, isbd2_sws, isbd_swg, isbd2_swg, PD, AD)
end else begin //backward compatible:
   `HSM2_Idio_args2_compat(isbd_btm, isbd2_btm, isbd_sws, isbd2_sws, isbd_swg, isbd2_swg, PD, AD)
end
isbd = isbd_btm + isbd_sws + isbd_swg ;

if( isbd > 0 ) begin
   T2 = isbd + `Small ; //once removed in Geoffrey01_Small_20160309, but necessary for backward compatibility
   vbdt = UC_NJD / beta * ln( UC_VDIFFJD * T0 / T2 + 1.0 ) ;
   exptempd = exp (( Tratio - 1.0 ) * CTEMPD ) ;
   jd_nvtm_invd = 1.0 / ( UC_NJD / beta ) ;
   jd_expcd = exp (vbdt * jd_nvtm_invd ) ;
end


// for substrate-source junction diode. //
`HSM2_Idio_args1(js,     UC_JS0S,    XTIS,  UC_NJS)
`HSM2_Idio_args1(jssw,   UC_JS0SWS,  XTIS,  NJSWS)
`HSM2_Idio_args1(jsswg,  JS0SWGS,    XTIS,  NJSWGS)
`HSM2_Idio_args1(js2,    UC_JS0S,    XTI2S, UC_NJS)
`HSM2_Idio_args1(jssw2,  UC_JS0SWS,  XTI2S, NJSWS)
`HSM2_Idio_args1(jsswg2, JS0SWGS,    XTI2S, NJSWGS)

if ( CODIO > 0 ) begin //new model:
   `HSM2_Idio_args2(isbs_btm, isbs2_btm, isbs_sws, isbs2_sws, isbs_swg, isbs2_swg, PS, AS)
end else begin //backward compatible:
   `HSM2_Idio_args2_compat(isbs_btm, isbs2_btm, isbs_sws, isbs2_sws, isbs_swg, isbs2_swg, PS, AS)
end
isbs = isbs_btm + isbs_sws + isbs_swg ;

if( isbs > 0 ) begin
   T3 = isbs + `Small ; //once removed in Geoffrey01_Small_20160309, but necessary for backward compatibility
   vbst = UC_NJS / beta * ln( UC_VDIFFJS * T0 / T3 + 1.0 ) ;
   exptemps = exp (( Tratio - 1.0 ) * CTEMPS ) ;
   jd_nvtm_invs = 1.0 / ( UC_NJS / beta ) ;
   jd_expcs = exp (vbst * jd_nvtm_invs ) ;
end


//-----------------------------------------------------------*
//* Charges and Capacitances.
//*-----------------//
      
// Drain Bulk Junction //
`HSM2_Qdio_args1(czbd, czbdsw, czbdswg, PD, AD, CJD, TCJBD, CJSWD, TCJBDSW, CJSWGD, TCJBDSWG)

// Source Bulk Junction //
`HSM2_Qdio_args1(czbs, czbssw, czbsswg, PS, AS, CJS, TCJBS, CJSWS, TCJBSSW, CJSWGS, TCJBSSWG)

// end of HSM2temp_eval_dio.h //
//=============================== `include "HSM2_temp_eval_dio.inc" =============================== END
`endif /* End of COEXTDIO */

              
//   get biases from CKT //
     ivds = TYPE * V(BRdpsp) ;
     ivgs = TYPE * V(BRgpsp) ;
     ivbs = TYPE * V(BRbpsp) ;
             
`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
     vsbs = TYPE * V(BRsbs ) ;
     vdbd = TYPE * V(BRdbd ) ;
     vbpsp = TYPE * V(BRbpsp ) ;
     vbpdp = TYPE * V(BRbpdp ) ;
     vbs_jct = vsbs;
     vbd_jct = vdbd;
     vbsi_jct = vbpsp;
     vbdi_jct = vbpdp;
`endif /* End of COEXTDIO */

     if(ivds >= 0)  begin  // normal mode //
       mode = 1;
       ModeNML = 1.0 ;
       ModeRVS = 0.0 ;
       ivds  = ivds ;
       ivgs  = ivgs ;
       ivbs  = ivbs ;
     end  else  begin     // reverse mode //
       mode = -1;
       ModeNML = 0.0 ;
       ModeRVS = 1.0 ;
       ivgd = ivgs -ivds ;
       ivbd = ivbs -ivds ;
       ivds  = -ivds ;
       ivgs  =  ivgd ;
       ivbs  =  ivbd ;
     end
           
     if( INFO >= 5 )  begin  // mode, bias conditions ... //
       $write( "--- variables given to HSM2evaluate() ----\n" );
       $write( "TYPE   = %d\n" , TYPE );
       $write( "mode   = %d\n" , mode );
       $write( "ivbs   = %.10e \n" , ivbs );
       $write( "ivds   = %.10e \n" , ivds );
       $write( "ivgs   = %.10e \n" , ivgs );

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
       $write( "vbsj vbdj   = %20.10e %20.10e\n" , vbs_jct, vbd_jct );
`endif /* End of COEXTDIO */

     end
           
     if( INFO >= 6 )  begin  // input flags //
       $write( "corsrd  = %d\n" , CORSRD );
       $write( "coadov  = %d\n" , COADOV );
       $write( "coisub  = %d\n" , COISUB );
       $write( "coiigs  = %d\n" , COIIGS );
       $write( "cogidl  = %d\n" , COGIDL );
       $write( "coovlp  = %d\n" , COOVLP );
       $write( "coflick = %d\n" , COFLICK );
       $write( "coisti  = %d\n" , COISTI );
       $write( "conqs   = %d\n" , CONQS  );
       $write( "cothrml = %d\n" , COTHRML );
       $write( "coign   = %d\n" , COIGN );
     end
           
//start_of_evaluation;

     // Flat band voltage //
`ifdef _AGING_
     Vfb = UC_VFBC + V(dVfb) + TRAPDVTH ;
`else
     Vfb = UC_VFBC ;
`endif
         
     // Velocity Temperature Dependence //
     Vmaxe = VMAXeff ;
          
     // c_eox: Permittivity in ox  //
     c_eox = cecox ;
           
     // Tox and Cox without QME //
     Tox0 = TOX ;
     Cox0 = c_eox / Tox0 ;
     Cox0_inv = 1.0 / Cox0 ;
     Cox0ov = c_eox / TOXOV ;
     Cox0ov_inv = 1.0 / Cox0ov ;
              
     // for calculation of Ps0_min //
     Vgs_min = TYPE * VGSMIN ;
             
     //-----------------------------------------------------------*
     //* Exchange bias conditions according to MOS type.
     //* - Vxse are external biases for HiSIM. ( type=NMOS , Vds >= 0
     //*   are assumed.)
     //*-----------------//
     Vbse = ivbs ;
     Vdse = ivds ;
     Vgse = ivgs ;

     //---------------------------------------------------*
     //* Clamp too large biases.
     //* -note: Quantities are extrapolated in PART-5.
     //*-----------------//
     if( Pb2 - VZADD0 < Vbs_max ) begin
       Vbs_max = Pb2 - VZADD0 ;
     end
     if( Pb20 - VZADD0 < Vbs_max ) begin
       Vbs_max = Pb20 - VZADD0 ;
     end
     if( Pb2c - VZADD0 < Vbs_max ) begin
       Vbs_max = Pb2c - VZADD0 ;
     end
     if( Vbs_bnd > Vbs_max * 0.5 ) begin
       Vbs_bnd = 0.5 * Vbs_max ;
     end
     if( Vbse > Vbs_bnd ) begin
       T1 = Vbse - Vbs_bnd ;
       T2 = Vbs_max - Vbs_bnd ;
       `Fn_SUPoly4( TY , T1 , T2 , dVbsc ) 
       Vbsc = Vbs_bnd + TY ;
     end  else if( Vbse < `Vbs_min ) begin
       Vbsc = `Vbs_min ;
       dVbsc = 1.0 ;
     end  else begin
       Vbsc = Vbse ;
       dVbsc = 1.0 ;
     end
     Vdsc = Vdse ;
     Vgsc = Vgse ;
     if(Rse > 0.0 || Rde > 0.0) begin
       if ( CORSRD == 1 ) flg_rsrd  = 1 ;
       if ( CORSRD == 2 ) flg_rsrd  = 2 ;
     end
          
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //* PART-1: Basic device characteristics.
     //*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
     flg_pprv = 0 ;
     Rdd  = Rde ;
     Rsd  = Rse ;
     Ids = 0.0 ;
     Vbs = Vbsc ;
     Vds = Vdsc ;
     Vgs = Vgsc ;

`ifdef _AGING_
     //-----------------------------------------------------------*
     //* initilization for Trap simulation.
     //*-----------------//
     if( TRAPGC1MAX == 0 ) begin
       nt0s      = 0.0 ;
       ntls      = 0.0 ;
     end else begin
       NtK10     = 0.0 ;
       NtK20     = 0.0 ;
       keT       = `C_KB / `C_QE * TTEMP ;
       Qt0       = 0.0;
       pretime0  = (DEGTIME0 > 0 ) ? DEGTIME0 * 0.01 : `pretime ;
       //*-----------------//
       Nt_max0 = 0.0 ; 
       Nt_maxl = 0.0 ;
       MKS_TRAPGC0 = TRAPGC0 / `C_cm2m_p3 ; 
       MKS_TRAPGCLIM = TRAPGCLIM / `C_cm2m_p3 ;
       MKS_TRAPGC2 = TRAPGC2 / `C_cm2m_p3 ;
       MKS_GC1MAX  = TRAPGC1MAX / `C_cm2m_p3 ;
       `Fn_calcNKT(NtK20,MKS_TRAPGC2,TRAPES2) 
       `Fn_calcNKT(NtK30,MKS_TRAPGC0,TRAPES0) 
       `Fn_calcNKT(NtK40,MKS_TRAPGCLIM,TRAPESLIM) 

       //---------------------------------------------------*
       //* Trap estimation.
       //*-----------------//
       if( analysis("tran") == 0 ) begin
         Ps0_prv     = V(ps0) ;
         Vtraplx_prv = V(vtraplx) ;
       end 
       if ( CODEG == 1 ) begin // update NtK10 
         if( CODEGSTEP == 0 ) begin
            MKS_TRAPGC1 = V(vgc1) * 1e24 ;
            MKS_TRAPES1 = V(ve1) ;
         end else begin
            MKS_TRAPGC1 = gc1 ;
            MKS_TRAPES1 = e1  ;
         end
       end else begin
         MKS_TRAPGC1 = TRAPGC1 / `C_cm2m_p3 ;
         MKS_TRAPES1 = TRAPES1 ;
       end
       `Fn_SL(MKS_TRAPES1, MKS_TRAPES1, 1e-6 , 1e-3 , T0)
       `Fn_calcNKT(NtK10,MKS_TRAPGC1,MKS_TRAPES1) 
       `Fn_calc_TRAP( Nt_maxl , NtK10 , NtK20, NtK30, NtK40, Ps0_prv , 0 )
       Nt_max0 = Nt_maxl ;
       exp_time = (CODEG == 1 && TRAPTAUCAP > 0.0) ? lexp( - 0.5 * DEGTIME / TRAPTAUCAP ) : 0.0 ;
       nt0s  = ( Nt_max0 * (1.0 + Nt0s_temp) ) * ( 1 - exp_time ) ;
       ntls  = nt0s ;
     end // end of Trap estimation

`ifdef __AGING_DEBUG__
       $debug( "debugz %m Vgs %g Vgp %g NtK10 %g NtK20 %g Nt_max0 %g nt0s %g MKS_TRAPGC1 %g MKS_TRAPES1 \n",
       Vgs, Vgp, NtK10 , NtK20, Nt_max0, nt0s , MKS_TRAPGC1 , MKS_TRAPES1 ) ;
       $debug( "debugz1 abstime %g %m nt0s %g Isub_trap %g \n", $abstime, nt0s, Isub_trap );
`endif

`endif // _AGING_

    if( UC_CODEP != 0 ) begin
     //---------------------------------------------------*
     //* depletion mode MOSFET   
     //*------------------//

       //-----------------------------------------------------------*
       //* Vxsz: Modified bias introduced to realize symmetry at Vds=0.
       //*-----------------//
       T1 = dVbsc * Vds / 2 ;
       `Fn_SymAdd(  Vzadd , T1 , VZADD0 , T2 )
       if( Vzadd < `ps_conv ) begin
           Vzadd = `ps_conv ;
       end
       Vbsz = Vbs + Vzadd ;
       Vdsz = Vds + 2.0 * Vzadd ;
       Vgsz = Vgs + Vzadd ;

       //---------------------------------------------------*
       //* Factor of modification for symmetry.
       //*-----------------//
       T1 = qnsub_esi * Cox0_inv * Cox0_inv ;
       T2 = Vgs - Vfb ;
       T3 = 1 + 2.0 / T1 * ( T2 - beta_inv - Vbs ) ;
       `Fn_SZ( T4 , T3 , 1e-3 , T5 )
       TX = sqrt( T4 ) ;
       Pslsat = T2 + T1 * ( 1.0 - TX ) ;
       VdsatS = Pslsat - Pb2 ;
       `Fn_SL( VdsatS , VdsatS , 0.1 , 5e-2 , T6 )
       T1 = Vds / VdsatS ;
       `Fn_SUPoly4( TX , T1 , 1.0 , T0 )
       FMDVDS = TX * TX ;

       //-----------------------------------------------------------*
       //* Quantum effect
       //*-----------------//
       if( flg_qmetemp == 0 ) begin
         flg_qme = 0 ;
       end else begin
         flg_qme = 1 ;
       end
       T1 = qnsub_esi2 ;
       T2 = sqrt( T1 * Pb20 ) ;
       Vthq = Pb20 + Vfb + T2 * Cox0_inv ;
       if( flg_qme == 0 ) begin
         Toxe = Tox0 ;
         Cox = Cox0 ;
         Cox_inv  = Cox0_inv ;
         T0 = cnst0 * cnst0 * Cox_inv ;
         cnstCoxi = T0 * Cox_inv ;
       end else begin
         T5     = Vgs  - Vbs - Vthq + QME2 ;
         `Fn_SZ( T2 , T5 , `qme_dlt, T3)
         T2 = T2 + `Small ;
         T3 = 1.0 /  T2 ;
         T4 = 2.0 * abs(Vthq) ;
         T6 = Vfb - Vthq + QME2 ;
         if(T6 > T4) begin T4 = T6; end
         `Fn_SU( T2 , T3 , 1.0 / T4  , `qme_dlt, T6 )

         dTox = QME1 * T2 + QME3 ;
         T7   = QME1 ;
         if( dTox * 1.0e12 < Tox0 ) begin
           dTox = 0.0 ;
           flg_qme = 0 ;
         end
         Toxe = Tox0 + dTox ;
         Cox = c_eox / Toxe ;
         T1  = - c_eox / ( Toxe * Toxe ) ;
         Cox_inv  = Toxe / c_eox ;
         T1  = 1.0 / c_eox ;
         T0 = cnst0 * cnst0 * Cox_inv ;
         cnstCoxi = T0 * Cox_inv ;
       end

       //---------------------------------------------------*
       //* Vbsz2 : Vbs for dVth
       //*-----------------//
       Vbsz2 = Vbsz ;

       //---------------------------------------------------*
       //* Vthp : Vth with pocket.
       //*-----------------//
       T1 = qnsub_esi2 ;
       Qb0 = sqrt (T1 * (Pb20 - Vbsz2)) ;
       T2 = 0.5 * T1 / Qb0 ;
       Vthp = Pb20 + Vfb + Qb0 * Cox_inv + ptovr;
       Pb20b = Pb20 ;
       T0 = 0.95 ;
       T4 = (UC_CODEP > 1) ? 0.0 : 1.0 ;
       T1 = T0 * Pb20b - T4 * Vbsz2 - 1.0e-3 ;
       T2 = sqrt (T1 * T1 + 4.0 * T0 * Pb20b * 1.0e-3) ;
       T3 = T0 * Pb20b - 0.5 * (T1 + T2) ;
       T5 = (UC_CODEP == 1) ? DEPETA * Vdsz : 0.0 ;
       Pbsum = Pb20b - T3 + T5 ; 

       sqrt_Pbsum = sqrt( Pbsum ) ;

       //-------------------------------------------*
       //* dVthLP : Short-channel effect induced by pocket.
       //* - Vth0 : Vth without pocket.
       //*-----------------//
       if( LP != 0.0 ) begin
         T1 = qnsub_esi2 ;
         T2 = BS2 - Vbsz2 ;
         T3 = T2 + `Small ;
         T4 = sqrt (T3 * T3 + 4.0 * `vth_dlt) ;
         T5 = 0.5 * (T3 + T4) ;
         T6 = 0.5 * (1.0 + T3 / T4) ;
         T7 = 1.0 / T5 ;
         bs12 = BS1 * T7 ;
         T8 = - bs12 * T7 ;
         `Fn_SU( T10 , Vbsz2 + bs12, 0.93 * Pb20, `vth_dlt, T0)
         Qbmm = sqrt (T1 * (Pb20 - T10 )) ;
         T9 = T0 / Qbmm ;
         dqb = (Qb0 - Qbmm) * Cox_inv ;
         T1 = 2.0 * `C_QE * EF_NSUBC * `C_ESI ;
         T2 = sqrt( T1 * ( Pb2c - Vbsz2 ) ) ;
         Vth0 = Pb2c + Vfb + T2 * Cox_inv ;
         T3 = 0.5 * T1 / T2 * Cox_inv ;
         T1 = `C_ESI * Cox_inv ;
         T2 = wdplp ;
         T4 = 1.0e0 / ( LP * LP ) ;
         T5 = 2.0e0 * ( VBI - Pb20b ) * T1 * T2 * T4 ;
         dVth0 = T5 * sqrt_Pbsum ;
         T1 = Vthp - Vth0 ;
         T2 = UC_SCP1 + UC_SCP3 * Pbsum / LP ;
         T3 = T2 + UC_SCP2 * Vdsz ;
         Vdx = SCP21 + Vdsz ;
         Vdx2 = Vdx * Vdx ;
         dVthLP = T1 * dVth0 * T3 + dqb - msc / Vdx2 ;
               end else begin
                 dVthLP = 0.0e0 ;
               end

       //---------------------------------------------------*
       //* dVthSC : Short-channel effect induced by Vds.
       //*-----------------//

       T1 = `C_ESI * Cox_inv ;
       T2 = wdpl ;
       T3 = Lgate - PARL2 ;
       T4 = 1.0e0 / ( T3 * T3 ) ;
       T5 = 2.0e0 * ( VBI - Pb20b ) * T1 * T2 * T4 ;
       dVth0 = T5 * sqrt_Pbsum ;

       T1 = UC_SC3 / Lgate ;
       T4 = UC_SC1 + T1 * Pbsum ;
       T5 = T4 + UC_SC2 * Vdsz * ( 1.0 +  SC4 * Pbsum );
       dVthSC = dVth0 * T5 ;

   
       //---------------------------------------------------*
       //* dVthW : narrow-channel effect.
       //*-----------------//
       T1 = 1.0 / Cox ;
       T2 = T1 * T1 ;
       T3 = 1.0 / ( Cox + UC_WFC / Weff_cv ) ;
       T4 = T3 * T3 ;
       T5 = T1 - T3 ;
       dVthW = Qb0 * T5 + UC_WVTH0 / WG ;

       //---------------------------------------------------*
       //* dVth : Total variation.
       //* - Positive dVth means the decrease in Vth.
       //*-----------------//
       dVth = dVthSC + dVthLP + dVthW + dVthsm ;

       //---------------------------------------------------*
       //* Vth : Threshold voltage for OP.
       //*-----------------//
       T2 = sqrt( qnsub_esi2 * (Pb2 - Vbsz)) ;
       Vth = Pb2 + Vfb + T2 * Cox0_inv - dVth ;

       //---------------------------------------------------*
       //* Poly-Depletion Effect
       //*-----------------//
       dPpg = 0.0 ;
       if( flg_pgd == 1 ) begin
         T7 = Vgsz ;
         T0 = cnstpgd ;
         T3 = T7 - PGD2 ;
         `Fn_ExpLim( dPpg , T3 , T6 )
         `Fn_SZ( dPpg , dPpg - 1.0 , `pol_dlt , T6 )
         dPpg = dPpg * T0 ;
         `Fn_SU( dPpg , dPpg , `pol_b , `pol_dlt , T9 )
       end

       //---------------------------------------------------*
       //* Vgp : Effective gate bias with SCE & RSCE & flatband.
       //*-----------------//
       Vgp = Vgs - Vfb + dVth - dPpg ;

       //---------------------------------------------------*
       //* Vgs_fb : Actual flatband voltage taking account Vbs.
       //* - note: if Vgs == Vgs_fb then Vgp == Ps0 == Vbs .
       //*------------------//
       Vgs_fb = Vfb - dVth + dPpg + Vbs ;

       case (UC_CODEP)
       1: begin // 2.8.0 Model
`include "HSM2_depmos.inc"
          end
       2: begin // 2.9.0 Model
`include "HSM2_depmos2.inc"
          end
       3: begin // 3.0.0 new Model
`include "HSM2_depmos3.inc"
          end
       endcase // case (CODEP)

     end else begin

     //---------------------------------------------------*
     //* normal mode  MOSFET
     //*------------------//

       START_OF_SCE_LOOP = 1;
       end_of_part_1 = 0 ;

       // Initialization of counters is needed for restart. //
       lp_s0   = 0 ;
       lp_sl   = 0 ;
               
       //-----------------------------------------------------------*
       //* Vxsz: Modified bias introduced to realize symmetry at Vds=0.
       //*-----------------//
       T1 = dVbsc * Vds / 2 ;
       `Fn_SymAdd(  Vzadd , T1 , VZADD0 , T2 ) 
       if( Vzadd < `ps_conv ) begin
         Vzadd = `ps_conv ;
       end
       Vbsz = Vbs + Vzadd ;
       Vdsz = Vds + 2.0 * Vzadd ;
       Vgsz = Vgs + Vzadd ;
            
       // Vbs effects of dVth with NSUBD //
       if ( $param_given(NSUBD) && NSUBD > 0.0 ) begin

         UC_NSUBD = NSUBD / `C_cm2m_p3 ;
         Nsubd    = UC_NSUBD;
         q_Nsubd  = `C_QE * Nsubd;
         UC_NSUBDW0 = NSUBDW0 / `C_cm2m_p3 ;

         // UC_NSUBDNW = UC_NSUBD*(1+NSUBDW*(1/WG)^NSUBDP)  WG in um; W dependent
         if( NSUBDWP == 0.0 && $param_given(NSUBDNW)) UC_NSUBDNW = NSUBDNW / `C_cm2m_p3 ;
         else UC_NSUBDNW = UC_NSUBDW0*(1.0 + NSUBDW / pow(WG,NSUBDWP));//  WG in um; W dependent 
         Nsubdnw    = UC_NSUBDNW;
         q_Nsubdnw  = `C_QE * Nsubdnw;
          

         // Depletion Width prefactor and 2phiB @NSUBD //
         wdpld = sqrt ( C2_esi_p_q / Nsubd ) ;
         Pb20d = 2.0e0 / `C_b300 * ln (Nsubd / `C_Nin0) ;
         wdpldnw = sqrt ( C2_esi_p_q / Nsubdnw ) ;
         Pb20dnw = 2.0e0 / `C_b300 * ln (Nsubdnw / `C_Nin0) ; 

          begin : vertDopSC //
            real dVth0; // avoid interference with dVth0 outside.
            real UC_SC1W, UC_SC3W, UC_SC4W;
            
            UC_SC1W = UC_SC1;
            UC_SC3W = UC_SC3;
            UC_SC4W = UC_SC4;
            
            Pb20b = Pb20 ; // Pb20 available around L2519.
            T0 = 0.95 ;
            T1 = T0 * Pb20b - Vbsz2 - 1.0e-3 ; // Vbsz2 available around L3422.
            T2 = sqrt (T1 * T1 + 4.0 * T0 * Pb20b * 1.0e-3) ;
            T3 = T0 * Pb20b - 0.5 * (T1 + T2) ;
            Pbsum = Pb20b - T3 ;

            sqrt_Pbsum = sqrt( Pbsum ) ;


            c_eox    = cecox ;
            Toxe     = TOX ;
            Cox      = c_eox / Toxe ;
            Cox_inv  = 1.0 / Cox ;     
                   // Depletion Width //
            C2_esi_p_q = 2.0e0 * `C_ESI / `C_QE ;
            wdpl = sqrt ( C2_esi_p_q / Nsub ) ;
            
            T1 = `C_ESI * Cox_inv ;   // Cox_inv available around L2788.
            T2 = wdpl ;               // wdpl available around L2768.
            T3 = Lgate - PARL2 ;      // Lgate available around L2103.
            T4 = 1.0e0 / ( T3 * T3 ) ;
            T5 = 2.0e0 * ( VBI - Pb20b ) * T1 * T2 * T4 ;
            dVth0 = T5 * sqrt_Pbsum ; // dVth0 (local)

            
            T1 = UC_SC3W / Lgate ;
            T4 = UC_SC1W + T1 * Pbsum ;
                   
            // QME:1  CORECIP:0 //
            if( UC_SC4W != 0 ) begin
              T8 = UC_SC4W * Vdsz * Pbsum ;    // Vdsz available around L3054.
              T5 = T4 + UC_SC2W * Vdsz + T8 ;
            end else begin
              T5 = T4 + UC_SC2W * Vdsz ;
            end
            //dVthSC = dVth0 * T5 ;
            dVSFTDsc = dVth0 * T5 ; // dVth0 (local)


         end
          
         dVthVerts = wdpl  * q_Nsub  * sqrt( Pb20  - Vbsz ) * Cox0_inv ;
         wk_gammad = wdpld * q_Nsubd * Cox0_inv;
         dVthVertd = wk_gammad * sqrt( Pb20d - Vbsz ) + VSFTD -dVSFTDsc ; 
 
         wk_gamma3   = wdpldnw * q_Nsubdnw * Cox0_inv ;
         wk_vsftdnw  = wk_gammad*WDEPV +VSFTD-dVSFTDsc - wk_gamma3 * WDEPV;
         dVthVertdnw = wk_gamma3 * sqrt( Pb20dnw - Vbsz ) + wk_vsftdnw;

         //dVthSC    just like Ps0_ini from Ps0_iniA hampered by Ps0_iniB
            `Fn_SL( wdVthVert,  dVthVertdnw, dVthVertd,`c_ps0ini_2, T1)
            `Fn_SU2(wdVthVert,  dVthVerts, wdVthVert,  `c_ps0ini_2, T1, T2)
           
         dVthVert = dVthVerts - wdVthVert;

       end else begin // NSUBD not given or NSUBD non positive
         dVthVert = 0.0 ; // no effects active
       end

       //---------------------------------------------------*
       //* Factor of modification for symmetry.
       //*-----------------//
       T1 = qnsub_esi * Cox0_inv * Cox0_inv ;
       T2 = Vgs - Vfb ;
       T3 = 1 + 2.0 / T1 * ( T2 - beta_inv - Vbs ) ;
       `Fn_SZ( T4 , T3 , 1e-3 , T5 ) 
       TX = sqrt( T4 + `Small ) ;
       Pslsat = T2 + T1 * ( 1.0 - TX ) ;

       VdsatS = Pslsat - Pb2 ;
       `Fn_SL( VdsatS , VdsatS , 0.1 , 5e-2 , T6 ) 
       T1 = Vds / VdsatS ;
       `Fn_SUPoly4( TX , T1 , 1.0 , T0 ) 
       FMDVDS = TX * TX ;
          
       //-----------------------------------------------------------*
       //* Quantum effect
       //*-----------------//
       if( flg_qmetemp == 0 ) begin
         flg_qme = 0 ;
       end else begin
         flg_qme = 1 ;
       end
       T1 = qnsub_esi2 ;
       T2 = sqrt( T1 * Pb20 ) ;
       Vthq = Pb20 + Vfb + T2 * Cox0_inv ;
       if( flg_qme == 0 ) begin
         Toxe = Tox0 ;
         Cox = Cox0 ;
         Cox_inv  = Cox0_inv ;
         T0 = cnst0 * cnst0 * Cox_inv ;
         cnstCoxi = T0 * Cox_inv ;
       end else begin
         T5     = Vgs  - Vbs - Vthq + QME2 ;
         `Fn_SZ( T2 , T5 , `qme_dlt, T3) 
         T2 = T2 + `Small ;
         T3 = 1.0 /  T2 ;
         T4 = 2.0 * abs(Vthq) ;
         T6 = Vfb - Vthq + QME2 ;
         if(T6 > T4) begin T4 = T6; end
         `Fn_SU( T2 , T3 , 1.0 / T4  , `qme_dlt, T6 ) 
            
         dTox = QME1 * T2 + QME3 ;
         T7   = QME1 ;
         if( dTox * 1.0e12 < Tox0 ) begin
           dTox = 0.0 ;
           flg_qme = 0 ;
         end
         Toxe = Tox0 + dTox ;
         Cox = c_eox / Toxe ;
         T1  = - c_eox / ( Toxe * Toxe ) ;
         Cox_inv  = Toxe / c_eox ;
         T1  = 1.0 / c_eox ;
         T0 = cnst0 * cnst0 * Cox_inv ;
         cnstCoxi = T0 * Cox_inv ;
         T1 = 2.0 * T0 ;
       end
       fac1 = cnst0 * Cox_inv ;
       fac1p2 = fac1 * fac1 ;
              
       // Ps0_min: approx. solution of Poisson equation at Vgs_min //
       //          ( easy to improve, if necessary  )              //
       Ps0_min = 2.0 * beta_inv * ln (-Vgs_min/fac1) ;
               
       //---------------------------------------------------*
       //* Vbsz2 : Vbs for dVth
       //*-----------------//
       Vbsz2 = Vbsz ;
       if( UC_CORECIP ) begin
               
         // ************************** //
         // Initial value for PS0Z_SCE //
         // ************************** //
         T1 = `dP_max + `dP_max ;

         if( abs(T1) > `dP_max) begin
           // ------------------------------------- *
           //* Analytical initial value for PS0Z_SCE *
           //* ------------------------------------- //
           T1 = qnsub_esi2 ;
           T2 = sqrt( T1 * ( Pb20 - Vbsz ) ) ;
           Vthq = Pb20 + Vfb + T2 * Cox0_inv ;
           Vth = Vthq ;
           TX = 4.0e0 * ( beta * ( Vgs - Vbs ) - 1.0e0 ) / ( fac1p2 * beta2 ) ;
           TX = TX + 1.0 ;
           if( TX > `epsm10 ) begin
             T3 = sqrt( TX ) ;
           end else begin
             T3 = sqrt( `epsm10 ) ;
           end
           Ps0_iniA = Vgs + fac1p2 * beta * 0.5 * ( 1.0e0 - T3 ) ;
           Chi = beta * ( Ps0_iniA - Vbs ) ;
           if( Chi < `znbd3 ) begin
             //-----------------------------------*
             //* zone-D1/D2
             //* - Ps0_ini is the analytical solution of Qs=Qb0 with
             //*   Qb0 being approximated to 3-degree polynomial.
             //*-----------------//
             TY = beta * ( Vgs - Vbs ) ;
             T1 = 1.0e0 / ( `cn_nc3 * beta * fac1 ) ;
             T2 = 81.0 + 3.0 * T1 ;
             T3 = -2916.0 - 81.0 * T1 + 27.0 * T1 * TY ;
             T4 = T3 ;
             T6 = sqrt( 4 * T2 * T2 * T2 + T4 * T4 ) ;
             T5 = `Fn_Pow( T3 + T6 , `C_1o3 ) ;
             if( T5 <= 0) begin
               TX = 0.0 ; 
             end else begin 
             TX = 3.0 - ( `C_2p_1o3 * T2 ) / ( 3.0 * T5 )
                + 1 / ( 3.0 * `C_2p_1o3 ) * T5 ;
             end
             Ps0_iniA = TX * beta_inv + Vbs ;
             Ps0_ini = Ps0_iniA ;
           end else if( Vgs <= Vth ) begin
             //-----------------------------------*
             //* Weak inversion zone.
             //*-----------------//
             Ps0_ini = Ps0_iniA ;
           end else begin
             //-----------------------------------*
             //* Strong inversion zone.
             //* - Ps0_iniB : upper bound.
             //*-----------------//
             T1 = 1.0 / cnst1 / cnstCoxi ;
             T0 = Vgs - Vfb ;
             T2 = T1 * T0 * T0 ;
             T3 = beta + 2.0 / T0 ;
             Ps0_iniB = ln ( T2 + `Small ) / T3 ;
             `Fn_SU2( Ps0_ini , Ps0_iniA, Ps0_iniB, `c_ps0ini_2, T1,T2) 
           end
         end // end of initial value calculation //
                  
         //************************//
                  
         // initial value for SCE LOOP //
         PS0Z_SCE = Ps0_ini ;
       end // end of corecip=1 case(initial value calculation) //
       MAX_LOOP_SCE = 5 ;
       NNN = 0 ;

           
       // ************************************************************************* //
       //   START_OF_SCE_LOOP: // outer loop of multi level Newton framework        //
       while( START_OF_SCE_LOOP ) begin // Begin: 1st SCE LOOP //
         while( START_OF_SCE_LOOP ) begin // Begin: 2nd SCE LOOP //
           while( START_OF_SCE_LOOP ) begin // Begin: 3rd SCE LOOP //
             START_OF_SCE_LOOP = 0 ;
                               
             // ************************************************************************* //
                               
             // for multi level Newton method we need the derivatives //
             // with respect to PS0Z_SCE                              //
             // naming convention: ..._dPS0Z means d.../dPS0Z_SCE     //
             if( flg_qme == 1 ) begin
               //---------------------------------------------------*
               //* Vthp : Vth with pocket.
               //*-----------------//
               if( UC_CORECIP ) begin
                 T1 = qnsub_esi2 ;
                 Qb0 = sqrt ( T1 ) ;
                 Vthp = PS0Z_SCE + Vfb + Qb0 * Cox_inv + ptovr ;
                 Vthp_dPS0Z = 1.0 ;
               end else begin  // original //
                 T1 = qnsub_esi2 ;
                 Qb0 = sqrt (T1 * (Pb20 - Vbsz2)) ;
                 Vthp = Pb20 + Vfb + Qb0 * Cox_inv + ptovr;
               end
               Pb20b = Pb20 ;
               T0 = 0.95 ;
               T1 = T0 * Pb20b - Vbsz2 - 1.0e-3 ;
               T2 = sqrt (T1 * T1 + 4.0 * T0 * Pb20b * 1.0e-3) ;
               T3 = T0 * Pb20b - 0.5 * (T1 + T2) ;
               Pbsum = Pb20b - T3 ;

               sqrt_Pbsum = sqrt( Pbsum ) ;
                          
               //-------------------------------------------*
               //* dVthLP : Short-channel effect induced by pocket.
               //* - Vth0 : Vth without pocket.
               //*-----------------//
               if( LP != 0.0 ) begin
                 if( UC_CORECIP ) begin
                   T1 = qnsub_esi2 ;
                   T2 = BS2 - Vbsz2 ;
                   T3 = T2 + `Small ;
                   T4 = sqrt (T3 * T3 + 4.0 * `vth_dlt) ;
                   T5 = 0.5 * (T3 + T4) ;
                   T7 = 1.0 / T5 ;
                   bs12 = BS1 * T7 ;
                   T1 = 0.93 * ( PS0Z_SCE + Ps0_min - Vbsz2 );
                   T1_dPS0Z = 0.93 ;
                   T2 = bs12 ;
                   `Fn_SU2( T10 , T2 , T1 , `vth_dlt, T0, T3 ) 
                   T10_dPS0Z = T1_dPS0Z * T3 ;
                   T4 = qnsub_esi2 * ( PS0Z_SCE + Ps0_min - Vbsz2 - T10 ) ;
                   T4_dPS0Z = qnsub_esi2 * ( 1.0 - T10_dPS0Z ) ;
                   if(T4 > arg2) begin
                     Qbmm = sqrt ( T4 ) ;
                     Qbmm_dPS0Z = 0.5 / Qbmm * T4_dPS0Z ;
                   end else begin
                     Qbmm = sqrt(arg2) + 0.5 / sqrt(arg2) * ( T4 - arg2) ;
                     Qbmm_dPS0Z = 0.5 / sqrt(arg2) * T4_dPS0Z ;
                   end
                   dqb = ( Qb0 - Qbmm ) * Cox_inv ;
                   dqb_dPS0Z = - Qbmm_dPS0Z * Cox_inv ;
                   if( codqb == 0 ) begin
                     dqb = 0.0 ;
                     dqb_dPS0Z = 0.0 ;
                   end
                   T1 = 2.0 * `C_QE * EF_NSUBC * `C_ESI ;
                   T2 = sqrt( T1 ) ;
                   Vth0 = PS0Z_SCE + Vfb + T2 * Cox_inv ;
                   Vth0_dPS0Z = 1.0 ;
                   T1 = `C_ESI * Cox_inv ;
                   T2 = wdplp ;
                   T4 = 1.0e0 / ( LP * LP ) ;
                   T3 = 2.0 * ( VBI - Pb20 ) * T2 * T4 ;
                   T5 = T1 * T3 ;
                   T6 = PS0Z_SCE - Vbsz ;
                   T6_dPS0Z = 1.0 ;
                   `Fn_SZ( T6, T6, `C_sce_dlt, T0 )
                   T6_dPS0Z = T6_dPS0Z * T0 ;
                   dVth0 = T5 * sqrt( T6 ) ;
                   dVth0_dPS0Z = T5 * 0.5 / sqrt( T6 ) * T6_dPS0Z ;
                   T1 = Vthp - Vth0 ;
                   T1_dPS0Z = Vthp_dPS0Z - Vth0_dPS0Z ;
                   T9 = PS0Z_SCE - Vbsz2 ;
                   T9_dPS0Z = 1.0 ;
                   T3 = UC_SCP1 + UC_SCP3 * T9 / LP + UC_SCP2 * Vdsz ;
                   T3_dPS0Z = UC_SCP3 * T9_dPS0Z / LP ;
                   Vdx = SCP21 + Vdsz ;
                   Vdx2 = Vdx * Vdx + `Small ;
                   T4 = Vdx * Vdx + `Small ;
                   T5 = 1.0 / T4 ;
                   dVthLP = T1 * dVth0 * T3 + dqb - msc * T5  ;
                   dVthLP_dPS0Z = T1_dPS0Z * dVth0 * T3 + T1 * dVth0_dPS0Z * T3 + T1 * dVth0 * T3_dPS0Z + dqb_dPS0Z   ;
                                
                 end else begin  // original //
                   T1 = qnsub_esi2 ;
                   T2 = BS2 - Vbsz2 ;
                   T3 = T2 + `Small ;
                   T4 = sqrt (T3 * T3 + 4.0 * `vth_dlt) ;
                   T5 = 0.5 * (T3 + T4) ;
                   T7 = 1.0 / T5 ;
                   bs12 = BS1 * T7 ;
                   `Fn_SU( T10 , Vbsz2 + bs12, 0.93 * Pb20, `vth_dlt, T0) 
                   Qbmm = sqrt (T1 * (Pb20 - T10 )) ;
                   dqb = (Qb0 - Qbmm) * Cox_inv ;
                   T1 = 2.0 * `C_QE * EF_NSUBC * `C_ESI ;
                   T2 = sqrt( T1 * ( Pb2c - Vbsz2 ) ) ;
                   Vth0 = Pb2c + Vfb + T2 * Cox_inv ;
                   T3 = 0.5 * T1 / T2 * Cox_inv ;
                   T1 = `C_ESI * Cox_inv ;
                   T2 = wdplp ;
                   T4 = 1.0e0 / ( LP * LP ) ;
                   T5 = 2.0e0 * ( VBI - Pb20b ) * T1 * T2 * T4 ;
                   dVth0 = T5 * sqrt_Pbsum ;
                   T1 = Vthp - Vth0 ;
                   T2 = UC_SCP1 + UC_SCP3 * Pbsum / LP ;
                   T3 = T2 + UC_SCP2 * Vdsz ;
                   Vdx = SCP21 + Vdsz ;
                   Vdx2 = Vdx * Vdx + `Small ;
                   dVthLP = T1 * dVth0 * T3 + dqb - msc / Vdx2 ;
                 end
               end else begin
                 dVthLP = 0.0e0 ;
               end // else: !if( LP != 0.0 )
                      
               //---------------------------------------------------*
               //* dVthSC : Short-channel effect induced by Vds.
               //*-----------------//
               if( UC_CORECIP ) begin
                 T3 = Lgate - PARL2 ;
                 T4 = 1.0e0 / ( T3 * T3 ) ;
                 T5 = UC_SC3 / Lgate ;
                 T6 = UC_SC1 + T5 * ( PS0Z_SCE - Vbsz ) ;
                 T6_dPS0Z = T5 ;
                          
                 // QME:1  CORECIP:1 //
                 if( UC_SC4 != 0 ) begin
                   T8 = UC_SC4 * Vdsz * ( PS0Z_SCE - Vbsz ) ;
                   T8_dPS0Z = UC_SC4 * Vdsz ;
                   T1 = T6 + UC_SC2 * Vdsz + T8 ;
                   T1_dPS0Z = T6_dPS0Z + T8_dPS0Z ;
                 end else begin
                   T1 = T6 + UC_SC2 * Vdsz ;
                   T1_dPS0Z = T6_dPS0Z ;
                 end
                 T0 = `C_ESI * wdpl * 2.0e0 * ( VBI - Pb20 ) * T4 ;
                 T2 = T0 * Cox_inv ;
                 A  = T2 * T1 ;
                 A_dPS0Z = T2 * T1_dPS0Z ;
                 T9 = PS0Z_SCE - Vbsz + Ps0_min ;
                 T9_dPS0Z = 1.0 ;
                 if( T9 > arg0 ) begin
                   T8 = sqrt( T9 ) ;
                   T8_dPS0Z = 0.5 * T9_dPS0Z / T8 ;
                 end else begin
                   T8 = sqrt(arg0) + 0.5 / sqrt(arg0) * ( T9 - arg0) ;
                   T8_dPS0Z = 0.5 / sqrt(arg0) * T9_dPS0Z ;
                 end
                 dVthSC = A * T8 ;
                 dVthSC_dPS0Z = A * T8_dPS0Z + A_dPS0Z * T8;
                              
               end else begin  // original //
                 T1 = `C_ESI * Cox_inv ;
                 T2 = wdpl ;
                 T3 = Lgate - PARL2 ;
                 T4 = 1.0e0 / ( T3 * T3 ) ;
                 T5 = 2.0e0 * ( VBI - Pb20b ) * T1 * T2 * T4 ;
                 dVth0 = T5 * sqrt_Pbsum ;
                 T1 = UC_SC3 / Lgate ;
                 T4 = UC_SC1 + T1 * Pbsum ;
                    
                 // QME:1  CORECIP:0 //
                 if( UC_SC4 != 0 ) begin
                   T8 = UC_SC4 * Vdsz * Pbsum ;
                   T5 = T4 + UC_SC2 * Vdsz + T8 ;
                 end else begin
                   T5 = T4 + UC_SC2 * Vdsz ;
                 end
                 dVthSC = dVth0 * T5 ;
                        
               end // else: !if( UC_CORECIP )
                      
               //---------------------------------------------------*
               //* dVthW : narrow-channel effect.
               //*-----------------//
               T1 = 1.0 / Cox ;
               T2 = T1 * T1 ;
               T3 = 1.0 / ( Cox +  UC_WFC / Weff ) ;
               T4 = T3 * T3 ;
               T5 = T1 - T3 ;
               dVthW = Qb0 * T5 + UC_WVTH0 / WG ;
                     
               // end of case flg_qme = 1 //
             end else begin
                     
               // now case flg_qme = 0    //
                     
               //---------------------------------------------------*
               //* Vthp : Vth with pocket.
               //*-----------------//
               if( UC_CORECIP ) begin
                 T1 = qnsub_esi2 ;
                 Qb0 = sqrt ( T1 ) ;
                 Vthp = PS0Z_SCE + Vfb + Qb0 * Cox_inv + ptovr;
                 Vthp_dPS0Z = 1.0 ;
               end else begin  // original //
                 T1 = qnsub_esi2 ;
                 Qb0 = sqrt (T1 * (Pb20 - Vbsz2)) ;
                 Vthp = Pb20 + Vfb + Qb0 * Cox_inv + ptovr;
               end
               Pb20b = Pb20 ;
               T0 = 0.95 ;
               T1 = T0 * Pb20b - Vbsz2 - 1.0e-3 ;
               T2 = sqrt (T1 * T1 + 4.0 * T0 * Pb20b * 1.0e-3) ;
               T3 = T0 * Pb20b - 0.5 * (T1 + T2) ;
               Pbsum = Pb20b - T3 ;
               sqrt_Pbsum = sqrt( Pbsum ) ;
                          
               //-------------------------------------------*
               //* dVthLP : Short-channel effect induced by pocket.
               //* - Vth0 : Vth without pocket.
               //*-----------------//
               if( LP != 0.0 ) begin
                 if( UC_CORECIP ) begin
                   T1 = qnsub_esi2 ;
                   T2 = BS2 - Vbsz2 ;
                   T3 = T2 + `Small ;
                   T4 = sqrt (T3 * T3 + 4.0 * `vth_dlt) ;
                   T5 = 0.5 * (T3 + T4) ;
                   T7 = 1.0 / T5 ;
                   bs12 = BS1 * T7 ;
                   T1 = 0.93 * ( PS0Z_SCE + Ps0_min - Vbsz2 );
                   T1_dPS0Z = 0.93 ;
                   T2 = bs12 ;
                   `Fn_SU2( T10 , T2 , T1 , `vth_dlt, T0, T3 ) 
                   T10_dPS0Z = T1_dPS0Z * T3 ;
                   T4 = qnsub_esi2 * ( PS0Z_SCE + Ps0_min - Vbsz2 - T10 ) ;
                   T4_dPS0Z = qnsub_esi2 * ( 1.0 - T10_dPS0Z ) ;
                   if(T4 > arg2) begin
                     Qbmm = sqrt ( T4 ) ;
                     Qbmm_dPS0Z = 0.5 / Qbmm * T4_dPS0Z ;
                   end else begin
                     Qbmm = sqrt(arg2) + 0.5 / sqrt(arg2) * ( T4 - arg2) ;
                     Qbmm_dPS0Z = 0.5 / sqrt(arg2) * T4_dPS0Z ;
                   end
                   dqb = ( Qb0 - Qbmm ) * Cox_inv ;
                   dqb_dPS0Z = ( - Qbmm_dPS0Z ) * Cox_inv ;
                             
                   //  W/O QME PART  //
                   if( codqb == 0 ) begin
                     dqb = 0 ;
                     dqb_dPS0Z = 0.0 ;
                   end
                   T1 = 2.0 * `C_QE * EF_NSUBC * `C_ESI ;
                   T2 = sqrt( T1 ) ;
                   Vth0 = PS0Z_SCE + Vfb + T2 * Cox_inv ;
                   Vth0_dPS0Z = 1.0 ;
                   T1 = `C_ESI * Cox_inv ;
                   T2 = wdplp ;
                   T4 = 1.0e0 / ( LP * LP ) ;
                   T5 = 2.0e0 * ( VBI - Pb20 ) * T1 * T2 * T4 ;
                   T6 = PS0Z_SCE - Vbsz      ;
                   T6_dPS0Z = 1.0 ;
                   `Fn_SZ(T6, T6, `C_sce_dlt, T0 )
                   T6 = T6 + `Small ;
                   T6_dPS0Z = T6_dPS0Z * T0 ;
                   dVth0 = T5 * sqrt( T6 ) ;
                   dVth0_dPS0Z = T5 * 0.5 / sqrt( T6 ) * T6_dPS0Z ;
                   T1 = Vthp - Vth0 ;
                   T1_dPS0Z = Vthp_dPS0Z - Vth0_dPS0Z ;
                   T9 = PS0Z_SCE - Vbsz2 ;
                   T9_dPS0Z = 1.0 ;
                   T3 = UC_SCP1 + UC_SCP3 * T9 / LP + UC_SCP2 * Vdsz ;
                   T3_dPS0Z = UC_SCP3 * T9_dPS0Z / LP ;
                   Vdx = SCP21 + Vdsz ;
                   Vdx2 = Vdx * Vdx + `Small ;
                   T4 = Vdx * Vdx + `Small ;
                   T5 = 1.0 / T4 ;
                   dVthLP = T1 * dVth0 * T3 + dqb - msc * T5  ;
                   dVthLP_dPS0Z = T1_dPS0Z * dVth0 * T3 + T1 * dVth0_dPS0Z * T3 + T1 * dVth0 * T3_dPS0Z + dqb_dPS0Z   ;
                                
                 end else begin  // Original //
                   T1 = qnsub_esi2 ;
                   T2 = BS2 - Vbsz2 ;
                   T3 = T2 + `Small ;
                   T4 = sqrt (T3 * T3 + 4.0 * `vth_dlt) ;
                   T5 = 0.5 * (T3 + T4) ;
                   T7 = 1.0 / T5 ;
                   bs12 = BS1 * T7 ;
                   `Fn_SU( T10 , Vbsz2 + bs12, 0.93 * Pb20, `vth_dlt, T0) 
                   Qbmm = sqrt (T1 * (Pb20 - T10 )) ;
                   dqb = (Qb0 - Qbmm) * Cox_inv ;
                   T1 = 2.0 * `C_QE * EF_NSUBC * `C_ESI ;
                   T2 = sqrt( T1 * ( Pb2c - Vbsz2 ) ) ;
                   Vth0 = Pb2c + Vfb + T2 * Cox_inv ;
                   T1 = `C_ESI * Cox_inv ;
                   T2 = wdplp ;
                   T4 = 1.0e0 / ( LP * LP ) ;
                   T5 = 2.0e0 * ( VBI - Pb20b ) * T1 * T2 * T4 ;
                   dVth0 = T5 * sqrt_Pbsum ;
                   T1 = Vthp - Vth0 ;
                   T2 = UC_SCP1 + UC_SCP3 * Pbsum / LP ;
                   T3 = T2 + UC_SCP2 * Vdsz ;
                   Vdx = SCP21 + Vdsz ;
                   Vdx2 = Vdx * Vdx + `Small ;
                   dVthLP = T1 * dVth0 * T3 + dqb - msc / Vdx2 ;
                 end
               end else begin
                 dVthLP = 0.0e0 ;
               end
                      
               //---------------------------------------------------*
               //* dVthSC : Short-channel effect induced by Vds.
               //*-----------------//
               if( UC_CORECIP ) begin
                 T3 = Lgate - PARL2 ;
                 T4 = 1.0e0 / ( T3 * T3 ) ;
                 T5 = UC_SC3 / Lgate ;
                 T6 = UC_SC1 + T5 * ( PS0Z_SCE - Vbsz ) ;
                 T6_dPS0Z = T5 ;
                          
                 // QME:0  CORECIP:1 //
                 if( UC_SC4 != 0 ) begin
                   T8 = UC_SC4 * Vdsz * ( PS0Z_SCE - Vbsz ) ;
                   T8_dPS0Z = UC_SC4 * Vdsz ;
                   T1 = T6 + UC_SC2 * Vdsz + T8 ;
                   T1_dPS0Z = T6_dPS0Z + T8_dPS0Z ;
                 end else begin
                   T1 = T6 + UC_SC2 * Vdsz ;
                   T1_dPS0Z = T6_dPS0Z ;
                 end
                 T2 = `C_ESI * Cox_inv * wdpl * 2.0e0 * ( VBI - Pb20 ) * T4 ;
                 A = T2 * T1 ;
                 A_dPS0Z = T2 * T1_dPS0Z ;
                 T7 = PS0Z_SCE - Vbsz + Ps0_min ;
                 T7_dPS0Z = 1.0 ;
                 if( T7 > arg0 ) begin
                   T8 = sqrt( T7 ) ;
                   T8_dPS0Z = 0.5 * T7_dPS0Z / T8 ;
                 end else begin
                   T8 = sqrt(arg0) + 0.5 / sqrt(arg0) * ( T7 - arg0) ;
                   T8_dPS0Z = 0.5 / sqrt(arg0) * T7_dPS0Z ;
                 end
                 dVthSC = A * T8 ;
                 dVthSC_dPS0Z = A * T8_dPS0Z + A_dPS0Z * T8;
                              
               end else begin // original //
                 T1 = `C_ESI * Cox_inv ;
                 T2 = wdpl ;
                 T3 = Lgate - PARL2 ;
                 T4 = 1.0e0 / ( T3 * T3 ) ;
                 T5 = 2.0e0 * ( VBI - Pb20b ) * T1 * T2 * T4 ;
                 dVth0 = T5 * sqrt_Pbsum ;
                 T1 = UC_SC3 / Lgate ;
                 T4 = UC_SC1 + T1 * Pbsum ;
                    
                 // QME:0  CORECIP:0 //
                 if( UC_SC4 != 0 ) begin
                   T8 = UC_SC4 * Vdsz * Pbsum ;
                   T5 = T4 + UC_SC2 * Vdsz + T8 ;
                 end else begin
                   T5 = T4 + UC_SC2 * Vdsz ;
                 end
                 dVthSC = dVth0 * T5 ;
                        
               end
                      
               //---------------------------------------------------*
               //* dVthW : narrow-channel effect.
               //*-----------------//
               T1 = 1.0 / Cox ;
               T3 = 1.0 / ( Cox +  UC_WFC / Weff ) ;
               T5 = T1 - T3 ;
               dVthW = Qb0 * T5 + UC_WVTH0 / WG ;
                     
             end // end of flg_qme if-blocks // 

             //---------------------------------------------------*
             //* dVth : Total variation.
             //* - Positive dVth means the decrease in Vth.
             //*-----------------//
             dVth = dVthSC + dVthLP + dVthW + dVthsm  + dVthVert; // dVthVert 20180208
             dVth_dPS0Z = dVthSC_dPS0Z + dVthLP_dPS0Z ;
                        
             //---------------------------------------------------*
             //* Vth : Threshold voltage for OP.
             //*-----------------//
             T2 = sqrt( qnsub_esi2 * (Pb2 - Vbsz) );
             Vth = Pb2 + Vfb + T2 * Cox0_inv - dVth ;
                 
             //-----------------------------------------------------------*
             //* Constants in the equation of Ps0 .
             //*-----------------//
             fac1 = cnst0 * Cox_inv ;
             fac1p2 = fac1 * fac1 ;
             //---------------------------------------------------*
             //* Poly-Depletion Effect
             //*-----------------//
             if( flg_pgd == 0 ) begin
               dPpg = 0.0 ;
             end else begin
               T7 = Vgsz ;
               T0 = cnstpgd ;
               T3 = T7 - PGD2 ;
               `Fn_ExpLim( dPpg , T3 , T6 ) 
               `Fn_SZ( dPpg , dPpg - 1.0 , 0.1 , T6 ) 
               dPpg = dPpg * T0 ;
               `Fn_SU( dPpg , dPpg , `pol_b , `pol_dlt , T9 ) 
                    
             end
                  
             //---------------------------------------------------*
             //* Vgp : Effective gate bias with SCE & RSCE & flatband.
             //*-----------------//
             Vgp = Vgs - Vfb + dVth - dPpg ;
             Vgp_dPS0Z = dVth_dPS0Z ;
             Vgpz = Vgsz - Vfb + dVth - dPpg ; 

             //---------------------------------------------------*
             //* Vgs_fb : Actual flatband voltage taking account Vbs.
             //* - note: if Vgs == Vgs_fb then Vgp == Ps0 == Vbs .
             //*------------------//
             Vgs_fb = Vfb - dVth + dPpg + Vbs ;
                    
             //-----------------------------------------------------------*
             //* Accumulation zone. (zone-A)
             //* - evaluate basic characteristics and exit from this part.
             //*-----------------//
             if( Vgs < Vgs_fb ) begin
               flg_zone = -1 ;
                        
               //---------------------------------------------------*
               //* Evaluation of Ps0.
               //* - Psa : Analytical solution of
               //*             Cox( Vgp - Psa ) = cnst0 * Qacc
               //*         where Qacc is the 3-degree series of(fdep)^begin1/2end.
               //*         The unknown  is transformed to Chi=beta(Ps0-Vbs).
               //* - Ps0_min : |Ps0_min| when Vbs=0.
               //*-----------------//
               // Ps0_min = Eg - Pb2 ;                                    //
               // -> replaced by approx. solving Poisson equation at Vgs=Vgs_min     //
               // Ps0_min = 2.0 * beta_inv * log(-Vgs_min/fac1) ; already done above //
               TX = beta * ( Vgp - Vbs ) ;
               TX_dPS0Z = beta * Vgp_dPS0Z ;
               T1 = 1.0 / ( beta * cnst0 ) ;
               TY = T1 * Cox ;
               Ac41 = 2.0 + 3.0 * `C_SQRT_2 * TY ;
               Ac4 = 8.0 * Ac41 * Ac41 * Ac41 ;
               T5 = 9.0 * TY * ( TX - 2.0 ) ;
               T5_dPS0Z = 9.0 * TY * TX_dPS0Z ;
               Ac31 = 7.0 * `C_SQRT_2 - T5 ;
               Ac31_dPS0Z = -T5_dPS0Z ;
               Ac3 = Ac31 * Ac31 ;
               T1 = 2.0 * Ac31 ;
               Ac3_dPS0Z = T1 * Ac31_dPS0Z ;
               if( Ac4 < Ac3*1.0e-8 ) begin
                 Ac1 = 0.5 * Ac4 / Ac31 ;
                 Ac1_dPS0Z =  - Ac1 / Ac31 ;
               end else begin
                 Ac2 = sqrt( Ac4 + Ac3 ) ;
                 T1 = 0.5 / Ac2 ;
                 Ac2_dPS0Z = T1 * ( Ac3_dPS0Z ) ;
                 Ac1 = -Ac31 + Ac2 ;
                 Ac1_dPS0Z = -Ac31_dPS0Z + Ac2_dPS0Z ;
               end
               Acd = `Fn_Pow( Ac1 , `C_1o3 ) ;
               T1 = `C_1o3 / ( Acd * Acd ) ;
               Acd_dPS0Z = Ac1_dPS0Z * T1 ;
               Acn = -4.0 * `C_SQRT_2 - 12.0 * TY + 2.0 * Acd + `C_SQRT_2 * Acd * Acd ;
               T1 = 2.0 + 2.0 * `C_SQRT_2 * Acd ;
               Acn_dPS0Z = T1 * Acd_dPS0Z ;
               T1 = 1.0 / Acd ;
               Chi = Acn * T1 ;
               Chi_dPS0Z = ( Acn_dPS0Z - Chi * Acd_dPS0Z ) * T1 ;
               Psa = Chi * beta_inv + Vbs ;
               Psa_dPS0Z = Chi_dPS0Z * beta_inv ;
               T1 = Psa - Vbs ;
               T2 = T1 / Ps0_min ;
               T3 = sqrt( 1.0 + ( T2 * T2 ) ) ;
               T9 = T2 / T3 / Ps0_min ;
               T3_dPS0Z = T9 * ( Psa_dPS0Z ) ;
               Ps0 = T1 / T3 + Vbs ;
               T9 = 1.0 / ( T3 * T3 ) ;
               Ps0_dPS0Z = T9 * ( Psa_dPS0Z * T3 - T1 * T3_dPS0Z ) ;
                         
               //---------------------------------------------------*
               //* Characteristics.
               //*-----------------//
               Psl = Ps0 ;
               T2 = ( Vgp - Ps0 ) ;
               Qbu = Cox * T2 ;
               Qiu = 0.0e0 ;
               Qdrat = 0.5e0 ;
               Lred = 0.0e0 ;
               Ids = 0.0e0 ;
               VgVt = 0.0 ;
               flg_noqi = 1 ;
               if( UC_CORECIP ) begin
                 //!! This is for Accumulation Region !!//
                 T1 = Vds * 0.5  ;
                 `Fn_SymAdd( Pzadd , T1 , PZADD0 , T2 ) 
                 Pzadd_dPS0Z = 0.0 ;
                 if( Pzadd < `epsm10 ) begin
                   Pzadd = `epsm10 ;
                   Pzadd_dPS0Z = 0.0 ;
                 end
                 Ps0z = Ps0 + Pzadd ;
                 Ps0z_dPS0Z = Ps0_dPS0Z + Pzadd_dPS0Z ;
                            
                 // calculate Newton correction: //
                 G = PS0Z_SCE - Ps0z ;
                 delta_PS0Z_SCE = - G / (1.0 - Ps0z_dPS0Z) ;
                 PS0Z_SCE = PS0Z_SCE + delta_PS0Z_SCE ;
                 NNN = NNN + 1 ;
                     
                 if( abs(delta_PS0Z_SCE) > PS0_SCE_tol
                 && (NNN < MAX_LOOP_SCE)  ) begin
                   //go to START_OF_SCE_LOOP;
                   START_OF_SCE_LOOP = 1 ;
                 end
               end
               //go to end_of_part_1 ;
               if(START_OF_SCE_LOOP==0) end_of_part_1 = 1 ;
               end
                               
           end // End of 3rd SCE_LOOP //
           if( end_of_part_1 == 0 ) begin // skip to end_of_part_1 //
                               
             //-----------------------------------------------------------*
             //* Initial guess for Ps0.
             //*-----------------//
                               
             //---------------------------------------------------*
             //* Ps0_iniA: solution of subthreshold equation assuming zone-D1/D2.
             //*-----------------//
             TX = 1.0e0 + 4.0e0 * ( beta * ( Vgp - Vbs ) - 1.0e0 ) / ( fac1p2 * beta2 ) ;
             TX = `Fn_Max( TX , `epsm10 ) ;
             Ps0_iniA = Vgp + fac1p2 * beta * 0.5 * ( 1.0e0 - sqrt( TX ) ) ;
                      
             // use analytical value in subthreshold region. //
             if( Vgs <( Vfb + Vth ) * 0.5 ) begin
               flg_pprv = 0 ;
             end

             if( flg_pprv == 0 ) begin
                        
               //---------------------------------------------------*
               //* Analytical initial guess.
               //*-----------------//
               //-------------------------------------------*
               //* Common part.
               //*-----------------//
               Chi = beta * ( Ps0_iniA - Vbs ) ;
               if( Chi < `znbd3 ) begin
                 //-----------------------------------*
                 //* zone-D1/D2
                 //* - Ps0_ini is the analytical solution of Qs=Qb0 with
                 //*   Qb0 being approximated to 3-degree polynomial.
                 //*-----------------//
                 TY = beta * ( Vgp - Vbs ) ;
                 T1 = 1.0e0 / ( `cn_nc3 * beta * fac1 ) ;
                 T2 = 81.0 + 3.0 * T1 ;
                 T3 = -2916.0 - 81.0 * T1 + 27.0 * T1 * TY ;
                 T4 = 1458.0 - 81.0 * ( 54.0 + T1 ) + 27.0 * T1 * TY ;
                 T4 = T4 * T4 ;
                 T5 = `Fn_Pow( T3 + sqrt( 4 * T2 * T2 * T2 + T4 ) , `C_1o3 ) ;
                 TX = 3.0 - ( `C_2p_1o3 * T2 ) / ( 3.0 * T5 )
                    + 1 / ( 3.0 * `C_2p_1o3 ) * T5 ;
                 Ps0_iniA = TX * beta_inv + Vbs ;
                 Ps0_ini = Ps0_iniA ;
               end else if( Vgs <= Vth ) begin
                 //-----------------------------------*
                 //* Weak inversion zone.
                 //*-----------------//
                 Ps0_ini = Ps0_iniA ;
               end else begin
                 //-----------------------------------*
                 //* Strong inversion zone.
                 //* - Ps0_iniB : upper bound.
                 //*-----------------//
                 T1 = 1.0 / cnst1 / cnstCoxi ;
                 T2 = T1 * Vgp * Vgp ;
                 T3 = beta + 2.0 / Vgp ;
                 Ps0_iniB = ln ( T2 + `Small ) / T3 ;
                 `Fn_SU( Ps0_ini , Ps0_iniA, Ps0_iniB, `c_ps0ini_2, T1) 
               end
             end
             TX = Vbs + `ps_conv / 2 ;
             if ( Ps0_ini < TX ) Ps0_ini = TX ;
                
             //---------------------------------------------------*
             //* Assign initial guess.
             //*-----------------//
             Ps0 = Ps0_ini ;
             Psl_lim = Ps0_iniA ;
                                  
`ifdef _AGING_
             ftr0_qs = 0.0 ; ftr0_qs_dPs0 = 0.0 ;
             ftrl_qs = 0.0 ; ftrl_qs_dPsl = 0.0 ;
`endif

             //---------------------------------------------------*
             //* Calculation of Ps0. (beginning of Newton loop)
             //* - Fs0 : Fs0 = 0 is the equation to be solved.
             //* - dPs0 : correction value.
             //*-----------------//
             exp_bVbs = exp( beta * Vbs ) ;
             cfs1 = cnst1 * exp_bVbs ;
             flg_conv = 0 ;
             for ( lp_s0 = 1 ; lp_s0 <= lp_s0_max + 1 ; lp_s0 = lp_s0 + 1 ) begin

`ifdef _AGING_
               if( nt0s > 0.0 ) begin
                 T1 = ( Ps0 - Vbs ) * 0.5 ;
                 T2 = beta / Nsub * nt0s ;
                 ftr0_qs      = T2 * T1 ;
                 ftr0_qs_dPs0 = T2 * 0.5 ;
                 if( ftr0_qs < 0.0 ) begin
                     ftr0_qs = 0.0 ; ftr0_qs_dPs0 = 0.0 ;
                 end
               end
`endif
               
               Chi = beta * ( Ps0 - Vbs ) ;
               if( Chi < `znbd5 ) begin
                 //-------------------------------------------*
                 //* zone-D1/D2.  (Ps0)
                 //* - Qb0 is approximated to 5-degree polynomial.
                 //*-----------------//
                 fi = Chi * Chi * Chi * ( `cn_im53 + Chi * ( `cn_im54 + Chi * `cn_im55 ) ) ;
                 fi_dChi = Chi * Chi * ( 3 * `cn_im53 + Chi * ( 4 * `cn_im54 + Chi * 5 * `cn_im55 ) ) ;
                 fs01 = cfs1 * fi * fi ;
                 fs01_dPs0 = cfs1 * beta * 2 * fi * fi_dChi ;
                 fb = Chi * ( `cn_nc51 + Chi * ( `cn_nc52 + Chi * ( `cn_nc53 + Chi * ( `cn_nc54 + Chi * `cn_nc55 ) ) ) ) ;
                 fb_dChi = `cn_nc51
                         + Chi * ( 2 * `cn_nc52
                         + Chi * ( 3 * `cn_nc53
                         + Chi * ( 4 * `cn_nc54 + Chi * 5 * `cn_nc55 ) ) ) ;
`ifdef _AGING_
                 fs02 = sqrt( fb * fb + fs01 + ftr0_qs ) + `Small ;
                 fs02_dPs0 = ( beta * fb_dChi * 2 * fb + fs01_dPs0 + ftr0_qs_dPs0 ) / ( fs02 + fs02 ) ;
`else
                 fs02 = sqrt( fb * fb + fs01 ) + `Small ;
                 fs02_dPs0 = ( beta * fb_dChi * 2 * fb + fs01_dPs0 ) / ( fs02 + fs02 ) ;
`endif
               end else begin
                 //-------------------------------------------*
                 //* zone-D3.  (Ps0)
                 //*-----------------//
                 if( Chi < `large_arg ) begin // avoid exp_Chi to become extremely large //
                   exp_Chi = exp( Chi ) ;
                   fs01 = cfs1 * ( exp_Chi - 1.0e0 ) ;
                   fs01_dPs0 = cfs1 * beta * ( exp_Chi ) ;
                 end else begin
                   exp_bPs0 = exp( beta*Ps0 ) ;
                   fs01 = cnst1 * ( exp_bPs0 - exp_bVbs ) ;
                   fs01_dPs0 = cnst1 * beta * exp_bPs0 ;
                 end
`ifdef _AGING_
                 fs02 = sqrt( Chi - 1.0 + fs01 + ftr0_qs ) ;
                 fs02_dPs0 = ( beta + fs01_dPs0  + ftr0_qs_dPs0 ) / ( fs02 + fs02 ) ;
`else
                 fs02 = sqrt( Chi - 1.0 + fs01 ) ;
                 fs02_dPs0 = ( beta + fs01_dPs0 ) / ( fs02 + fs02 ) ;
`endif
               end // end of if( Chi ... ) else block //
               Fs0 = Vgp - Ps0 - fac1 * fs02 ;
               Fs0_dPs0 = - 1.0e0 - fac1 * fs02_dPs0 ;
               if( flg_conv == 0 ) begin // break
                 dPs0 = - Fs0 / Fs0_dPs0 ;
                    
                 //-------------------------------------------*
                 //* Update Ps0 .
                 //* - clamped to Vbs if Ps0 < Vbs .
                 //*-----------------//
                 dPlim = 0.5*`dP_max*(1.0 + `Fn_Max(1.0e0,abs(Ps0))) ;
                 if ( abs( dPs0 ) > dPlim ) dPs0 = dPlim * `Fn_Sgn( dPs0 ) ;
                 Ps0 = Ps0 + dPs0 ;
                 TX = Vbs + `ps_conv / 2 ;
                 if ( Ps0 < TX ) Ps0 = TX ;
                  
                 //-------------------------------------------*
                 //* Check convergence.
                 //* NOTE: This condition may be too rigid.
                 //*-----------------//
                 if( abs( dPs0 ) <= `ps_conv && abs( Fs0 ) <= `gs_conv ) begin
                   flg_conv = 1 ;
                 end
                        
               end // flg_conv == 0
             end // end of Ps0 Newton loop //
                      
             // Eliminate loop count to take account of the derivative loop //
             lp_s0 = lp_s0 - 1 ;
                   
             //-------------------------------------------*
             //* Procedure for diverged case.
             //*-----------------//
             if( flg_conv == 0 ) begin
               $write( "*** warning(HiSIM2): %M Went Over Iteration Maximum(Ps0)\n" ) ;
               $write( " Vbse   = %7.3f Vdse = %7.3f Vgse = %7.3f\n" ,Vbse , Vdse , Vgse ) ;
             end
                   
             if( Chi < `znbd5 ) begin
               //-------------------------------------------*
               //* zone-D1/D2. (Ps0)
               //* Xi0 := fdep0^2 = fb * fb  [D1,D2]
               //*-----------------//
               Xi0 = fb * fb + `epsm10 ;
               Xi0p12 = fb + `epsm10 ;
               Xi0p32 = fb * fb * fb + `epsm10 ;
             end else begin
               //-------------------------------------------*
               //* zone-D3. (Ps0)
               //*-----------------//
               flg_zone = 3 ;
               flg_noqi = 0 ;
                        
               //-----------------------------------*
               //* Xi0 := fdep0^2 = Chi - 1 = beta * ( Ps0 - Vbs ) - 1 [D3]
               //*-----------------//
               Xi0 = Chi - 1.0e0 ;
               Xi0p12 = sqrt( Xi0 ) ;
               Xi0p32 = Xi0 * Xi0p12 ;
   
             end // end of if( Chi  ... ) block //
             wk_Xi0p12 = Xi0p12;
                
             //-----------------------------------------------------------*
             //* Qb0 : Qb at source side.
             //* Qn0 : Qi at source side.
             //*-----------------//
`ifdef _AGING_
             Qt0 = (ftr0_qs <= 0) ? 0.0 : cnst0 * sqrt(ftr0_qs) ;
`endif
             Qb0 = cnst0 * Xi0p12 ;
             T1  = 1.0 / ( fs02 + Xi0p12 ) ;
             Qn0 = cnst0 * fs01 * T1 + `Small ;
                
             //-----------------------------------------------------------*
             //* zone-D1 and D2
             //*-----------------//
             if( Chi < `znbd5 ) begin
                 if( Chi < `znbd3 ) begin
                 //-------------------------------------------*
                 //* zone-D1. (Ps0)
                 //*-----------------//
                 flg_zone = 1 ;
                 flg_noqi = 1 ; //* !! to be revisited !! *//
                 Qiu = Qn0 ;
                 Qbu = Qb0 ;
                 Qdrat = 0.5 ;
                 Lred = 0.0e0 ;
               end else begin
                 //-------------------------------------------*
                 //* zone-D2 (Ps0)
                 //*-----------------//
                 flg_zone = 2 ;
                 flg_noqi = 0 ;
                 //-----------------------------------------------------------*
                 //* FD2 : connecting function for zone-D2.
                 //* - Qiu, Qbu, Qdrat and Lred should be interpolated later.
                 //*-----------------//
                 T1 = 1.0 / ( `znbd5 - `znbd3 ) ;
                 TX = T1 * ( Chi - `znbd3 ) ;
                 FD2 = TX * TX * TX * ( 10.0 + TX * ( -15.0 + TX * 6.0 ) ) ;
               end // end of zone-D2 //
             end
                
             //---------------------------------------------------*
             //* VgVt : Vgp - Vth_qi. ( Vth_qi is Vth for Qi evaluation. )
             //*-----------------//
             VgVt = Qn0 * Cox_inv ;
                  
             //-----------------------------------------------------------*
             //* make Qi=Qd=Ids=0 if VgVt <= VgVt_Small
             //*-----------------//
             if( VgVt <= `VgVt_Small && BYPASS_ENABLE ) begin
               flg_zone = 4 ;
               flg_noqi = 1 ;
               Psl = Ps0 ;
               Pds = 0.0 ;
               Qbu = Qb0 ;
               Qiu = 0.0 ;
               Qdrat = 0.5 ;
               Lred = 0.0 ;
               Ids = 0.0e0 ;
               if( UC_CORECIP ) begin
                 Fs0_dPS0Z = Vgp_dPS0Z ;
                 Ps0_dPS0Z = - Fs0_dPS0Z / Fs0_dPs0 ;
                 T1 = Vds * 0.5  ;
                 `Fn_SymAdd( Pzadd , T1 , PZADD0 , T2 ) 
                 Pzadd_dPS0Z = 0.0 ;
                 if( Pzadd < `epsm10 ) begin
                   Pzadd = `epsm10 ;
                   Pzadd_dPS0Z = 0.0 ;
                 end
                 Ps0z = Ps0 + Pzadd ;
                 Ps0z_dPS0Z = Ps0_dPS0Z + Pzadd_dPS0Z ;
                            
                 // calculate Newton correction: //
                 G = PS0Z_SCE - Ps0z ;
                 delta_PS0Z_SCE = - G / (1.0 - Ps0z_dPS0Z) ;
                 PS0Z_SCE = PS0Z_SCE + delta_PS0Z_SCE ;
                 NNN = NNN + 1 ;
                     
                 if( abs(delta_PS0Z_SCE) > PS0_SCE_tol
                 && (NNN < MAX_LOOP_SCE)  ) begin
                   //go to START_OF_SCE_LOOP;
                   START_OF_SCE_LOOP = 1 ;
                 end
                                   
               end
               //go to end_of_part_1 ;
               if(START_OF_SCE_LOOP==0) end_of_part_1 = 1 ;
                                 
             end
                               
           end // skip end_of_part_1  //
         end // End of 2nd SCE_LOOP //
         if( end_of_part_1 == 0 ) begin // skip to end_of_part_1 //
                             
           //-----------------------------------------------------------*
           //* Start point of Psl(= Ps0 + Pds) calculation.(label)
           //*-----------------//
// start_of_Psl:

           // Vdseff(begin) //
           Vdsorg = Vds ;
           T2 = qnsub_esi / ( Cox * Cox ) ;
           T5 = Vgpz - beta_inv - Vbsz ;
           T1 = 1.0e0 + 2.0 / T2 * T5 ;
           `Fn_SZ( T9 , T1 , 0.05 , T9 )
           T9 = T9 + `Small ;
           T3 = sqrt( T9 ) ;
           T10 = Vgpz + T2 * ( 1.0e0 - T3 ) ;
           `Fn_SZ( T10 , T10 , 0.01 , T0 )
           T10 = T10 + `epsm10 ;
           T1 = Vds / T10 ;
           T2 = `Fn_Pow( T1 , DDLTe - 1.0 ) ;
           T3 = 1.0 + T2 * T1 ;
           T4 = `Fn_Pow( T3 , 1.0 / DDLTe - 1.0 ) ;
           T6 = T4 * T3 ;
           Vdseff = Vds / T6 ;
           Vds = Vdseff ;
           // Vdseff(end) //

           exp_bVbsVds = exp( beta * ( Vbs - Vds ) ) ;
                       
           //---------------------------------------------------*
           //* Skip Psl calculation when Vds is very Small.
           //*-----------------//
           if( Vds <  0.0 ) begin
             Pds = 0.0 ;
             Psl = Ps0 ;
             start_of_loopl = 1 ;
           end
                                      if(start_of_loopl == 0) begin
                          
           //-----------------------------------------------------------*
           //* Initial guess for Pds( = Psl - Ps0 ).
           //*-----------------//
                
           if( flg_pprv == 0 ) begin
             //---------------------------------------------------*
             //* Analytical initial guess.
             //*-----------------//
             Pds_max = `Fn_Max( Psl_lim - Ps0 , 0.0e0 ) ;
             `Fn_SU( Pds_ini , Vds, (1.0e0 + `c_pslini_1) * Pds_max, `c_pslini_2, T1 ) 
             Pds_ini = `Fn_Min( Pds_ini , Pds_max ) ;
           end
           if ( Pds_ini < 0.0 ) Pds_ini = 0.0 ;
           else if ( Pds_ini > Vds ) Pds_ini = Vds ;
                   
           //---------------------------------------------------*
           //* Assign initial guess.
           //*-----------------//
           if( NNN == 0 ) begin
             Pds = Pds_ini ;
             Psl = Ps0 + Pds ;
           end else begin
             // take solution from previous PS0_SCE_loop as initial value //
             Pds = Psl - Ps0 ;
           end
           TX = Vbs + `ps_conv / 2 ;
           if ( Psl < TX ) Psl = TX ;
              
           //---------------------------------------------------*
           //* Calculation of Psl by solving Poisson eqn.
           //* (beginning of Newton loop)
           //* - Fsl : Fsl = 0 is the equation to be solved.
           //* - dPsl : correction value.
           //*-----------------//
           flg_conv = 0 ;
                    
           //---------------------------------------------------*
           //* start of Psl calculation. (label)
           //*-----------------//
                                      end if(start_of_loopl)  start_of_loopl = 0; // end of start_of_loopl
// start_of_loopl:
           for ( lp_sl = 1 ; lp_sl <= `lp_sl_max + 1 ; lp_sl = lp_sl + 1 ) begin

`ifdef _AGING_
             if( ntls > 0.0 ) begin
               T1 = ( Psl - Vbs ) * 0.5 ;
               T2 = beta / Nsub * ntls ;
               ftrl_qs      = T2 * T1 ;
               ftrl_qs_dPsl = T2 * 0.5 ;
               if( ftrl_qs < 0.0 ) begin
                   ftrl_qs = 0.0 ; ftrl_qs_dPsl = 0.0 ;
               end
             end
`endif
              
             Chi = beta * ( Psl - Vbs ) ;
             if( Chi  < `znbd5 ) begin
               //-------------------------------------------*
               //* zone-D2.  (Psl)
               //* - Qb0 is approximated to 5-degree polynomial.
               //*-----------------//
               fi = Chi * Chi * Chi * ( `cn_im53 + Chi * ( `cn_im54 + Chi * `cn_im55 ) ) ;
               fi_dChi = Chi * Chi * ( 3 * `cn_im53 + Chi * ( 4 * `cn_im54 + Chi * 5 * `cn_im55 ) ) ;
               cfs1 = cnst1 * exp_bVbsVds ;
               fsl1 = cfs1 * fi * fi ;
               fsl1_dPsl = cfs1 * beta * 2 * fi * fi_dChi ;
               fb = Chi * ( `cn_nc51 + Chi * ( `cn_nc52 + Chi * ( `cn_nc53 + Chi * ( `cn_nc54 + Chi * `cn_nc55 ) ) ) ) ;
               fb_dChi = `cn_nc51
                       + Chi * ( 2 * `cn_nc52
                       + Chi * ( 3 * `cn_nc53
                       + Chi * ( 4 * `cn_nc54 + Chi * 5 * `cn_nc55 ) ) ) ;
`ifdef _AGING_
               fsl2 = sqrt( fb * fb + fsl1 + ftrl_qs ) ;
               fsl2_dPsl = ( beta * fb_dChi * 2 * fb + fsl1_dPsl + ftrl_qs_dPsl ) / ( fsl2 + fsl2 ) ;
`else
               fsl2 = sqrt( fb * fb + fsl1 ) ;
               fsl2_dPsl = ( beta * fb_dChi * 2 * fb + fsl1_dPsl ) / ( fsl2 + fsl2 ) ;
`endif
             end else begin
               //-------------------------------------------*
               //* zone-D3.  (Psl)
               //*-----------------//
               Rho = beta * ( Psl - Vds ) ;
//             exp_Rho = exp( Rho ) ;
               `Fn_DExp( exp_Rho , Rho , T0) 
               fsl1 = cnst1 * ( exp_Rho - exp_bVbsVds ) ;
               fsl1_dPsl = cnst1 * beta * ( exp_Rho ) ;
               Xil = Chi - 1.0e0 ;
`ifdef _AGING_
               fsl2 = sqrt( Xil + fsl1  + ftrl_qs ) ;
               fsl2_dPsl = ( beta + fsl1_dPsl + ftrl_qs_dPsl ) / ( fsl2 + fsl2 ) ;
`else
               fsl2 = sqrt( Xil + fsl1 ) ;
               fsl2_dPsl = ( beta + fsl1_dPsl ) / ( fsl2 + fsl2 ) ;
`endif
             end
             Fsl = Vgp - Psl - fac1 * fsl2 ;
             Fsl_dPsl = - 1.0e0 - fac1 * fsl2_dPsl ;
             if( flg_conv == 0 ) begin // break
               dPsl = - Fsl / Fsl_dPsl ;
                  
               //-------------------------------------------*
               //* Update Psl .
               //* - clamped to Vbs if Psl < Vbs .
               //*-----------------//
               dPlim = 0.5*`dP_max*(1.0 + `Fn_Max(1.0e0,abs(Psl))) ;
               if ( abs( dPsl ) > dPlim ) dPsl = dPlim * `Fn_Sgn( dPsl ) ;
               Psl = Psl + dPsl ;
               TX = Vbs + `ps_conv / 2 ;
               if ( Psl < TX ) Psl = TX ;
                
               //-------------------------------------------*
               //* Check convergence.
               //* NOTE: This condition may be too rigid.
               //*-----------------//
               if( abs( dPsl ) <= `ps_conv && abs( Fsl ) <= `gs_conv ) begin
                 flg_conv = 1 ;
               end
             end // flg_conv==0
           end // end of Psl Newton loop //
                    
           // Eliminate loop count to take account of the derivative loop //
           lp_sl = lp_sl - 1 ;
                 
           //-------------------------------------------*
           //* Procedure for diverged case.
           //*-----------------//
           if( flg_conv == 0 ) begin
             $write( "*** warning(HiSIM2): %M Went Over Iteration Maximum(Psl)\n" ) ;
             $write( " Vbse   = %7.3f Vdse = %7.3f Vgse = %7.3f\n" ,Vbse , Vdse , Vgse ) ;
           end
                 
           if( Chi < `znbd5 ) begin
             //-------------------------------------------*
             //* zone-D1/D2. (Psl)
             //*-----------------//
             Xil = fb * fb + `epsm10 ;
             Xilp12 = fb + `epsm10 ;
             Xilp32 = fb * fb * fb + `epsm10 ;
           end else begin
             //-------------------------------------------*
             //* zone-D3. (Psl)
             //*-----------------//
             Xil = Chi - 1.0e0 ;
             Xilp12 = sqrt( Xil ) ;
             Xilp32 = Xil * Xilp12 ;
                
           end
              
           //---------------------------------------------------*
           //* Assign Pds.
           //*-----------------//
           Pds = Psl - Ps0 ;
           if( Pds < 0.0 ) begin
             Pds = Pds + `epsm10 ;
             Psl = Pds + Ps0 ;
           end
               
           // Vdseff //
           Vds = Vdsorg;
           if( UC_CORECIP ) begin
                 
             // For multi level Newton method to calculate PS0Z_SCE        //
             // remember that for the inner Newton:                        //
             // Fs0(PS0Z_SCE,Ps0) = Vgp(PSOZ_SCE) - Ps0 - fac1 * fs02(Ps0) //
             // -> dPs0/dPS0Z_SCE = - (dFs0/dPS0Z_SCE) / (dFs0/dPs0)       //
             // and                                                        //
             // Fsl(PS0Z_SCE,Psl) = Vgp(PS0Z_SCE) - Psl - fac1 * fsl1(Psl) //
             // -> dPsl/dPS0Z_SCE = - (dFsl/dPS0Z_SCE) / (dFsl/dPsl)       //
                 
             // Outer Newton:                                                                       //
             // PS0Z_SCE = Ps0 + Pzadd(Ps0,Psl)                                                     //
             // -> G(PS0Z_SCE) := PS0Z_SCE - Ps0(PS0Z_SCE) - Pzadd(Ps0(PS0Z_SCE),Psl(Ps0Z_SCE)) = 0 //
             // -> Newton correction delta_PS0Z_SCE from:                                           //
             //         (1.0 - dPs0/dPS0Z_SCE - dPzadd/dPS0Z_SCE) * delta_PS0Z_SCE = - G            //
             Fs0_dPS0Z = Vgp_dPS0Z ;
             Ps0_dPS0Z = - Fs0_dPS0Z / Fs0_dPs0 ;
             Fsl_dPS0Z = Vgp_dPS0Z ;
             Psl_dPS0Z = - Fsl_dPS0Z / Fsl_dPsl ;
             if( Pds < `ps_conv ) begin
               Pds_dPS0Z = 0.0 ;
             end else begin
               Pds_dPS0Z = Psl_dPS0Z - Ps0_dPS0Z ;
             end
             T1 = ( Vds - Pds ) / 2 ;
             `Fn_SymAdd( Pzadd , T1 , PZADD0 , T2 ) 
             Pzadd_dPS0Z = T2 * ( - Pds_dPS0Z) ;
             if( Pzadd < `epsm10 ) begin
               Pzadd = `epsm10 ;
               Pzadd_dPS0Z = 0.0 ;
             end
             Ps0z = Ps0 + Pzadd ;
             Ps0z_dPS0Z = Ps0_dPS0Z + Pzadd_dPS0Z ;
                        
             // calculate Newton correction: //
             G = PS0Z_SCE - Ps0z ;
             delta_PS0Z_SCE = - G / (1.0 - Ps0z_dPS0Z) ;
             PS0Z_SCE = PS0Z_SCE + delta_PS0Z_SCE ;
             NNN = NNN + 1 ;
                 
             if( abs(delta_PS0Z_SCE) > PS0_SCE_tol
             && (NNN < MAX_LOOP_SCE)  ) begin
               //go to START_OF_SCE_LOOP;
               START_OF_SCE_LOOP = 1 ;
             end
                               
           end
                             
         end // skip end_of_part_1  //
       end // End of 1st SCE_LOOP //
       if( end_of_part_1 == 0 ) begin // skip to end_of_part_1 //
                           
         //-----------------------------------------------------------*
         //* Evaluate Idd.
         //* - Eta : substantial variable of QB'/Pds and Idd/Pds.
         //* - note: Eta   = 4 * GAMMA_{hisim_0}
         //*-----------------//
         T1 = beta / Xi0 ;
         Eta = T1 * Pds ;
           
         // ( Eta + 1 )^n // 
         Eta1 = Eta + 1.0e0 ;
         Eta1p12 = sqrt( Eta1 ) ;
         Eta1p32 = Eta1p12 * Eta1 ;
         Eta1p52 = Eta1p32 * Eta1 ;
                 
         // 1 / ( ( Eta + 1 )^n + 1 ) //
         Zeta12 = 1.0e0 / ( Eta1p12 + 1.0e0 ) ;
         Zeta32 = 1.0e0 / ( Eta1p32 + 1.0e0 ) ;
         Zeta52 = 1.0e0 / ( Eta1p52 + 1.0e0 ) ;
                
         //---------------------------------------------------*
         //* F00 := PS00/Pds(n=1/2)
         //*-----------------//
         F00 = Zeta12 / Xi0p12 ;
            
         //---------------------------------------------------*
         //* F10 := PS10/Pds(n=3/2)
         //*-----------------//
         T1 = 3.0e0 + Eta * ( 3.0e0 + Eta ) ;
         F10 = `C_2o3 * Xi0p12 * Zeta32 * T1 ;
            
         //---------------------------------------------------*
         //* F30 := PS30/Pds(n=5/2)
         //*-----------------//
         T1 = 5e0 + Eta * ( 10e0 + Eta * ( 10e0 + Eta * ( 5e0 + Eta ) ) ) ;
         F30 = 4e0 / ( 15e0 * beta ) * Xi0p32 * Zeta52 * T1 ;
            
         //---------------------------------------------------*
         //* F11 := PS11/Pds.
         //*-----------------//
         F11 = Ps0 * F10 + `C_2o3 * beta_inv * Xilp32 - F30 ;
            
         //---------------------------------------------------*
         //* Fdd := Idd/Pds.
         //*-----------------//
         T1 = Vgp + beta_inv - 0.5e0 * ( 2.0e0 * Ps0 + Pds ) ;
         T2 = - F10 + F00 ;
         T3 = beta * Cox ;
         T4 = beta * cnst0 ;
         Fdd = T3 * T1 + T4 * T2 ;
             
         //---------------------------------------------------*
         //*  Idd:
         //*-----------------//
         Idd = Pds * Fdd ;
             
         //-----------------------------------------------------------*
         //* Skip CLM and integrated charges if zone==D1
         //*-----------------//
         if( flg_zone == 1 ) begin
           start_of_mobility = 1 ;
         end
                                    if(start_of_mobility == 0) begin
         //-----------------------------------------------------------*
         //* Channel Length Modulation. Lred: \Delta L
         //*-----------------//
         if( UC_CLM2 < `epsm10 && UC_CLM3 < `epsm10 ) begin
           Lred = 0.0e0 ;
           Psdl = Psl ;
           if( Psdl > Ps0 + Vds - `epsm10 ) begin
             Psdl = Ps0 + Vds - `epsm10 ;
           end
         end else begin
           T1 = wdpl ;
           T8 = sqrt (Psl - Vbs) ;
           Wd = T1 * T8 ;
           T0 = 1.0 / Wd ;
           T1 = Qn0 * T0 ;
           T2 = UC_CLM3 * T1 ;
           T3 = UC_CLM3 * T0 ;
           T5 = UC_CLM2 * q_Nsub + T2 ;
           T1 = 1.0 / T5 ;
           T4 = `C_ESI * T1 ;
           T1 = (1.0e0 - UC_CLM1) ;
           Psdl = UC_CLM1 * (Vds + Ps0) + T1 * Psl ;
           if( Psdl > Ps0 + Vds - `epsm10 ) begin
             Psdl = Ps0 + Vds - `epsm10 ;
           end
           T6 = Psdl - Psl ;
           T3 = beta * Qn0 ;
           T1 = 1.0 / T3 ;
           T5 = Idd * T1 ;
           T10 = q_Nsub / `C_ESI ;
           T1 = `C_E0_p2 ;  // E0^2
           T2 = 1.0 / Leff ;
           T11 = (2.0 * T5 + 2.0 * T10 * T6 * T4 + T1 * T4) * T2 ;
           T7 = T11 * T4 ;
           T11 = 4.0 * (2.0 * T10 * T6 + T1) ;
           T8 = T11 * T4 * T4 ;
           T9 = sqrt (T7 * T7 + T8);
           Lred = 0.5 * (- T7 + T9) ;
                
           //---------------------------------------------------*
           //* Modify Lred for symmetry.
           //*-----------------//
           T1 = Lred ;
           Lred = FMDVDS * T1 ;

         end
              
         // CLM5 & CLM6 //
         Lred = Lred * clmmod ;
              
         //---------------------------------------------------*
         //* Qbu : -Qb in unit area.
         //*-----------------//
         T1 = Vgp + beta_inv ;
         T2 = T1 * F10 - F11 ;
         Qbnm = cnst0 * ( cnst0 * ( 1.5e0 - ( Xi0 + 1.0e0 ) - 0.5e0 * beta * Pds )
              + Cox * T2 ) ;
         T1 = beta ;
         Qbu = T1 * Qbnm / Fdd ;
         //---------------------------------------------------*
         //* preparation for Qi and Qd.
         //* - DtPds: Delta * Pds ;
         //* - Achi: (1+Delta) * Pds ;
         //*-----------------//
         T1 = 2.0e0 * fac1 ;
         DtPds = T1 * ( F10 - Xi0p12 ) ;
         Achi = Pds + DtPds ;
              
         //-----------------------------------------------------------*
         //* Alpha : parameter to evaluate charges.
         //* - Achi: (1+Delta) * Pds ;
         //* - clamped to 0 if Alpha < 0.
         //*-----------------//
         T1 = 1.0 / VgVt ;
         T2 = Achi * T1 ;
         T3 = 1.0e0 - T2 ;
         TX = 1.0 - T3 ;
         `Fn_CP( TY , TX , 1.0 , 4 , T4 ) 
         Alpha = 1.0 - TY ;
            
         //-----------------------------------------------------------*
         //* Qiu : -Qi in unit area.
         //*-----------------//
         Qinm = 1.0e0 + Alpha * ( 1.0e0 + Alpha ) ;
         Qidn = `Fn_Max( 1.0e0 + Alpha , `epsm10 ) ;
         T1 = `C_2o3 * VgVt * Qinm / Qidn ;
         Qiu = T1 * Cox ;
            
         //-----------------------------------------------------------*
         //* Qdrat : Qd/Qi
         //*-----------------//
         Qdnm = 0.5e0 + Alpha ;
         Qddn = Qidn * Qinm ;
         Quot = 0.4e0 * Qdnm  / Qddn ;
         Qdrat = 0.6e0 - Quot ;
         if( Qdrat > 0.5e0 ) begin
           Qdrat = 0.5e0 ;
         end
               
         //-----------------------------------------------------------*
         //* Interpolate charges and CLM for zone-D2.
         //*-----------------//
         if( flg_zone == 2 ) begin
           Qbu = FD2 * Qbu + ( 1.0 - FD2 ) * Qb0 ;
           if( Qbu < 0.0 ) begin
             Qbu = 0.0 ;
           end
           Qiu = FD2 * Qiu + ( 1.0 - FD2 ) * Qn0 ;
           if( Qiu < 0.0 ) begin
             Qiu = 0.0 ;
           end
           Qdrat = FD2 * Qdrat + ( 1.0 - FD2 ) * 0.5e0 ;
                 
           // note: Lred=0 in zone-D1 //
           Lred = FD2 * Lred ;
         end // end of flg_zone==2 if-block //
              
                                    end if(start_of_mobility)  start_of_mobility = 0; // end of start_of_mobility
// start_of_mobility:
         Lch = Leff - Lred ;
         if( Lch < 1.0e-9 ) begin
             Lch = 1.0e-9 ;   
         end 

             
              
         //-----------------------------------------------------------*
         //* Muun : universal mobility. (CGS unit)
         //*-----------------//

         T1 = ndep_o_esi / `C_m2cm ;
         T2 = ninv_o_esi / `C_m2cm ;
         T0 = Ninvde ;
         Pdsz = sqrt(Pds*Pds + VZADD0) - sqrt(VZADD0) ; 
         T4 = 1.0 + (Pdsz) * T0 ;   // for DC symmetry

`ifdef _AGING_
         T3 = TRAPN / `C_ESI / `C_m2cm ;
         T5 = T1 * Qbu + T2 * Qiu + T3 * Qt0 ;
`else
         T5 = T1 * Qbu + T2 * Qiu ;
`endif
         T3 = T5 / T4 ;
         Eeff = T3 ;
         T5 = `Fn_Pow( Eeff , MUEPH0 - 1.0e0 ) ;
         T8 = T5 * Eeff ;
         T7 = `Fn_Pow( Eeff , muesr - 1.0e0 ) ;
         T6 = T7 * Eeff ;
         T9 = `C_QE * `C_m2cm_p2 ;
         Rns = Qiu / T9 ;
`ifdef _AGING_
         T10 = Qiu / (Qiu + Qt0) ;
         Rns = Rns * T10 ;
`endif

         T1 = 1.0e0 / ( UC_MUECB0 + UC_MUECB1 * Rns / 1.0e11 )
            + mphn0 * T8 + T6 / UC_MUESR1 ;
         Muun = 1.0e0 / T1 ;
            
         //  Change to MKS unit //
         Muun = Muun / `C_m2cm_p2 ;
         //-----------------------------------------------------------*
         //* Mu : mobility
         //*-----------------//
         T2 = beta * Qn0 * Lch ;
         T1 = 1.0e0 / T2 ;
         TY = Idd * T1 ;
         T2 = 0.2 * Vmaxe /  Muun ;
         Ey = sqrt( TY * TY + T2 * T2 ) ;
         T4 = 1.0 / Ey ;
         Em = Muun * Ey ;
         T1  = Em / Vmaxe ;
         // note: bb = 2 (electron) ;1 (hole) //
         if( 1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10 ) begin
           T3 = 1.0e0 ;
         end else if( 2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10 ) begin
           T3 = T1 ;
         end else begin
           T3 = `Fn_Pow( T1 , BB - 1.0e0 ) ;
         end
         T2 = T1 * T3 ;
         T4 = 1.0e0 + T2 ;
         if( 1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10 ) begin
           T5 = 1.0 / T4 ;
           T6 = T5 / T4 ;
         end else if( 2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10 ) begin
           T5 = 1.0 / sqrt( T4 ) ;
           T6 = T5 / T4 ;
         end else begin
           T6 = `Fn_Pow( T4 , ( - 1.0e0 / BB - 1.0e0 ) ) ;
           T5 = T4 * T6 ;
         end
         T7 = Muun / Vmaxe * T6 * T3 ;
         Mu = Muun * T5 ;
            
// end_of_mobility:
            
         //-----------------------------------------------------------*
         //* Ids: channel current.
         //*-----------------//
         betaWL = weff_nf * beta_inv / Lch ;
         Ids0 = betaWL * Idd * Mu ;
            
//     end // skip to end_of_part_1 //

         //-----------------------------------------------------------*
         //* Adding parasitic components to the channel current.
         //*-----------------//
         if( COPT>0 && PTL != 0 ) begin
           T1 =  0.5 * ( Vds - Pds ) ;
           `Fn_SymAdd( T6 , T1 , 0.01 , T2 ) 
           T1     = 1.1 - ( Ps0 + T6 );
           `Fn_SZ( T2 , T1 , 0.05 , T0 ) 
           T2 = T2 + `Small ;
           T0 = beta * ptl0 ;
           T3 = Cox * T0 ;
           T0 = pow( T2 , PTP ) ;
           T9 = T3 * T0 ;
           T4 = 1.0 + Vdsz * PT2 ;
           T0 = pt40 ;
           T5 = Ps0 + T6 - Vbsz ;
           T4 = T4 + Vdsz * T0 * T5 ;
           T6 = T9 * T4 ;
           T9 = T6 ;
         end else begin
           T9 = 0.0 ;
         end
         if( GDL != 0 ) begin
           T1 = beta * gdl0 ;
           T2 = Cox * T1 ;
           T8 = T2 * Vdsz ;
         end else begin
           T8 = 0.0 ;
         end
         if(( T9 + T8 ) > 0.0 ) begin
           Idd1 = Pds * ( T9 + T8 ) ;
           IdsPT0 = betaWL * Idd1 * Mu ;
           Ids0   = Ids0 + IdsPT0 ;
         end else begin
           IdsPT0 = 0.0 ;
         end
            
         // (note: rpock procedure was removed. (2006.04.20) //
         if( flg_rsrd == 2 ) begin
           Rdd  = Rde ;
           T0 = Rdd * Ids0 ;
           T1 = Vds + `Small ;
           T2 = 1.0 / T1 ;
           T3 = 1.0 + T0 * T2 ;
           T4 = 1.0 / T3 ;
           Ids = Ids0 * T4 ;
         end else begin
           Ids = Ids0 ;
         end
         Ids = Ids + Gdsmin * Vds ;
             
         //-----------------------------------------------------------*
         //* STI
         //*-----------------//
         if( COISTI != 0 ) begin
           //---------------------------------------------------*
           //* dVthSCSTI : Short-channel effect induced by Vds(STI).
           //*-----------------//
           T1 = `C_ESI * Cox_inv ;
           T2 = wdpl ;
           T3 =  lgatesm - PARL2 ;
           T4 = 1.0 / (T3 * T3) ;
           T5 = 2.0 * (VBI - Pb20b) * T1 * T2 * T4 ;
           dVth0 = T5 * sqrt_Pbsum ;
           T4 = UC_SCSTI1 ;
           T6 = UC_SCSTI2 ;
           T1 = T4 + T6 * Vdsz ;
           dVthSCSTI = dVth0 * T1 ;
           T1 = UC_VTHSTI - VDSTI * Vds ;
           Vgssti = Vgsz - Vfb + T1 + dVthSCSTI ;
                  
           costi3 = costi0_p2 * Cox_inv * Cox_inv ;
           costi4 = costi3 * beta * 0.5 ;
           costi5 = costi4 * beta * 2.0 ;
           T11 = beta * 0.25 ;
           T10 = beta_inv - costi3 * T11 + Vfb - UC_VTHSTI - dVthSCSTI + `Small ;
           T1 = Vgsz - T10 - `psisti_dlt ;
           T0 = `Fn_Sgn(T10) ;
           T2 = sqrt (T1 * T1 + T0 * 4.0 * T10 * `psisti_dlt) ;
           T3 = T10 + 0.5 * (T1 + T2) - Vfb + UC_VTHSTI + dVthSCSTI - Vbsz ;
           T4 = beta * T3 - 1.0 ;
           T5 = 4.0 / costi5 ;
           T1 = 1.0 + T4 * T5 ;
           `Fn_SZ( T1 , T1, 1.0e-2, T2) 
           T1 = T1 + `Small ;
           costi6 = sqrt (T1) ;
           T0 = costi4 * (1.0 - costi6) ;
           Psasti = Vgssti + T0 ;
           T0 = 1.0 / (beta + 2.0 / (Vgssti + `Small)) ;
           Psbsti = ln (1.0 / costi1 / costi3 * (Vgssti * Vgssti)) * T0 ;
           T3 = Psbsti / (Vgssti + `Small) ;
           Psab = Psbsti - Psasti - `sti2_dlt ;
           T0 = sqrt (Psab * Psab + 4.0 * `sti2_dlt * Psbsti) ;
           Psti = Psbsti - 0.5 * (Psab + T0) ;
           T1 = 1.0 / T0 ;
           T0 = costi1 * exp (beta * Psti) ;
           T1 = beta * (Psti - Vbsz) - 1.0 + T0 ;
           `Fn_SZ( T1 , T1, 1.0e-2, T0) 
           T1 = T1 + `epsm10 ;
           sq1sti = sqrt (T1);
           T1 = beta * (Psti - Vbsz) - 1.0;
           `Fn_SZ( T1 , T1, 1.0e-2, T0) 
           T1 = T1 + `epsm10 ;
           sq2sti = sqrt (T1);
           Qn0sti = costi0 * (sq1sti - sq2sti) ;
                  
           // T1: Vdsatsti //
           T1 = Psasti - Psti ;
           `Fn_SZ( T1 , T1 , 1.0e-1 , T2 ) 
           T1 = T1 + `epsm10 ;
           TX = Vds / T1 ;
           `Fn_CP( TY , TX , 1.0 , 4 , T2 ) 
           costi7 = 2.0 * UC_WSTI * NF * beta_inv ;
           T1 = Lch ;
           Idssti = costi7 * Mu * Qn0sti * TY / T1;
           Ids = Ids + Idssti ;
               
         end

     end // skip to end_of_part_1 //


     if( end_of_part_1 == 0 ) begin
           
       //----------------------------------------------------------*
       //* induced gate noise. ( Part 1/3 )
       //*----------------------//
       if( COIGN != 0 && COTHRML != 0 && UC_CODEP == 0 ) begin
         kusai00 = VgVt * VgVt ;
         kusaidd = 2.0e0 * beta_inv * Cox_inv * Idd ;
         kusaiL = kusai00 - kusaidd ;
         `Fn_SZ( kusai00 , kusai00 , 1.0e-3 , T0 ) 
         `Fn_SZ( kusaiL , kusaiL , 1.0e-3 , T0 ) 
         kusai00L = kusai00 - kusaiL ;
         if ( Qn0 < `epsm10 || kusai00L < `epsm10 ) flg_ign = 0 ;
         else flg_ign = 1 ;
       end
                
       //-----------------------------------------------------------*
       //* End of PART-1. (label)
       //*-----------------//
     end // skip end_of_part_1 //
     end_of_part_1 = 0;

     //-----------------------------------------------------------*
     //* Adding punchthrough current. 
     //*-----------------//
     Idsorg = Ids ;
     IdsPT1 = 0.0 ;
     if(COPT > 0 && MUPT > 0.0) begin
`include "HSM2_eval_newPT.inc"
     end //
     IdsPT  = IdsPT0 + IdsPT1 ;

     // Qiu for noise calc.
     Qiu_noi = Qiu ;


   end // End of normal mode  MOSFET //
     //----------------------------------------------------------*
     //* Evaluate integrated charges in unit [C].
     //*----------------------//
     T1 = - weffcv_nf * Leff_cv ;
     Qb = T1 * Qbu ;
     Qi = T1 * Qiu ;
     Qd = Qi * Qdrat ;

     // Qi for noise calc.
     Qi_noi = T1 * Qiu_noi ;
        
     //-----------------------------------------------------------*
     //* Modified potential for symmetry.
     //*-----------------//
     T1 =  ( Vds - Pds ) / 2 ;
     `Fn_SymAdd( Pzadd , T1 , PZADD0 , T2 ) 
     if( Pzadd < `epsm10 ) begin
         Pzadd = `epsm10 ;
     end
     Ps0z = Ps0 + Pzadd ;

     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //* PART-2: Substrate / gate / leak currents
     //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
        
     //-----------------------------------------------------------*
     //* Isub : substrate current induced by impact ionization.
     //*-----------------//
     if( COISUB == 0 ) begin 
       // Accumulation zone or nonconductive case, in which Ids==0. //
       Isub = 0.0e0 ;
     end else begin
       //-------------------------------------------*
       //* Conductive case.
       //*-----------------//
       if( UC_SUB1 > 0.0e0 && UC_VMAX > 0.0e0 ) begin
         T1 = vg2const * Vgp ;
         T3 = qnsub_esi / (Cox0 * Cox0) ;
         T4 = 2.0 / qnsub_esi * (Cox0 * Cox0) ;
         T5 = T1 - beta_inv - xvbs * Vbsz ;
         T6 = 1.0 + T4 * T5 ;
         T7 = 2.0 * ( 1.0 + T4 ) ;
         `Fn_SL_CP( T6 , T6 , `Small, T7 , 4 , T0 )
         T6 = (T6 <=0 ) ? 0.0 : sqrt( T6 ) ;
         Psislsat = T1 + T3 * ( 1.0 - T6 ) ;
         T2 = Lgate / (xgate + Lgate) ;
         Psisubsat = UC_SVDS * Vdsz + Ps0z - T2 * Psislsat ;
         `Fn_SZ( Psisubsat , Psisubsat, 1.0e-3, T9 ) 
         Psisubsat = Psisubsat + `Small ;

         xsubtmp = 1.0 + UC_SUBTMP * (TTEMP-KTNOM) ; 
         xsubtmp = ( xsubtmp <= 1.0e-3 ) ? 1.0e-3 : xsubtmp ;
         T5 = xsub1 / xsubtmp ;
         T6 = xsub2 * xsubtmp ;
         T2 = exp( - T6 / Psisubsat ) ;

         Isub = T5 * Psisubsat * Ids * T2 ;
       end else begin
         Isub = 0.0e0 ;
       end // end of if( UC_SUB1 ... ) else block. //
     end

`ifdef _AGING_
      // ---------------------------------------------------//
      // * stress simulation
      `include "HSM2_eval_aging.inc"
      //*-----------------//

      // restore Ps0 , Psl , Vdseff
      Ps0_prv = Ps0 ;
      Vtraplx_prv =  Vdseff + Ps0 - Psl ;
`endif

     //---------------------------------------------------*
     //* Impact-Ionization Induced Bulk Potential Change(IBPC)
     //*-----------------//
     if( Isub > 0e0 && UC_IBPC1 != 0e0 && UC_CODEP == 0 ) begin
            
       // delta Vbs //
       T0 = 1e0 + UC_IBPC2 * dVth ;
       dVbsIBPC = UC_IBPC1 * T0 * Isub ;
                
       // dG3 & dG4 //
       T10 = 1e0 / Xi0 ;
       T1 = beta * dVbsIBPC * T10 ;
       T10 = 1e0 / Xil ;
       T2 = beta * dVbsIBPC * T10 ;
       dG3 = cnst0 * ( Xilp32 * T2 - Xi0p32 * T1 ) ;
       dG4 = cnst0 * 0.5 * ( - Xilp12 * T2 + Xi0p12 * T1 ) ;
           
       // Add IBPC current into Ids //
       dIdd = dG3 + dG4 ;
       IdsIBPC = betaWL * dIdd * Mu ;
               
     end // End if(IBPC) //
             
     //-----------------------------------------------------------*
     //* Igate : Gate current induced by tunneling.
     //*-----------------//
     if( COIIGS == 0 ) begin
       Igate = 0.0 ;
       Igs = 0.0 ;
       Igd = 0.0 ;
       Igb = 0.0 ;
       GLPART1 = 0.0 ;
     end else begin
               
       // Igate //
       if( flg_noqi == 0 ) begin
         Psdlz = Ps0z + Vdsz - `epsm10 ;
         T1 = Vgsz - Vfb + MKS_GLEAK4 * (dVth - dPpg) * Leff - Psdlz * UC_GLEAK3 ;
         T3 = 1.0 / Tox0 ;
         T2 = T1 * T3 ;
         T3 = 1.0 / MKS_GLEAK5 ;
         if( VgVt <= `VgVt_Small ) begin
           Ey = 0.0 ;
         end
         T7 = 1.0 + Ey * T3 ;
         Etun = T2 * T7 ;
         `Fn_SZ( Etun , Etun , `igate_dlt , T5 ) 
         `Fn_SZ( T3 , Vgsz , 1.0e-3 , T4 ) 
         T3 = T3 - VZADD0 ;
         TX = T3 / `cclmmdf ;
         T2 = 1.0 +  TX * TX ;
         T1 = 1.0 - 1.0 / T2 ;
         Etun = Etun * T1 ;
         T0 = Leff * weff_nf ;
         T7 = MKS_GLEAK7 / (MKS_GLEAK7 + T0) ;
         T6 = UC_GLEAK6 ;
         T9 = T6 / (T6 + Vdsz) ;
         T1 = - UC_GLEAK2 * Egp32 / (Etun + `Small) ;
         if( T1 < - `EXP_THR ) begin
           Igate = 0.0 ;
         end else begin
           T2 = exp ( T1 ) ;
           T3 = UC_GLEAK1 / Egp12 * `C_QE * T0 ;
           T4 =  T2 * T3 * sqrt ((Qiu_noi + Cox0 * `VgVt_Small ) / cnst0) ;
           T5 = T4 * Etun ;
           T10 = T5 * Etun ;
           Igate = T7 * T9 * T10 ;
         end
       end else begin
         Igate = 0.0 ;
       end
             
       // Igs //
       T0 = - UC_GLKSD2 * Vgs + MKS_GLKSD3 ;
       T2 = exp (Tox0 * T0);
       T0 = Vgs / Tox0 / Tox0 ;
       T3 = Vgs * T0 ;
       T4 = UC_GLKSD1 / 1.0e6 * weff_nf ;
       Igs = T4 * T2 * T3 ;
       if( Vgs >= 0.0e0 ) begin
         Igs = Igs * -1.0 ;
       end
           
       // Igd //
       T1 = Vgs - Vds ;
       T0 = - UC_GLKSD2 * T1 + MKS_GLKSD3 ;
       T2 = exp (Tox0 * T0);
       T0 = T1 / Tox0 / Tox0 ;
       T3 = T1 * T0 ;
       T4 = UC_GLKSD1 / 1.0e6 * weff_nf ;
       Igd = T4 * T2 * T3 ;
       if( T1 >= 0.0e0 ) begin
         Igd = Igd * -1.0 ;
       end
           
       // Igb //
       Etun = (- Vgs + Vbs + Vfb + GLKB3 ) / Tox0 ;
       `Fn_SZ( Etun , Etun, `igate_dlt, T5) 
       Etun = Etun + `Small ;
       T1 = - UC_GLKB2 / Etun ;
       if( T1 < - `EXP_THR ) begin
         Igb = 0.0 ;
       end else begin
         T2 = exp ( T1 );
         T3 =  UC_GLKB2 / ( Etun * Etun ) * T2 ;
         T3 = UC_GLKB1 * weff_nf * Leff ;
         Igb = T3 * Etun * Etun * T2 ;
       end
       GLPART1 = 0.5 ;
               
     end // if( coiigs == 0 ) //
             
     //-----------------------------------------------------------*
     //* Igidl : GIDL
     //*-----------------//
     if( COGIDL == 0 ) begin
       Igidl = 0.0e0 ;
     end else begin
       T3 = qnsub_esi2 ;
       Qb0 = sqrt (T3 * (Pb20 - Vbsz2)) ;
       Qb0Cox = GIDL6 * Qb0 * Cox_inv ;
       T1 = GIDL3 * (Vds  + GIDL4) - Vgs + (dVthSC + dVthLP) * GIDL5 - Qb0Cox ;
       T2 = 1.0 / Tox0 ;
       E1 = T1 * T2 ;
       `Fn_SZ( Egidl , E1, `eef_dlt, T5) 
       Egidl = Egidl + `Small ;
       T6 = pow(Egidl,GIDL7) ;
       T0 = - UC_GIDL2 * Egp32 / T6 ;
       if( T0 < - `EXP_THR ) begin
         Igidl = 0.0 ;
       end else begin
         T1 = exp ( T0 ) ;
         T2 = UC_GIDL1 / Egp12 * `C_QE * weff_nf ;
         Igidl = T2 * Egidl * Egidl * T1 ;
       end
       Vdb = Vds - Vbs ;
       if( Vdb > 0.0 ) begin
         T2 = Vdb * Vdb ;
         T4 = T2 * Vdb ;
         T0 = T4 + `C_gidl_delta ;
         T5 = T4 / T0 ;
         Igidl = Igidl * T5 ;
       end else begin
         Igidl = 0.0 ;
       end
             
     end
           
     //-----------------------------------------------------------*
     //* Igisl : GISL
     //*-----------------//
     if( COGIDL == 0) begin
       Igisl = 0.0e0 ;
     end else begin
       T1 = GIDL3 * ( - Vds + GIDL4 )
          - ( Vgs - Vds ) + ( dVthSC + dVthLP ) * GIDL5 - Qb0Cox ;
       T2 = 1.0 / Tox0 ;
       E1 = T1 * T2 ;
       `Fn_SZ( Egisl , E1, `eef_dlt, T5) 
       Egisl = Egisl + `Small ;
       T6 = pow(Egisl,GIDL7) ;
       T0 = - UC_GIDL2 * Egp32 / T6 ;
       if( T0 < - `EXP_THR ) begin
         Igisl = 0.0 ;
       end else begin
         T1 = exp ( T0 ) ;
         T2 = UC_GIDL1 / Egp12 * `C_QE * weff_nf ;
         Igisl = T2 * Egisl * Egisl * T1 ;
       end
       Vsb = - Vbs ;
       if( Vsb > 0.0 ) begin
         T2 = Vsb * Vsb ;
         T4 = T2 * Vsb ;
         T0 = T4 + `C_gidl_delta ;
         T5 = T4 / T0 ;
         Igisl = Igisl * T5 ;
       end else begin
         Igisl = 0.0 ;
       end
             
     end
           
     //-----------------------------------------------------------*
     //* End of PART-2. (label)
     //*-----------------//
// end_of_part_2:
           
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //* PART-3: Overlap charge
     //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
     Aclm = UC_CLM1 ;
     if( flg_noqi != 0 ) begin
       //-------------------------------------------*
       //* Calculation of Psdl for cases of flg_noqi==1.
       //*-----------------//
       Psdl = Aclm * (Vds + Ps0) + (1.0e0 - Aclm) * Psl ;
       if( Psdl > Ps0 + Vds - `epsm10 ) begin
         Psdl = Ps0 + Vds - `epsm10 ;
       end
       if(XQY !=0) begin
         Ec = 0.0e0 ;
       end
     end else begin
       // Ec is removed from Lred calc. part //
       if(XQY !=0) begin
           if( Idd < `C_IDD_MIN ) begin
           Ec = 0.0e0 ;
         end else begin
           T1 =  beta_inv / Leff ;
           T2 = 1.0 / Qn0 ;
           T3 = T2 * T2 ;
           Ec = Idd * T1 * T2 ;
         end
       end
     end
        
     //-------------------------------------------*
     //* Overlap charges: Qgod, Qgos, and Qover
     //*-----------------//
     if( COOVLP >= 1 && UC_LOVER > 0.0 ) begin
       cov_slp = MKS_OVSLP ;
       cov_mag = OVMAG ;
       covvg = Vgs ;
       T1 = Cox0ov * weffcv_nf ;
       Lov = UC_LOVER ;
       if( UC_NOVER == 0.0 ) begin
         T4 = cov_slp * T1 * ( cov_mag + covvg ) ;
         T5 = Lov * T1 ;
         TX = Ps0 ;
         T9 = 1.2e0 - TX ;
         Qgos = Vgs * T5 - T9 * T4 ;
         T4 = cov_slp * T1 * ( cov_mag + covvg - Vds ) ;
         TX = Psl - Vds ;
         T9 = 1.2e0 - TX ;
         Qgod = (Vgs - Vds) * T5 - T4 * T9 ;
       end else begin
         for ( lcover = -1 ; lcover <= +1 ; lcover = lcover + 2 ) begin
           flg_ovloops = ( 1 - lcover ) / 2 ; // 1 in Source overlap calc. //
           flg_ovloopd = ( 1 + lcover ) / 2 ; // 1 in Drain overlap calc. //
           //-------------------------------------------*
           //* Qover(G/D overlap charge)  |  note: _dVxs means _dVxse
           //*------------------------//
           Vbsgmt = ModeNML * Vbse + ModeRVS * ( Vbse - Vdse ) ;
           Vdsgmt = ModeNML * Vdse + ModeRVS * ( - Vdse ) ;
           Vgsgmt = ModeNML * Vgse + ModeRVS * ( Vgse - Vdse ) ;
           Vdbgmt = Vdsgmt - Vbsgmt ;
           Vgbgmt = Vgsgmt - Vbsgmt ;
           Vsbgmt = - Vbsgmt ;
           flg_overs = flg_ovloops * ModeNML + flg_ovloopd * ModeRVS ; // geometrical source //
           flg_overd = flg_ovloops * ModeRVS + flg_ovloopd * ModeNML ; // geometrical drain //
           Vxbgmt = flg_overs * Vsbgmt + flg_overd * Vdbgmt + `epsm10 ;
                  
           //---------------------------------------------------*
           //* Clamp -Vxbgmt.
           //*-----------------//
           T0 = - Vxbgmt;
           if( T0 > Vbs_bnd ) begin
             T1 =    T0   - Vbs_bnd;
             T2 =    Vbs_max    - Vbs_bnd;
             `Fn_SUPoly4( TY, T1, T2, T11 )
             T10 = Vbs_bnd + TY ;
           end  else begin
             T10 = T0 ;
             T11 = 1.0 ;
           end
           Vxbgmtcl = - T10 - `Small2 ;
           fac1 = cnst0over * Cox0ov_inv ;
           fac1p2 = fac1 * fac1 ;
           VgpLD = - Vgbgmt + UC_VFBOVER;
           T0 = UC_NOVER / Nin ;
           Vgb_fb_LD =  - Vxbgmtcl ;
                     
           //-----------------------------------*
           //* QsuLD: total charge = Accumulation | Depletion+inversion
           //*-----------------//
           if(   VgpLD  < Vgb_fb_LD ) begin
             //---------------------------*
             //* Accumulation
             //*-----------------//
             flg_ovzone = -1 ;
             T1 = 1.0 / ( beta * cnst0over ) ;
             TY = T1 * Cox0ov ;
             Ac41 = 2.0 + 3.0 * `C_SQRT_2 * TY ;
             Ac4 = 8.0 * Ac41 * Ac41 * Ac41 ;
             Ps0_min = 2.0 * beta_inv * ln (-Vgs_min/fac1) ;
             TX = beta * ( VgpLD + Vxbgmtcl ) ;
             Ac31 = 7.0 * `C_SQRT_2 - 9.0 * TY * ( TX - 2.0 ) ;
             Ac3 = Ac31 * Ac31 ;
             if( Ac4 < Ac3*1.0e-8 ) begin
               Ac1 = 0.5 * Ac4 / Ac31 ;
             end else begin
               Ac2 = sqrt( Ac4 + Ac3 ) ;
               Ac1 = -Ac31 + Ac2 ;
             end
             Acd = pow( Ac1 , `C_1o3 ) ;
             Acn = -4.0 * `C_SQRT_2 - 12.0 * TY + 2.0 * Acd + `C_SQRT_2 * Acd * Acd ;
             Chi = Acn / Acd ;
             Psa = Chi * beta_inv - Vxbgmtcl ;
             T1 = Psa + Vxbgmtcl ;
             T2 = T1 / Ps0_min ;
             T3 = sqrt( 1.0 + ( T2 * T2 ) ) ;
             Ps0LD = T1 / T3 - Vxbgmtcl ;
             T2 = ( VgpLD - Ps0LD ) ;
             QsuLD = Cox0ov * T2 ;
             QbuLD = QsuLD ;
           end else begin
                   
             //---------------------------*
             //* Depletion and inversion
             //*-----------------//
                   
             // initial value for a few fixpoint iterations
             //to get Ps0_iniA from simplified Poisson equation: //
             flg_ovzone = 2 ;
             Chi = `znbd3 ;
             Ps0_iniA= Chi/beta - Vxbgmtcl ;
                 
             // 1 .. 2 relaxation steps should be sufficient //
             for ( lp_ld = 1; lp_ld <= 2; lp_ld = lp_ld + 1 ) begin
               TY = exp(-Chi);
               TX = 1.0e0 + 4.0e0 * ( beta * ( VgpLD + Vxbgmtcl ) - 1.0e0 + TY ) / ( fac1p2 * beta2 ) ;
               if( TX < `epsm10) begin
                 TX = `epsm10;  
               end
               Ps0_iniA = VgpLD + fac1p2 * beta / 2.0e0 * ( 1.0e0 - sqrt( TX ) ) ;
               Chi = beta * ( Ps0_iniA + Vxbgmtcl ) ;
             end // End of iteration //
             if( Chi < `znbd3 ) begin
               flg_ovzone = 1 ;
                          
               //-----------------------------------*
               //* zone-D1
               //* - Ps0_iniA is the analytical solution of QovLD=Qb0 with
               //*   Qb0 being approximated by 3-degree polynomial.
               //*
               //*   new: Inclusion of exp(-Chi) term at right border
               //*-----------------//
               Ta =  1.0/(9.0*sqrt(2.0)) - (5.0+7.0*exp(-3.0)) / (54.0*sqrt(2.0+exp(-3.0)));
               Tb = (1.0+exp(-3.0)) / (2.0*sqrt(2.0+exp(-3.0))) - sqrt(2.0) / 3.0;
               Tc =  1.0/sqrt(2.0) + 1.0/(beta*fac1);
               Td = - (VgpLD + Vxbgmtcl) / fac1;
               Tq = Tb*Tb*Tb / (27.0*Ta*Ta*Ta) - Tb*Tc/(6.0*Ta*Ta) + Td/(2.0*Ta);
               Tp = (3.0*Ta*Tc-Tb*Tb)/(9.0*Ta*Ta);
               T5 = sqrt(Tq*Tq + Tp*Tp*Tp);
               Tu = pow(-Tq + T5,`C_1o3);
               Tv = -pow(Tq + T5,`C_1o3);
               Chi = Tu + Tv - Tb/(3.0*Ta);
               Ps0_iniA = Chi * beta_inv - Vxbgmtcl ;
             end
             if( COQOVSM > 0 ) begin
               //-----------------------------------*
               //* - Ps0_iniB : upper bound.
               //*-----------------//
               flg_ovzone = flg_ovzone + 2;
               VgpLD_shift = VgpLD + Vxbgmtcl + 0.1;
               exp_bVbs = exp( beta * - Vxbgmtcl ) + `Small ;
               T0 = Nin / UC_NOVER;
               cnst1over = T0 * T0;
               gammaChi = cnst1over * exp_bVbs ;
               T0  = beta2 * fac1p2;
               psi = beta*VgpLD_shift;
               Chi_1 = ln (gammaChi*T0 + psi*psi) - ln (cnst1over*T0) + beta*Vxbgmtcl;
               `Fn_SU2( Chi_1, Chi_1, psi, 1.0, T1, T2 )
                          
               // 1 fixpoint step for getting more accurate Chi_B //
               psi = psi - Chi_1 ;
               psi = psi + beta*0.1 ;
               T1 = ln (gammaChi*T0 + psi*psi) - ln (cnst1over*T0) ;
               Chi_B = T1 + beta*Vxbgmtcl ;
               Ps0_iniB = T1 * beta_inv ;
                             
               // construction of Ps0LD by taking Ps0_iniB as an upper limit of Ps0_iniA
               //*
               //* Limiting is done for Chi rather than for Ps0LD, to avoid shifting
               //* for Fn_SU2 //
               Chi_A = Chi;
               if ( COQOVSM == 1 ) begin
               `Fn_SU2( Chi, Chi_A, Chi_B, `c_ps0ini_2*75.00, T1, T2 ) // org: 50 //
               end else begin //COQOVSM == 2:
                  `Fn_SU2( Chi, Chi_A, Chi_B, `c_ps0ini_2*OVINVDLT, T1, T2 )
               end
                     
             end
                   
             // updating Ps0LD //
             Ps0LD = Chi/beta - Vxbgmtcl ;
             T1    = Chi - 1.0 + exp(-Chi);
             if(T1 < `epsm10) begin
                T1 = `epsm10 ;
             end
             T2 = sqrt(T1);
             QbuLD = cnst0over * T2 ;
                
             //-----------------------------------------------------------*
             //* QsuLD : Qovs or Qovd in unit area.
             //* note: QsuLD = Qdep+Qinv.
             //*-----------------//
             QsuLD = Cox0ov * ( VgpLD - Ps0LD ) ;
                   
             if( COQOVSM == 1 ) begin // take initial values from analytical model //
                     
               //---------------------------------------------------*
               //* Calculation of Ps0LD. (beginning of Newton loop)
               //* - Fs0 : Fs0 = 0 is the equation to be solved.
               //* - dPs0 : correction value.
               //*-----------------//
                     
               // initial value too close to flat band should not be used //
               exp_bVbs = exp( beta * - Vxbgmtcl ) ;
               T0 = Nin / UC_NOVER;
               cnst1over = T0 * T0;
               cfs1 = cnst1over * exp_bVbs ;
               flg_conv = 0 ;
               for ( lp_s0 = 1 ; lp_s0 <= lp_s0_max + 1 ; lp_s0 = lp_s0 + 1 ) begin
                 Chi = beta * ( Ps0LD + Vxbgmtcl ) ;
                 if( Chi < `znbd5 ) begin
                   //-------------------------------------------*
                   //* zone-D1/D2. (Ps0LD)
                   //*-----------------//
                   fi = Chi * Chi * Chi
                      * ( `cn_im53 + Chi * ( `cn_im54 + Chi * `cn_im55 ) ) ;
                   fi_dChi = Chi * Chi
                           * ( 3 * `cn_im53 + Chi * ( 4 * `cn_im54 + Chi * 5 * `cn_im55 ) ) ;
                   fs01 = cfs1 * fi * fi ;
                   fs01_dPs0 = cfs1 * beta * 2 * fi * fi_dChi ;
                             
                   fb = Chi * ( `cn_nc51
                      + Chi * ( `cn_nc52
                      + Chi * ( `cn_nc53
                      + Chi * ( `cn_nc54 + Chi * `cn_nc55 ) ) ) ) ;
                   fb_dChi = `cn_nc51
                           + Chi * ( 2 * `cn_nc52
                           + Chi * ( 3 * `cn_nc53
                           + Chi * ( 4 * `cn_nc54 + Chi * 5 * `cn_nc55 ) ) ) ;
                   fs02 = sqrt( fb * fb + fs01 + `Small ) ;
                   fs02_dPs0 = ( beta * fb_dChi * 2 * fb + fs01_dPs0 ) / ( fs02 + fs02 ) ;
                 end else begin
                   //-------------------------------------------*
                   //* zone-D3. (Ps0LD)
                   //*-----------------//
                   if( Chi < `large_arg ) begin // avoid exp_Chi to become extremely large //
                     exp_Chi = exp( Chi ) ;
                     fs01 = cfs1 * ( exp_Chi - 1.0e0 ) ;
                     fs01_dPs0 = cfs1 * beta * ( exp_Chi ) ;
                   end else begin
                     exp_bPs0 = exp( beta*Ps0LD ) ;
                     fs01     = cnst1over * ( exp_bPs0 - exp_bVbs ) ;
                     fs01_dPs0 = cnst1over * beta * exp_bPs0 ;
                   end
                   fs02 = sqrt( Chi - 1.0 + fs01 ) ;
                   fs02_dPs0 = ( beta + fs01_dPs0 ) / fs02 * 0.5 ;
                             
                 end // end of if( Chi  ... ) block //
                 //-----------------------------------------------------------*
                 //* Fs0
                 //*-----------------//
                 Fs0 = VgpLD - Ps0LD - fac1 * fs02 ;
                 Fs0_dPs0 = - 1.0e0 - fac1 * fs02_dPs0 ;
                 if( flg_conv == 0 ) begin // break
                   dPs0 = - Fs0 / Fs0_dPs0 ;
                      
                   //-------------------------------------------*
                   //* Update Ps0LD .
                   //*-----------------//
                   dPlim = 0.5*`dP_max*(1.0 + `Fn_Max(1.0e0,abs(Ps0LD))) ;
                   if ( abs( dPs0 ) > dPlim ) dPs0 = dPlim * `Fn_Sgn( dPs0 ) ;
                   Ps0LD = Ps0LD + dPs0 ;
                    
                   //-------------------------------------------*
                   //* Check convergence.
                   //*-----------------//
                   if( abs( dPs0 ) <= `ps_conv && abs( Fs0 ) <= `gs_conv ) begin
                     flg_conv = 1 ;
                   end
                          
                 end // flg_conv==0
               end // end of Ps0LD Newton loop //
                        
               //-------------------------------------------*
               //* Procedure for diverged case.
               //*-----------------//
               if( flg_conv == 0 ) begin
                 $write( "*** warning(HiSIM2): %M Went Over Iteration Maximum(Ps0LD)\n" ) ;
                 $write(" -Vxbgmtcl = %e   Vgbgmt = %e\n" , -Vxbgmtcl , Vgbgmt ) ;
               end
                        
               if( Chi < `znbd5 ) begin
                 //-------------------------------------------*
                 //* zone-D1/D2. (Ps0LD)
                 //*-----------------//
                 if ( Chi < `znbd3 ) begin flg_ovzone = 1; end
                 else begin flg_ovzone = 2; end
                 Xi0 = fb * fb + `epsm10 ;
                 Xi0p12 = fb + `epsm10 ;
               end else begin
                 //-------------------------------------------*
                 //* zone-D3. (Ps0LD)
                 //*-----------------//
                 flg_ovzone = 3 ;
                 Xi0 = Chi - 1.0e0 ;
                 Xi0p12 = sqrt( Xi0 ) ;
               end // end of if( Chi  ... ) block //
                  
               //-----------------------------------------------------------*
               //* QbuLD and QiuLD
               //*-----------------//
               QbuLD = cnst0over * Xi0p12 ;
               T1 = 1.0 / ( fs02 + Xi0p12 ) ;
               QiuLD = cnst0over * fs01 * T1 ;
                  
               //-----------------------------------------------------------*
               //* Total overlap charge
               //*-----------------//
               QsuLD = QbuLD + QiuLD;
                     
             end // end of COQOVSM branches //
                   
           end // end of Vgbgmt region blocks //
                 
           // inversion charge = total - depletion //
           QiuLD = QsuLD - QbuLD  ;
                 
           // assign final outputs of Qover model //
           // note: Qovs and Qovd are exchanged in reverse mode //
           T4 = weffcv_nf * Lov ;
           if(flg_ovloops) begin
             Qovs =  T4 * QsuLD ;
             QbsLD = T4 * QbuLD ;
           end
           if(flg_ovloopd) begin
             Qovd =  T4 * QsuLD ;
             QbdLD = T4 * QbuLD ;
           end
                 
         end // end of lcover loop //
               
       end // end of if( UC_NOVER == 0.0 ) //
             
       //-----------------------------------*
       //* Additional constant capacitance model
       //*-----------------//
       flg_overgiven = ( ModeRVS * CGSO_GIVEN
                       + ModeNML * CGDO_GIVEN  ) ;
       if( flg_overgiven ) begin
         Cgdoe = ModeRVS * UC_CGSO + ModeNML * UC_CGDO ;
         Cgdoe = Cgdoe * ( - weffcv_nf ) ;
         Qgod = Qgod + - Cgdoe * (Vgs - Vds) ;
       end
            
       flg_overgiven = ( ModeNML * CGSO_GIVEN
                       + ModeRVS * CGDO_GIVEN ) ;
       if(flg_overgiven) begin
         Cgsoe = ModeNML * UC_CGSO + ModeRVS * UC_CGDO ;
         Cgsoe = Cgsoe * ( - weffcv_nf ) ;
         Qgos = Qgos + - Cgsoe * Vgs ;
       end
            
     end else begin // else case of if( coovlp >= 1 ) //
       if((mode == `HiSIM_NORMAL_MODE && !CGDO_GIVEN) ||
          (mode != `HiSIM_NORMAL_MODE && !CGSO_GIVEN) ) begin
         Cgdoe = - Cox0ov * UC_LOVER * weffcv_nf ;
       end else begin
         Cgdoe = ModeRVS * UC_CGSO + ModeNML * UC_CGDO ;
         Cgdoe = Cgdoe * ( - weffcv_nf ) ;
       end
       Qgod = - Cgdoe * (Vgs - Vds) ;
            
       if((mode == `HiSIM_NORMAL_MODE && !CGSO_GIVEN) ||
          (mode != `HiSIM_NORMAL_MODE && !CGDO_GIVEN) ) begin
         Cgsoe = - Cox0ov * UC_LOVER * weffcv_nf ;
       end else begin
         Cgsoe = ModeNML * UC_CGSO + ModeRVS * UC_CGDO ;
         Cgsoe = Cgsoe * ( - weffcv_nf ) ;
       end
       Qgos = - Cgsoe * Vgs ;
     end // end of if( coovlp >= 1 ) //
          
     //-------------------------------------------*
     //* Gate/Bulk overlap charge: Qgbo
     //*-----------------//
     Cgbo_loc = - CGBO * Lgate ;
     Qgbo = - Cgbo_loc * (Vgs -Vbs) ;
          
     //---------------------------------------------------*
     //* Lateral-field-induced capacitance.
     //*-----------------//
     if( flg_qy == 0 || XQY == 0 ) begin
       Qy = 0.0e0 ;
     end else begin
       Pslk = Ec * Leff + Ps0 ;
       `Fn_SU2( T10, (Pslk + `C_PSLK_SHIFT), (Psdl + `C_PSLK_SHIFT), `C_PSLK_DELTA, T1, T2 )
       Pslk = T10 - `C_PSLK_SHIFT;
            
       // suppress Qy in accumulation region //
       //
       Aclm_eff = Aclm ;   
       T1 = Aclm_eff * ( Vds + Ps0 ) + ( 1.0e0 - Aclm_eff ) * Pslk ;
       T10 = wdpl ;
       T3 = T10 * 1.3 ;
       T2 = `C_ESI * weffcv_nf * T3 ;
       T7 = 1.0e-9 ; // 1nm //
       T0 = `Fn_Max( XQY , T7 ) ;
       T4 = T2 / T0 ;
       Qy = - ( Ps0 + Vds - T1 ) * T4 ;
          
     end
     if( XQY1 != 0.0 ) begin
       Qy = Qy + cqyb0 * Vbs ;
     end
     Qy = Qy * FMDVDS ;
             
     //---------------------------------------------------*
     //* Fringing capacitance.
     //*-----------------//
     Cf = cfrng ;
     Qfd = Cf * ( Vgs - Vds ) ;
     Qfs = Cf * Vgs ;
         
     //-----------------------------------------------------------*
     //* End of PART-3. (label)
     //*-----------------//
         
// end_of_part_3:
         
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //* PART-4: Substrate-source/drain junction diode.
     //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
         
           
`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
//=============================== `include "HSM2_eval_dio.inc" =============================== BEGIN
      
  //-----------------------------------------------------------*
  //* Cbsj, Cbdj: node-base S/D biases.
  //*-----------------//
        
  // ibd //
  T10 = CVBD * jd_nvtm_invd ;
  T11 = CVBK * jd_nvtm_invd ; //only in HiSIM2
  T9 = CISBD * exptempd ;
  `HSM2_Idio(Ibd_btm, vbd_jct,  isbd_btm, isbd2_btm,  vbdt, jd_expcd,  T10, T11, T9, jd_nvtm_invd, UC_CISBKD, DIVXD)
  `HSM2_Idio(Ibd_sws, vbd_jct,  isbd_sws, isbd2_sws,  vbdt, jd_expcd,  T10, T11, T9, jd_nvtm_invd, UC_CISBKD, DIVXD)
  if ( CODIO > 0 ) begin //new model:
     `HSM2_Idio(Ibd_swg, vbdi_jct, isbd_swg, isbd2_swg,  vbdt, jd_expcd,  T10, T11, T9, jd_nvtm_invd, UC_CISBKD, DIVXD)
  end else begin //backward compatible:
     Ibd_swg = 0.0 ;
  end

  // ibs //
  T10 = CVBS * jd_nvtm_invs ;
  T11 = CVBK * jd_nvtm_invs ; //only in HiSIM2
  T9 = CISBS * exptemps ;
  `HSM2_Idio(Ibs_btm, vbs_jct,  isbs_btm, isbs2_btm,  vbst, jd_expcs,  T10, T11, T9, jd_nvtm_invs, UC_CISBKS, DIVXS)
  `HSM2_Idio(Ibs_sws, vbs_jct,  isbs_sws, isbs2_sws,  vbst, jd_expcs,  T10, T11, T9, jd_nvtm_invs, UC_CISBKS, DIVXS)
  if ( CODIO > 0 ) begin //new model:
     `HSM2_Idio(Ibs_swg, vbsi_jct, isbs_swg, isbs2_swg,  vbst, jd_expcs,  T10, T11, T9, jd_nvtm_invs, UC_CISBKS, DIVXS)
  end else begin //backward compatible:
     Ibs_swg = 0.0 ;
  end

  //-----------------------------------------------------------*
  //* Charges and Capacitances.
  //*-----------------//
  //  charge storage elements
  //*  bulk-drain and bulk-source depletion capacitances
  //*  czbd : zero bias drain junction capacitance
  //*  czbs : zero bias source junction capacitance
  //*  czbdsw:zero bias drain junction sidewall capacitance
  //*  czbssw:zero bias source junction sidewall capacitance
  ////
      
  // Drain Bulk Junction //
  `HSM2_Qdio(Qbd_btm, Capbd_btm, vbd_jct,  czbd,    PBD,    MJD)
  `HSM2_Qdio(Qbd_sws, Capbd_sws, vbd_jct,  czbdsw,  PBSWD,  MJSWD)
  if ( CODIO > 0 ) begin //new model:
  `HSM2_Qdio(Qbd_swg, Capbd_swg, vbdi_jct, czbdswg, PBSWGD, MJSWGD)
  end else begin //backward compatible:
  `HSM2_Qdio(Qbd_swg, Capbd_swg, vbd_jct, czbdswg, PBSWGD, MJSWGD)
  end

  // Source Bulk Junction //
  `HSM2_Qdio(Qbs_btm, Capbs_btm, vbs_jct,  czbs,    PBS,    MJS)
  `HSM2_Qdio(Qbs_sws, Capbs_sws, vbs_jct,  czbssw,  PBSWS,  MJSWS)
  if ( CODIO > 0 ) begin //new model:
  `HSM2_Qdio(Qbs_swg, Capbs_swg, vbsi_jct, czbsswg, PBSWGS, MJSWGS)
  end else begin //backward compatible:
  `HSM2_Qdio(Qbs_swg, Capbs_swg, vbs_jct, czbsswg, PBSWGS, MJSWGS)
  end


  //---------------------------------------------------*
  //* Junction diode.
  //*-----------------//
  Ibs = Mfactor * (Ibs_btm + Ibs_sws) ;
  Ibd = Mfactor * (Ibd_btm + Ibd_sws) ;
  if ( CODIO > 0 ) begin //new model:
     Ibsi = Mfactor * Ibs_swg ;
     Ibdi = Mfactor * Ibd_swg ;
     Qbs = Mfactor * (Qbs_btm + Qbs_sws) ;
     Qbd = Mfactor * (Qbd_btm + Qbd_sws) ;
     Qbsi = Mfactor * Qbs_swg ;
     Qbdi = Mfactor * Qbd_swg ;
     Capbs = Mfactor * (Capbs_btm + Capbs_sws) ;
     Capbd = Mfactor * (Capbd_btm + Capbd_sws) ;
     Capbsi = Mfactor * Capbs_swg ;
     Capbdi = Mfactor * Capbd_swg ;
  end else begin //backward compatible:
     Ibsi = 0.0 ;
     Ibdi = 0.0 ;
     Qbs = Mfactor * (Qbs_btm + Qbs_sws + Qbs_swg) ;
     Qbd = Mfactor * (Qbd_btm + Qbd_sws + Qbd_swg) ;
     Capbs = Mfactor * (Capbs_btm + Capbs_sws + Capbs_swg) ;
     Capbd = Mfactor * (Capbd_btm + Capbd_sws + Capbd_swg) ;
     Qbsi = 0.0 ;
     Qbdi = 0.0 ;
     Capbsi = 0.0 ;
     Capbdi = 0.0 ;
  end

//  End of HSM2evalDio //
//=============================== `include "HSM2_eval_dio.inc" =============================== END
`endif /* End of COEXTDIO */
     //-----------------------------------------------------------*
     //* End of PART-4. (label)
     //*-----------------//
           
// end_of_part_4:
           
     //-----------------------------------------------------------*
     //* PART-5: NQS. (label)
     //*-----------------//

     if(flg_nqs == 1)  begin // NQS flag = 1      Tiburon-DA implementation:
         NQS_CAPACITOR = 1e-9 ;
         // tau for inversion charge //
         if(flg_noqi == 0) begin
           T3 = Lch * Lch;
           T1 = DLY2 * DLY1 * T3;
           T2 = Mu * VgVt * DLY1 + DLY2 * T3 + `Small ;
           tau = T1 / T2 ;
         end else 
           tau = DLY1 + `Small ;
            
         // tau for bulk charge //
         taub = MKS_DLY3 * Cox ;
         Qb_nqs = NQS_CAPACITOR * V(int_nqs_b);  //NQS charge is C*V
         Qi_nqs = NQS_CAPACITOR * V(int_nqs_i);  //NQS charge is C*V
         T1 = (Qb_nqs - Qb ) / taub;
         T3 = (Qi_nqs - Qi ) / tau;
     end else begin
         T1 = 0;
         T3 = 0;
         NQS_CAPACITOR = 0.0 ;
     end

     I_nqs_b = ddt(NQS_CAPACITOR * V(int_nqs_b));
     I_nqs_i = ddt(NQS_CAPACITOR * V(int_nqs_i));

     I(int_nqs_b) <+ T1;
     I(int_nqs_b) <+ I_nqs_b ;
     I(int_nqs_i) <+ T3;
     I(int_nqs_i) <+ I_nqs_i ;
     I(int_nqs_b) <+ V(int_nqs_b)*1e-12; // Gmin
     I(int_nqs_i) <+ V(int_nqs_i)*1e-12; // Gmin
          
     //-----------------------------------------------------------*
     //* End of PART-5. (label)
     //*-----------------//
// end_of_part_5:
          
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //* PART-6: Noise Calculation.
     //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
          
     //-----------------------------------------------------------*
     //* 1/f noise.
     //*-----------------//
     if( COFLICK != 0 && !flg_noqi ) begin
//     NFalpe = UC_NFALP ;
       NFalp1 = UC_NFALP1 ;
       NFalp2 = UC_NFALP2 ;
       NFtrpe = UC_NFTRP ;
       Cite = MKS_CIT ;
       T1 = Qn0 / `C_QE ;
       if( CODEP == 0 ) begin //normal MOSFETs:
          T2 = ( Cox + Qn0 / ( Ps0 - Vbs ) + Cite ) * beta_inv / `C_QE ;
       end else begin //depletion-mode MOSFETs:
          T2 = ( Cox + Qn0 /   Ps0         + Cite ) * beta_inv / `C_QE ;
       end
       T5 = Lch - DLNOISE ;
       T3 = -2.0E0 * Qi_noi / `C_QE / Lch / weffcv_nf - T1 ;
       if( T3 != T1 ) begin
         T4 = 1.0E0 / ( T1 + T2 ) / ( T3 + T2 ) + 2.0E0 * NFalp1 * Ey * Mu / ( T3 - T1 )
            * ln(( T3 + T2 ) /( T1 + T2 ) ) + NFalp2 * Ey * Mu * NFalp2 * Ey * Mu ;
       end  else begin
         T4 = 1.0 / ( T1 + T2 ) / ( T3 + T2 ) + 2.0 * NFalp1 * Ey * Mu / ( T1 + T2 )
            + NFalp2 * Ey * Mu * NFalp2 * Ey * Mu;
       end
       Nflic = `Fn_Pow( Ids , SIDP) * NFtrpe / ( T5 * beta * weffcv_nf ) * T4 ;
     end else begin
       Nflic = 0.0 ;
     end
           
     //-----------------------------------------------------------*
     //* thermal noise.
     //*-----------------//
     if( COTHRML != 0 && !flg_noqi && UC_CODEP == 0 ) begin
       Eyd = ( Psdl - Ps0 + `epsm10 ) / Lch ;
       T12 = Muun * Eyd / `C_vmax ;
       // note: bb = 2 (electron) ;1 (hole) //
       if( 1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10 ) begin
         T7  = 1.0e0 ;
       end else if( 2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10 ) begin
         T7  = T12 ;
       end else begin
         T7  = `Fn_Pow( Eyd, BB - 1.0e0 ) ;
       end
       T8 = T12 * T7 ;
       T9 = 1.0e0 + T8 ;
       T10 = `Fn_Pow( T9, ( - 1.0e0 / BB - 1.0e0 ) ) ;
       T11 = T9 * T10 ;
       Mud_hoso = Muun * T11 ;
       Mu_Ave = ( Mu + Mud_hoso ) / 2.0 ;
       // Sid_h = GAMMA * 4.0 * C_KB * KTEMP * gds0_h2; //
       T0 = Alpha * Alpha ;
       Nthrml  = weffcv_nf * Cox * VgVt * Mu
               * ( ( 1e0 + 3e0 * Alpha + 6e0 * T0 ) * Mud_hoso * Mud_hoso
               + ( 3e0 + 4e0 * Alpha + 3e0 * T0 ) * Mud_hoso * Mu
               + ( 6e0 + 3e0 * Alpha + T0 ) * Mu * Mu )
               / ( 15e0 * Lch * ( 1e0 + Alpha ) * Mu_Ave * Mu_Ave ) ;
     end else begin
       Nthrml = 0e0 ;
     end
            
     //----------------------------------------------------------*
     //* induced gate noise. ( Part 2/3 )
     //*----------------------//
     if( COIGN != 0 && COTHRML != 0 && flg_ign == 1 && !flg_noqi && UC_CODEP == 0 ) begin
       sqrtkusaiL = sqrt( kusaiL ) ;
       T2 = VgVt + sqrtkusaiL ;
       T3 = kusai00 * kusai00 ;
       T4 = kusaiL * kusaiL ;
       T5 = 42.0e0 * kusai00 * kusaiL ;
       T5 = T5 + 4.0e0 * ( T3 + T4 ) ;
       T5 = T5 + 20.0e0 * sqrtkusaiL * VgVt * ( kusai00 + kusaiL ) ;
       T10 = T2 * T2 ;
       T10 = T10 * T10 ;
       kusai_ig = T5 / ( T10 * T2 ) ; // Induced Gate Noise parameter //
       gds0_ign = weff_nf / Lch * Mu * Cox ;
       gds0_h2 = gds0_ign * VgVt ;
       GAMMA = Nthrml / gds0_h2 ;
       T7 = kusai00 + 4.0e0 * VgVt * sqrtkusaiL + kusaiL ;
       // cross-correlation coefficient(= Sigid/sqrt(Sig*Sid) ) //
       crl_f = `c_sqrt_15 * kusai00L * T7
             / ( 6.0e0 * T2 * sqrt( GAMMA * T2 * VgVt * T5 ) ) ;
     end
           
     //-----------------------------------------------------------*
     //* End of PART-6. (label)
     //*-----------------//
// end_of_part_6:
           
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //* PART-7: Evaluation of outputs.
     //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
           
     //-----------------------------------------------------------*
     //* Implicit quantities related to Alpha.
     //*-----------------//
     // note: T1 = 1 + Delta //
     if( flg_noqi == 0 && VgVt > `VgVt_Small ) begin
       Delta = fac1 * beta / ( 2 * wk_Xi0p12 ) ; // Xi0p12 was soiled by overlap charge block. Recall Xi0p12 assigned in the MOS intrinsic block.
       Pslsat = VgVt / ( 1.0 + Delta ) + Ps0 ;
     end else begin
       Pslsat = 0.0 ;
     end

     Vdsat = Pslsat - Pb2 ;
     if( Vdsat < 0.0 ) begin
       Vdsat = 0.0 ;
     end
           
                   
     //-------------------------------------------*
     //* Add IdsIBPC to Ids.
     //*-----------------//
     Ids = Ids + IdsIBPC ;
         
     //---------------------------------------------------*
     //* Add fringing charge/capacitance to overlap.
     //*-----------------//
     Qgod = Qgod + Qfd ;
     Qgos = Qgos + Qfs ;

     //-----------------------------------------------------------*
     //* Assign outputs.
     //*-----------------//
          
     //---------------------------------------------------*
     //* Channel current and conductances.
     //*-----------------//
     idse  = Mfactor * Ids ;
     IdsAcc = Mfactor * Ids_acc ;
     IdsRes = Mfactor * Ids_res ;
          
     //---------------------------------------------------*
     //* Lateral-field-induced capacitance.
     //*-----------------//
     T0 = QYRAT ;
     T1 = 1.0 - T0 ;
     Qys = Qy * T1 ;
     Qy = Qy * T0 ;
          
     // -------------------------------------*
     //* Intrinsic charges / capacitances.
     //*-----------------//
    if( flg_nqs ) begin
       qge = Mfactor * - (Qb_nqs + Qi_nqs) ;
       qde = Mfactor * Qi_nqs * Qdrat ;
       qse = Mfactor * Qi_nqs * (1.0 - Qdrat) ;
     end else  begin // QS or NQS(ac dc analysis) //
       qge = Mfactor * - (Qb + Qi) ;
       qde = Mfactor * Qd ;
       qse = Mfactor * ( Qi - Qd ) ;
     end
          
     //---------------------------------------------------*
     //* Add lateral-field-induced charges/capacitances to intrinsic ones.
     //* - NOTE: This function depends on coqy, a control option.
     //*-----------------//
     if( flg_qy == 1 ) begin
       qge = qge + Mfactor * ( Qy + Qys ) ;
       qde = qde + Mfactor * ( - Qy ) ;
       qse = qse + Mfactor * ( - Qys ) ;
     end
          
     //---------------------------------------------------*
     //* Add S/D overlap charges/capacitances to intrinsic ones.
     //* - NOTE: This function depends on coadov, a control option.
     //*-----------------//
     if( COADOV == 1 ) begin
       qge = qge + Mfactor * ( Qgod + Qgos + Qgbo - Qovd - Qovs ) ;
       qde = qde + Mfactor * ( - Qgod + QbdLD ) ;
       qse = qse + Mfactor * ( - Qgos + QbsLD ) ;
     end

             
     //---------------------------------------------------*
     //* Substrate/gate/leak currents.
     //*-----------------//
     isube = Mfactor * Isub ;
     igbe   = Mfactor * -Igb ;
     if(mode == `HiSIM_NORMAL_MODE) begin
       igde   = Mfactor * ( GLPART1 * Igate - Igd ) ;
     end else begin
       T1 = 1.0 - GLPART1 ;
       igde = Mfactor * ( T1 * Igate - Igs ) ;
     end

     if(mode == `HiSIM_NORMAL_MODE) begin
       T1 = 1.0 - GLPART1 ;
       igse   = Mfactor * ( T1 * Igate - Igs ) ;

     end else begin
       igse   = Mfactor * ( GLPART1 * Igate - Igd ) ;
     end

     igidle    = (mode == `HiSIM_NORMAL_MODE) ? Mfactor * Igidl       : Mfactor * Igisl ;
     igisle    = (mode == `HiSIM_NORMAL_MODE) ? Mfactor * Igisl       : Mfactor * Igidl ;
              
     //---------------------------------------------------*
     //* Von, Vdsat.
     //*-----------------//
     vone = Vth ;
     vdsate = Vdsat ;
           
     //---------------------------------------------------*
     //* Junction diode.
     //*-----------------//
`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
     ibdb    =  TYPE * Ibd  ;
     ibsb    =  TYPE * Ibs  ;
     ibdbi   =  TYPE * Ibdi ;
     ibsbi   =  TYPE * Ibsi ;
     Gbd     =  ddx(ibdb,V(db));  
     Gbs     =  ddx(ibsb,V(sb));  
     capbdb  =  Capbd  ; 
     capbsb  =  Capbs  ; 
     capbdbi =  Capbdi ; 
     capbsbi =  Capbsi ; 
`endif /* End of COEXTDIO */
             
     //-----------------------------------------------------------*
     //* Noise.
     //*-----------------//
// Noise coeff. calculation
`define C_QE2    2.0 * `C_QE
     whi_noise = 4.0 * `C_KB* TTEMP * `Kwhite ; 
     noiflick = Mfactor * Nflic ;
     noithrml = Mfactor * Nthrml ;
              
     cgdbd = ddx(qge,V(dp)) ; cgdbd = TYPE * cgdbd ;
     cgsbd = ddx(qge,V(sp)) ; cgsbd = TYPE * cgsbd ;
     cgsb  = (mode > 0) ? cgsbd : cgdbd ;
     noiigate = 0.0e0 ;
     noicross = 0.0e0 ;
     //----------------------------------------------------------*
     //* induced gate noise. ( Part 3/3 )
     //*----------------------//
     if( COIGN != 0 && COTHRML != 0 && flg_ign == 1 && !flg_noqi && UC_CODEP == 0 ) begin
       T0 = `Cox_Small * Cox * weffcv_nf * Leff_cv ;
       T1 = cgsb / Mfactor ;

         Nign0 = `c_16o135 * `C_QE * beta_inv * T1 * T1 / gds0_ign ;
         if( kusai00L > `epsm10 && Vds > `epsm10 ) begin
           MuModA = Muun / Mu ;
           MuModB = ( Muun / Mud_hoso - MuModA ) / Vds ;
           correct_w1 = MuModA + `C_2o3 * MuModB
                      * ( kusai00 + VgVt * sqrtkusaiL + kusaiL )
                      / ( VgVt + sqrtkusaiL ) ;
         end else begin
           correct_w1 = Muun / Mud_hoso ;
         end
         noiigate = Mfactor * Nign0 * kusai_ig * correct_w1 ;
         noicross = crl_f ;
         noiigate = (noiigate < 0.0) ? 0.0 : noiigate ;

       noiigate = ( - T1 > T0 ) ? noiigate : 0.0 ;
       noicross = ( - T1 > T0 ) ? noicross : 0.0 ;
     end
     // Thermal noise and induced gate noise:
     sid    = whi_noise * noithrml;
     ci     = noicross;    
     sigrat = (sid > 0.0 && noiigate > 0.0) ? sqrt(noiigate/sid) : 0.0 ;
     sigrat_s  = (mode > 0) ? sigrat*(1-Qdrat) : sigrat*   Qdrat ;
     sigrat_d  = (mode > 0) ? sigrat*   Qdrat  : sigrat*(1-Qdrat) ;
                       
     //-----------------------------------------------------------*
     //* End of PART-7. (label)
     //*-----------------//
// end_of_part_7:
                       
     //-----------------------------------------------------------*
                       
// *-------------------------------------------------------------
// * Actually load the device currents                  hsm2ld.c
// * 
// * 
// Clamping Rd & Rs
                       
     Rdde = Rdd / Mfactor ;
     Rsde = Rsd / Mfactor ;
          
     if( mode > 0 ) begin // forward mode //
       Ids   = idse ;
       Qd    = qde ;
       Qg    = qge ;
       Qs    = qse ;
       Qb    = - (qge + qde + qse) ;
       Isub  = isube ;
       Isubs = 0.0 ;
     end else begin // reverse mode //
       Ids   = - idse ;
       Qd    = qse ;
       Qg    = qge ;
       Qs    = qde ;
       Qb    = - (qge + qde + qse) ;
       Isub  = 0.0 ;
       Isubs = isube ;
     end // end of reverse mode //
     Igidl = igidle ;
     Igisl = igisle ;
     Igd   = igde ;
     Igs   = igse ;
     Igb   = igbe ;
           
//--print Op points--------*/
     idse    =  mode * Ids  ;
     ibdb    =  TYPE * Ibd  ;
     ibsb    =  TYPE * Ibs  ;
     Isuba   =  TYPE * (Isub + Isubs) ;
             
     ggds    =  ddx(idse,V(dp)) ;  ggds  = TYPE * ggds  ;
     ggdss   =  ddx(idse,V(sp)) ;  ggdss = TYPE * ggdss ;
             
     if(mode != `HiSIM_NORMAL_MODE) begin
       ggds    = ggdss ;
     end
             
     ggm     =  ddx(idse,V(gp)) ;  ggm   = TYPE * ggm   ;
     ggmbs   =  ddx(idse,V(bp)) ;  ggmbs = TYPE * ggmbs ;
             
     ggbgs   =  ddx(Isuba,V(gp));
     ggbds   =  ddx(Isuba,V(dp));
     ggbbs   =  ddx(Isuba,V(bp));
             
     qge     =  Qg ;
     qde     =  Qd ;
     qse     =  Qs ;
     qbe     =  Qb ;
             
     cggbd   =  ddx(qge,V(gp)) ;  cggbd = TYPE * cggbd ;
     cgdbd   =  ddx(qge,V(dp)) ;  cgdbd = TYPE * cgdbd ;
     cgsbd   =  ddx(qge,V(sp)) ;  cgsbd = TYPE * cgsbd ;
     cgbbd   =  ddx(qge,V(bp)) ;  cgbbd = TYPE * cgbbd ;
             
     cdgbd   =  ddx(qde,V(gp)) ;  cdgbd = TYPE * cdgbd ;
     cddbd   =  ddx(qde,V(dp)) ;  cddbd = TYPE * cddbd ;
     cdsbd   =  ddx(qde,V(sp)) ;  cdsbd = TYPE * cdsbd ;
     cdbbd   =  ddx(qde,V(bp)) ;  cdbbd = TYPE * cdbbd ;
             
     cbgbd   =  ddx(qbe,V(gp)) ;  cbgbd = TYPE * cbgbd ;
     cbdbd   =  ddx(qbe,V(dp)) ;  cbdbd = TYPE * cbdbd ;
     cbsbd   =  ddx(qbe,V(sp)) ;  cbsbd = TYPE * cbsbd ;
     cbbbd   =  ddx(qbe,V(bp)) ;  cbbbd = TYPE * cbbbd ;
             
     csgbd   =  ddx(qse,V(gp)) ;  csgbd = TYPE * csgbd ;
     csdbd   =  ddx(qse,V(dp)) ;  csdbd = TYPE * csdbd ;
     cssbd   =  ddx(qse,V(sp)) ;  cssbd = TYPE * cssbd ;
     csbbd   =  ddx(qse,V(bp)) ;  csbbd = TYPE * csbbd ;
             
     Rdd     =  Rdde ;
     Rsd     =  Rsde ;
             
     capbdb  =  Capbd ;
     capbsb  =  Capbs ;
             

     /* Temperatures */
     TK = TTEMP ;

     //---------------------------------------------------*
     //* Add Gjmin.
     //*-----------------//
     Gbd     =  ddx(Ibd,V(db)) + Gjmin * Mfactor ; 
     Gbs     =  ddx(Ibs,V(sb)) + Gjmin * Mfactor ;
     Ibd     =  Ibd  + vbd_jct * Gjmin * Mfactor ;
     Ibs     =  Ibs  + vbs_jct * Gjmin * Mfactor ;
         
// print all outputs ------------VV //
`ifdef _AGING_
     DVTBTI = dVth_bti ;
     NTRAP0 = nt0s ;
     NTRAPL = ntls ;
`endif
     if( INFO >= 8 ) begin
       $write( "vone,vdsate = %18.10e %18.10e \n" , vone, vdsate ) ;
       $write( "Ids       = %18.10e \n" , idse ) ;
       $write( "Rdd,Rsd     = %18.10e %18.10e \n" , Rdd , Rsd ) ;
       $write( "gds       = %18.10e \n" , ggds ) ;
       $write( "gm        = %18.10e \n" , ggm  ) ;
       $write( "gmbs      = %18.10e \n" , ggmbs) ;
       $write( "Qg        = %18.10e \n" , qge ) ;
       $write( "Qd        = %18.10e \n" , qde ) ;
       $write( "Qs        = %18.10e \n" , qse  ) ;
       $write( "cggb      = %18.10e \n" , cggbd ) ;
       $write( "cgsb      = %18.10e \n" , cgsbd ) ;
       $write( "cgdb      = %18.10e \n" , cgdbd ) ;
       $write( "cbgb      = %18.10e \n" , cbgbd ) ;
       $write( "cbsb      = %18.10e \n" , cbsbd ) ;
       $write( "cbdb      = %18.10e \n" , cbdbd ) ;
       $write( "cdgb      = %18.10e \n" , cdgbd ) ;
       $write( "cdsb      = %18.10e \n" , cdsbd ) ;
       $write( "cddb      = %18.10e \n" , cddbd ) ;
       $write( "Isub      = %18.10e \n" , Isuba ) ;
       $write( "gbgs      = %18.10e \n" , ggbgs ) ;
       $write( "gbds      = %18.10e \n" , ggbds ) ;
       $write( "gbbs      = %18.10e \n" , ggbbs ) ;
       $write( "Igidl,isl = %18.10e %18.10e \n" , Igidl , Igisl ) ;
       $write( "Igd,s,b   = %18.10e %18.10e %18.10e \n" , Igd , Igs , Igb) ;
       $write( "tau,taub  = %18.10e %18.10e\n" , tau, taub ) ;
`ifdef _AGING_
       $write( "DVTBTI    = %18.10e \n" , DVTBTI) ;
       $write( "NTRAP0    = %18.10e \n" , NTRAP0) ;
       $write( "NTRAPL    = %18.10e \n" , NTRAPL) ;
`endif

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
       $write( "Ibd,Ibs     = %18.10e %18.10e\n" , ibdb , ibsb ) ;
       $write( "Ibdi,Ibsi   = %18.10e %18.10e\n" , ibdbi, ibsbi ) ;
       $write( "Gbd,Gbs     = %18.10e %18.10e\n" , Gbd  , Gbs ) ;
       $write( "Capbd,Capbs = %18.10e %18.10e\n" , capbdb , capbsb ) ;
       $write( "Capbdi,Capbsi = %18.10e %18.10e\n" , capbdbi, capbsbi ) ;
       $write( "Qbd,Qbs     = %18.10e %18.10e\n" , Qbd , Qbs ) ;
       $write( "Qbdi,Qbsi   = %18.10e %18.10e\n" , Qbdi , Qbsi ) ;
`endif /* End of COEXTDIO */

     end
// print all outputs ------------AA //

// Drain , Substrate ,  GIDL and GISL Currents
     I(BRdpsp) <+  TYPE * Ids ;
     I(BRdpbp) <+  TYPE * (Igidl + Isub );
     I(BRspbp) <+  TYPE * (Igisl + Isubs);

`ifdef COEXTDIO 
       /* for Junction Diode Model */
`else 
// Junction Diode Currents 
     I(BRsbs ) <+  TYPE * Ibs ;
     I(BRdbd ) <+  TYPE * Ibd ;
     I(BRsbs ) <+  TYPE * ddt(Qbs) ;
     I(BRdbd ) <+  TYPE * ddt(Qbd) ;
     if ( CODIO > 0 ) begin //new model:
        I(BRbpsp) <+  TYPE * Ibsi ;
        I(BRbpdp) <+  TYPE * Ibdi ;
        I(BRbpsp) <+  TYPE * ddt(Qbsi) ;
        I(BRbpdp) <+  TYPE * ddt(Qbdi) ;
     end
`endif /* End of COEXTDIO */

// Gate Leakage Currents
     if(COIIGS == 1) begin
       I(BRgpsp) <+  TYPE * Igs;
       I(BRgpdp) <+  TYPE * Igd;
       I(BRgpbp) <+  TYPE * Igb;
     end
//
// Source & Drain Resistance Currents
     flg_rd = (CORSRD!=0 && ((RSH > 0 && NRD > 0) || RD > 0)) ? 1 : 0 ;
     flg_rs = (CORSRD!=0 && ((RSH > 0 && NRS > 0) || RS > 0)) ? 1 : 0 ;
     if(flg_rd) I(BRddp ) <+ V(BRddp ) / Rdd; else V(BRddp ) <+ 0.0 ;
     if(flg_rs) I(BRsps ) <+ V(BRsps ) / Rsd; else V(BRsps ) <+ 0.0 ;
//
// Inner Capacitance Currents
     I(BRgpsp) <+  TYPE * ddt(Qg);
     I(BRdpsp) <+  TYPE * ddt(Qd);
     I(BRbpsp) <+  TYPE * ddt(Qb);
//
// Noise Currents
// 1/F Noise
     I(BRdpsp) <+ flicker_noise(noiflick * `Kflic , FALPH  , "iflick");
// IG Noise
     I(n)      <+ 1*V(n) ;
     I(n)      <+ white_noise(sid) ;
     I(BRdpsp) <+ white_noise((1.0-ci*ci)*sid) ;
     I(BRdpsp) <+ ci*V(n) ;
     I(BRgpsp) <+ ddt(V(n)*sigrat_s) ;
     I(BRgpdp) <+ ddt(V(n)*sigrat_d) ;
//  
     if(flg_rs) I(BRsps ) <+ white_noise(whi_noise * sourceConductance , "isource");
     if(flg_rd) I(BRddp ) <+ white_noise(whi_noise * drainConductance  , "idrain");
// Shot Noise
     I(BRgpdp) <+ white_noise(`C_QE2 * abs(Igd) , "iigd");
     I(BRgpsp) <+ white_noise(`C_QE2 * abs(Igs) , "iigs");
     I(BRgpbp) <+ white_noise(`C_QE2 * abs(Igb) , "iigb");
//
// Gate Resistance Currents
     if(CORG ==1 && RSHG > 0.0) I(BRggp) <+ grg * V(BRggp);
     else V(BRggp) <+ 0.0 ;
//
// Substrate Resistance Network
     if(CORBNET) begin
       I(BRsbbp) <+  grbps * V(BRsbbp) ;
       I(BRdbbp) <+  grbpd * V(BRdbbp) ;
       I(BRbbp ) <+  grbpb * V(BRbbp ) ;
       I(BRbdb ) <+  grbdb * V(BRbdb ) ;
       I(BRbsb ) <+  grbsb * V(BRbsb ) ;
     end else begin
       V(BRbbp ) <+  0.0 ; V(BRbsb ) <+  0.0 ; V(BRbdb ) <+  0.0 ; 
     end
      
`ifdef _AGING_
     // **************************************** //
     // integration Isub & Ontime
     // **************************************** //
     T0 =  TYPE * Isuba ;
     T0 = ( T0 < 0 || `pretime > $abstime ) ? 0.0 : T0 ;
     V(idtag1) <+ idt( T0 , 0 ); 
     T2 = ( Vgs > Vth  && TRAPA > 0 && `pretime < $abstime ) ? 1.0 : 0.0 ;
     T3 = ( Vgs > Vth  && TRAPA > 0 && `pretime < $abstime ) ? Vgs : 0.0 ;
     if ( TRAPA > 0 && CODEG == 1 && CODEGSTEP == 1 ) begin  // BTI model
       V(idtag3) <+ idt( T2 , 0 ); // On time 
       V(idtag4) <+ idt( T3 , 0 ); // Vgp  
     end else begin
       V(idtag3) <+ 0 ;
       V(idtag4) <+ 0 ;
     end
     if ( CODEG == 1 && TRAPA > 0 ) begin         // for BTI model
       V(dVfb)   <+ dVth_bti ;
     end else begin
       V(dVfb)   <+ 0 ;
     end
     if( CODEG == 1 && TRAPGC1MAX > 0 ) begin     // for HC model
       V(vgc1)    <+ gc1/1e24;
       V(ve1)     <+ e1;
     end else begin
       V(vgc1)    <+ 0 ;
       V(ve1)     <+ 0 ;
     end
     if( TRAPGC1MAX > 0 && CODEGSTEP == 0 ) begin // for HC model
       V(ps0)     <+ Ps0_prv ;
       V(vtraplx) <+ Vtraplx_prv ;
     end else begin
       V(ps0)     <+ 0 ;
       V(vtraplx) <+ 0 ;
     end
     // ************************************************ //
     // output the degradation file for aging simulation
     // ************************************************ //
     if( CODEG == 1 && CODEGSTEP == 0 ) begin
       fno=$fopen("degradation.out") ;
       ivgs = V(g,s) ;
       ivds = V(d,s) ;
       ivbs = V(b,s) ;
       $fdisplay(fno,".param %M_DEGTIME=%g %M_gc1deg=%g %M_es1deg=%g %M_dVthbti=%g %M_TRAPGC1=%g %M_TRAPGC2=%g %M_TRAPGC1MAX=%g %M_TRAPGCTIME1=%g %M_TRAPGCTIME2=%g %M_TRAPES1=%g %M_TRAPES2=%g %M_TRAPES1MAX=%g %M_TRAPLX=%g \n*     Isub_trap=%g Ids=%g VGDEG:%g VDDEG:%g VBDEG:%g",
       DEGTIME,gc1/`C_m2cm_p3,e1,dVth_bti,
       TRAPGC1,TRAPGC2,TRAPGC1MAX,TRAPGCTIME1,TRAPGCTIME2,TRAPES1,TRAPES2,TRAPES1MAX,TRAPLX,
       Isub_trap,Ids,ivgs,ivds,ivbs) ;
     end
     if( CODEG == 1 && CODEGSTEP == 1 ) begin
       @(final_step("tran")) begin
         fno=$fopen("degtran.out") ;
         $fdisplay(fno,".param %M_DEGTIME=%g %M_gc1deg=%g %M_es1deg=%g %M_dVthbti=%g \n*     Isub_trap=%g Ids=%g tcycle=%g Vgsonave=%g time:%g ",
         DEGTIME,gc1/`C_m2cm_p3,e1,dVth_bti, Isub_trap,Ids, tcycle,Vgsonave, $abstime) ;
       end
     end

`endif
      
   end 
//================ End of executable code.=================//
endmodule
