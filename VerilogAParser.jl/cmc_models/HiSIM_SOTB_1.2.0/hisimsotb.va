//************************************************************************
//
// HiSIM (Hiroshima University STARC IGFET Model)
// Copyright(C) 2016 Hiroshima University 
//
// MODEL NAME : HiSIM_SOTB (HiSIM Silicon-On-Thin-Buried-Oxide)
// ( VERSION : 1  SUBVERSION : 2  REVISION : 0 )
// Model Parameter 'VERSION' : 1.20
// FILE : hisimsotb.va
//
// DATE : 2018.2.21
//
// Released by Hiroshima University
//
//***********************************************************************/
//
//***********************************************************************
//
// The following source code, and all copyrights, trade secrets or other
// intellectual property rights in and to the source code in its entirety,
// are owned by Hiroshima University.
//
// All users need to follow the "HISIM-SOTB Distribution Statement and
// Copyright Notice" attached to HiSIM_SOTB model.
//
//-----HISIM-SOTB Distribution Statement and Copyright Notice--------------
//
// Software is distributed as is, completely without warranty or service
// support. Hiroshima University and its employees are not liable
// for the condition or performance of the software.
//
// Hiroshima University owns the copyright and grants users a perpetual,
// irrevocable, worldwide, non-exclusive, royalty-free license with respect 
// to the software as set forth below.   
//
// Hiroshima University hereby disclaims all implied warranties.
//
// Hiroshima University grants the users the right to modify, copy,
// and redistribute the software and documentation, both within the user's
// organization and externally, subject to the following restrictions
//
// 1. The users agree not to charge for Hiroshima University code
// itself but may charge for additions, extensions, or support.
//
// 2. In any product based on the software, the users agree to acknowledge
// Hiroshima University that developed the software. This
// acknowledgment shall appear in the product documentation.
//
// 3. The users agree to reproduce any copyright notice which appears on
// the software on any copy or modification of such made available
// to others.
//
// Toshimasa Asahara, President, Hiroshima University
// Hans Juergen Mattausch, Professor, Hiroshima University
// December 2014
//*************************************************************************/

//
`include "discipline.h"

// Disable COPPRV flag that cause issues in RF simulation.
`define DISABLE_COPPRV

//
//  Macros for the model/instance parameters
//
//  MPRxx    model    parameter real
//  MPIxx    model    parameter integer
//  IPRxx    instance parameter real
//  IPIxx    instance parameter integer
//     || 
//     cc    closed lower bound, closed upper bound
//     oo    open   lower bound, open   upper bound
//     co    closed lower bound, open   upper bound
//     oc    open   lower bound, closed upper bound
//     nb    no bounds
//     sw    switch(integer only, values  0=false  and  1=true)
//     ty    switch(integer only, values -1=p-type and +1=n-type)
//
//  IPM   instance parameter mFactor(multiplicity, implicit for LRM2.2)
//  OPP   operating point parameter, includes units and description for printing
//
`define ALIAS(alias,paramName) aliasparam alias = paramName ;
`define OPP(nam,uni,des)               (*units=uni,                   desc=des*)           real    nam ;
`define MPRnb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter real    nam=def ; 
`define MPRcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr] ; 
`define MPRoo(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr) ; 
`define MPRco(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from[lwr:upr) ; 
`define MPRoc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter real    nam=def from(lwr:upr] ; 
`define MPIcc(nam,def,uni,lwr,upr,des) (*units=uni,                   desc=des*) parameter integer nam=def from[lwr:upr] ;
`define MPInb(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def ;
`define MPIsw(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[  0:  1] ;
`define MPIty(nam,def,uni,        des) (*units=uni,                   desc=des*) parameter integer nam=def from[ -1:  1] exclude 0 ;
`define IPRnb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def ; 
`define IPRcc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr] ; 
`define IPRoo(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr) ; 
`define IPRco(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from[lwr:upr) ; 
`define IPRoc(nam,def,uni,lwr,upr,des) (*units=uni, type="instance",  desc=des*) parameter real    nam=def from(lwr:upr] ; 
`define IPInb(nam,def,uni,        des) (*units=uni, type="instance",  desc=des*) parameter integer nam=def ;
`ifdef EXPLICIT_MFACTOR
   `define IPM                        (*units="" , type="instance",  desc="multiplicity factor"*) parameter real m=1.0 from(0.0:inf) ;
   `define MFACTOR_USE m 
`else // 
   `define IPM
   `define MFACTOR_USE 1.0
`endif

`define Kflic         1 
`define Kwhite        1 

// For Debugging print
`ifdef DEBUG
`define DEBUG_PRINT(xName, x) $strobe("%s = %g", xName, 1.0*x)
`else
`define DEBUG_PRINT(xName, x)
`endif

`define HiSIM_NORMAL_MODE     1                  // device working mode 
`define HiSIM_REVERSE_MODE   -1              
//---------------------------------------------------* 
//* Numerical constants. (macro) 
//*-----------------*/
`define C_EPS_M                   (2.2204460492503131e-16) 
`define C_SQRT_2                  (1.414213562373095e+00)       // sqrt(2) 
`define C_1o3                     (3.333333333333333e-01)       // 1/3 
`define C_2o3                     (6.666666666666667e-01)       // 2/3 
`define C_2p_1o3                  (1.259921049894873e+00)       // 2^(1/3) 
`define C_Pi                      (3.141592653589793)   // Pi 
`define C_m2cm                    (1.0e2)               // Unit change 
`define C_m2cm_p2                 (1.0e4)              
`define C_m2cm_p1o2               (1.0e1)              
`define C_m2um                    (1.0e6)              
`define C_cm2m                    (1.0e-2)               // Unit change 
`define C_cm2m_p2                 (1.0e-4)
`define C_cm2m_p3                 (1.0e-6)
`define C_cm2m_adhoc              (1.0e2)
`define C_cm2um                   (1.0e4)
//---------------------------------------------------* 
//* Physical constants/properties. (macro) 
//*-----------------*/
`define C_QE                      (1.6021918e-19)       // Elemental charge 
`define C_KB                      (1.3806226e-23)       // Boltzmann constant 
`define C_ESI                     (1.034943e-10 )        // Permittivity of Si, SiO2 and vacuum 
`define C_EOX                     (3.453133e-11 )       
`define C_b300                    (3.868283e+01)       
`define C_Nin0                    (1.04e+16)            // Intrinsic carrier density at 300K 

//---------------------------------------------------* 
//* flatZero: flooring to zero.
//*      y = 0.5 ( x + sqrt( x^2 + 4 delta^2 ) )
//*-----------------*/
//    *dx = 0.5 * (1.0 + x / TMF2) ;
//    *y = 0.5 * (x + TMF2) ;

`define t_fox                     (TFOX)               
`define t_SOI                     (TSOI)               
`define t_box                     (TBOX)               
`define N_sub_SOI                 (UC_NSUBS)           
`define N_sub_bulk                (MKS_NSUBB)              
`define C_PHI_1_MINIMUM           (1e-8)               
`define C_IDD_MIN                 1E-15                

`define lp_s0_max_qov 40
`define dP_max        ( 0.1 )               
`define ps_conv       ( 1.0e-12 )           
`define ps_conv_ini   ( 1.0e-3 )
`define znbd3         ( 3.0 )               
`define znbd5         ( 5.0 )               
`define cn_nc3        ( `C_SQRT_2 / 108.0 )  
`define cn_nc51       ( 0.707106781186548 )  // sqrt(2)/2 */
`define cn_nc52       ( -0.117851130197758 )  // -sqrt(2)/12 */
`define cn_nc53       ( 0.0178800506338833 )  // (187 - 112*sqrt(2))/1600 */
`define cn_nc54       ( -0.00163730162779191 )  // (-131 + 88*sqrt(2))/4000 */
`define cn_nc55       ( 6.36964918866352e-5 )  //(1509-1040*sqrt(2))/600000 */
`define c_ps0ini_2    ( 8.0e-4 )            
`define c_pslini_1    ( 0.3 )               
`define c_pslini_2    ( 3.0e-2 )            
`define VgVt_Small    ( 1.0e-12 )           
`define epsm10        ( 10.0 * `C_EPS_M )   
`define Small         ( 1.0e-50 )           
`define Small2        ( 1.0e-12 )    //for Qover */
`define cclmmdf       ( 1.0e-1 )            
`define qme_dlt       ( 1.0e-4 )            
`define eef_dlt       ( 1.0e-2 )            
`define Ievb_min      ( 1.0e-9 )
`define sti2_dlt      ( SUBDLT )
`define psisti_dlt    ( 5.0e-3 )
`define c_exp_2       ( 7.38905609893065 )     // exp(2)
`define c_expm3       ( 0.049787068367863944 ) // exp(-3)
`define c_sqrt_15     ( 3.872983346207417e0 )  // sqrt(15) */
`define C_fox_Small   ( 1.0e-6 )            
`define c_16o135      ( 1.185185185185185e-1 )  // 16/135 */
`define igate_dlt     ( 1.0e-2 )            
`define pol_dlt       ( 5.0e-2 )            
`define psia_dlt      ( 1.0e-3 )
`define psia2_dlt     ( 5.0e-3 )
`define pol_b         ( 1.0 )               
`define cn_im53       ( 2.9693154855770998e-1 )  
`define cn_im54       ( -7.0536542840097616e-2 )  
`define cn_im55       ( 6.1152888951331797e-3 )  
`define large_arg     ( 80 )                  // Old value = ( ln(1.0e100) )      
`define gs_conv       ( 1.0e-8 )            
`define cnst_2esi_q   ( 2 * `C_ESI / `C_QE )  
`define N             ( 100 )               
`define X_vbs         ( xvbs )              
`define X_sub1        ( xsub1 )             
`define X_sub2        ( xsub2 )             
`define X_vgs         ( UC_SVGS )           
`define Z_vgs         ( zvgs )              
`define X_vds         ( SVDS )              
`define X_slg         ( xgate )             
`define Nd            ( 1e20 / `C_cm2m_p3)              
`define Dn            ( 36.0 )              
`define Dp            ( 13.0 )              
`define Ln            ( sqrt(`Dn * 1e-7 / `C_cm2m_p2) )   
`define Lp            ( sqrt(`Dp * 1e-7 / `C_cm2m_p2) )   
`define Q_FD_BOX      ( 0.1 * C_box )             
`define NQS_CAP       ( 1E-9 )  // Scaling for NQS charge 
`define EXP_THRES     (  80 )   // Maximum limit of Exp.
`define EXP_THRES_MIN ( -34 )   // Minimum limit of Exp.
`define MAX_EXP       ( 5.540622384e+34 )    

//===========================================================*
//* Sigmoid function
//*=================*/
`define Fn_Sigmoid( y , x ) y = 1.0 / ( 1.0 + exp(-x) );
`define Fn_Sigmoidx( y , x , dx ) begin y = 1.0 / ( 1.0 + exp(-x) ); dx = y*y*exp(-x); end

//Start of HiSIM_SOTB model code

// Module Definition
module hisimsotb_va(d, g, s, e) ;
   inout      d, g, s, e ;
   electrical d, g, s, e ;                          // External Nodes 
   thermal    t ;
   electrical gp, bp ;
   electrical n, nqs_qi, nqs_qb, nqs_qhs ;  // Internal Nodes 

// Branch Definitions

   branch(g ,gp) BRggp  ;
   branch(gp,s ) BRgps  ;
   branch(gp,d ) BRgpd  ;
   branch(gp,bp) BRgpbp ;
   branch(d ,s ) BRds   ;
   branch(s ,d ) BRsd   ;
   branch(d ,g ) BRdg   ;
   branch(g ,d ) BRgd   ;
   branch(s ,g ) BRsg   ;
   branch(g ,s ) BRgs   ;
   branch(bp,d ) BRbpd  ;
   branch(d ,bp) BRdbp  ;
   branch(bp,s ) BRbps  ;
   branch(s ,bp) BRsbp  ;
   branch(bp,g ) BRbpg  ;
   branch(g ,bp) BRgbp  ;
   branch( e,bp) BRebp  ;

//
// Parameter definitions

//******* Device Parameters *******//
`IPRoo( L         , 5.0E-6    , "m"            , 0, inf , "Gate length (Lgate)" ) 
`IPRoo( W         , 5.0E-6    , "m"            , 0, inf , "Gate width (Wgate)" ) 
`IPRoo( NGCON     , 1.0       , ""             , 0, inf , "Number of gate contacts" ) 
`IPRnb( XGW       , 0E0       , "m"                     , "Distance from gate contact to channel edge" )
`IPRco( XGL       , 0E0       , "m"            , -L,  L , "Offset of gate length" ) 
`IPM
`IPRoo( NF        , 1.0       , ""             , 0, inf , "Number of gate fingers" ) 
`IPRco( SA        , 0         , "m"            , 0, inf , "Length of diffusion between gate and STI" ) 
`IPRco( SB        , 0         , "m"            , 0, inf , "Length of diffusion between gate and STI" ) 
`IPRco( SD        , 0         , "m"            , 0, inf , "Length of diffusion between gate and gate" ) 
`IPRnb( TEMP      , 27        , "degC"                  , "Device temperature" )
`IPRnb( DTEMP     , 0         , "degC"                  , "Device temperature change" )
`IPRnb( SCA       , 0.0       , "-"                     , "Layout characterization factor" )
`IPRnb( SCB       , 0.0       , "-"                     , "Layout characterization factor" )
`IPRnb( SCC       , 0.0       , "-"                     , "Layout characterization factor" )

//******* Model Flags *******//
`MPIsw( COPPRV    , 1         , ""                      , "Previous phi_s flag" )
`MPIsw( COADOV    , 1         , ""                      , "Lateral field induced and overlap capacitances are added to intrinsic" )
`MPIsw( COISUB    , 0         , ""                      , "Substrate current flag" )
`MPIsw( COFBE     , 0         , ""                      , "Floating-Body Effect flag" )
`MPIsw( COIIGS    , 0         , ""                      , "Gate current flag" )
`MPIsw( COGIDL    , 0         , ""                      , "GIDL current flag" )
`MPIsw( COOVLP    , 0         , ""                      , "Overlap capacitance model selector" )
`MPIsw( COIGN     , 0         , ""                      , "Induced gate and cross correlation noise flag" )
`MPIsw( COFLICK   , 0         , ""                      , "1/f noise flag" )
`MPIsw( COISTI    , 0         , ""                      , "Calculate STI ")
`MPIsw( COTHRML   , 0         , ""                      , "Thermal noise flag" )
`MPIsw( CONQS     , 0         , ""                      , "Non-quasi-static model flag" )
`MPIsw( CORG      , 0         , ""                      , "Gate-contact resistance flag" )
`MPIsw( COIEVB    , 0         , ""                      , "Valence-band-electron-tunneling-current model flag" )
`MPIsw( COHIST    , 0         , ""                      , "History Effect flag" )
`MPIsw( COSELFHEAT, 0         , ""                      , "Self-Heating flag" )
`MPIsw( COVBSBIZ  , 0         , ""                      , "Symmetry treatment flag" )
`MPIcc( COQOVSM   , 1         , ""              , 0,  2 , "Qover capacitance model selector" )
`MPInb( INFO      , 0         , ""                      , "print information selector" )
`MPIsw( COMUUNSZ  , 1         , ""                      , "Mobility smoothing flag" )
`MPIsw( CONEWMUB  , 1         , ""                      , "New mobility model flag" )

//******* Technology Model Parameters *******//
`MPIty( TYPE      , 1         , ""                      , "1 for nMOS and -1 for pMOS" )
`MPRnb( VERSION   , 1.10      , "-"                     , "model version selector" )
`MPRoo( VMAX      , 7.00E+6   , "cm*s^-1"     , 0, inf  , "maximum saturation velocity" )
`MPRnb( BGTMP1    , 90.25E-6  , "eV*K^-1"               , "temperature dependence of bandgap" )
`MPRnb( BGTMP2    , 100.0E-9  , "eV*K^-2"               , "temperature dependence of bandgap" )
`MPRnb( EG0       , 1.1785    , "eV"                    , "bandgap" )
`MPRnb( XLD       , 0.0       , "m"                     , "gate overlap length" )
`MPRnb( VFBOVER   , 0.0       , "V"                     , "flat-band voltage in overlap region" )
`MPRnb( NOVER     , 1E19      , "cm^-3"                 , "impurity concentration in overlap region" )
`MPRnb( XWD       , 0.0       , "m"                     , "gate overlap width" )
`MPRnb( XWDC      , XWD       , "m"                     , "different width dependence of cap. from currents" )
`MPRoo( SAREF     , 1E-6      , "m"            , 0, inf , "ref-dist between OD edge to poly of one side" )
`MPRoo( SBREF     , 1E-6      , "m"            , 0, inf , "ref-dist between OD edge to poly of the other side" )
`MPRco( XQY       , 0.0       , "m"            , 0, inf , "distance from junction to max field point" )
`MPRnb( XQY1      , 0.0       , "F*um^XQY2-1"           , "Ves-dependence of Qy" )
`MPRnb( XQY2      , 2.0       , ""                      , "Lgate-dependence of Qy" )
`MPRcc( RSHG      , 0.0       , "Ohm/square"   , 0, 100 , "gate sheet resistance" )
`MPRnb( VFBC      , -1.0      , "V"                     , "flat-band voltage" )
`MPRnb( VFBCL1    , 0.0       , "um^VFBCL1P"            , "channel length dependence of flat-band voltage" )
`MPRnb( VFBCL1P   , 1.0       , ""                      , "channel length dependence of flat-band voltage" )
`MPRnb( VFBCL2    , 0.0       , "um^VFBCL2P"            , "channel length dependence of flat-band voltage" )
`MPRnb( VFBCL2P   , 1.0       , ""                      , "channel length dependence of flat-band voltage" )
`MPRnb( VFBHAMP   , 0.0       , "V*cm^-1"               , "channel length dependence of flat-band voltage" )
`MPRnb( VBI       , 1.1       , "V"                     , "built-in potential" )
`MPRoo( PARL1     , 10.0E-9   , "m"         , -L/2, inf , "SOI SCE parameter" )
`MPRoo( PARL2     , 10.0E-9   , "m"         , -inf,   L , "depletion width of channel/contact junction" )
`MPRnb( LP        , 0.0       , "m"                     , "pocket penetration length" )
`MPRoo( NSUBP     , 1.0E+17   , "cm^-3"        , 0, inf , "max pocket concentration" )
`MPRnb( NSUBP0    , 0.0       , "um^NSUBWP"             , "mod of pocket concentration for narrow W" )
`MPRnb( NSUBWP    , 1.0       , ""                      , "mod of pocket concentration for narrow W" )
`MPRnb( WL1       , 0.0        , ""                     , "Gate width parameter ")
`MPRnb( WL1P      , 1.0        , ""                     , "Gate width parameter ")
`MPRnb( WL2       , 0.0       , "Vum^WL2P"              , "threshold voltage shift due to small-size effect" )
`MPRnb( WL2P      , 1.0       , ""                      , "threshold voltage shift due to small-size effect" )
`MPRnb( SCP1      , 0.0       , ""                      , "magnitude of short-channel effect due to pocket" )
`MPRnb( SCP2      , 0.0       , "V^-1"                  , "Vds-dependence of SCE due to pocket" )
`MPRnb( SCP3      , 0.0       , "m*V^-1"                , "Vds-dependence of SCE due to pocket" )
`MPRnb( SC1       , 0.0       , ""                      , "magnitude of short-channel effect" )
`MPRnb( SC2       , 0.0       , "V^-1"                  , "Vds-dependence of short-channel effect" )
`MPRnb( SC3       , 0.0       , "m*V^-1"                , "Ves dependence of short-channel effect" )
`MPRnb( SCR1      , 0.0       , ""                      , "parameter for SCE via BOX" )
`MPRnb( SCR2      , 0.0       , ""                      , "parameter for SCE via BOX" )
`MPRnb( SCR3      , 0.23      , ""                      , "parameter for SCE via BOX" )
`MPRnb( PGD1      , 0.0       , "V"                     , "strength of poly-depletion effect" )
`MPRnb( PGD2      , 1.0       , "V"                     , "threshold voltage of poly-depletion effect" )
`MPRnb( PGD4      , 0.0       , ""                      , "Lgate-dependence of poly-depletion effect" )
`MPRnb( NDEP      , 1.0       , ""                      , "depletion charge contribution on effective-electric field" )
`MPRnb( NDEPL     , 0.0       , ""                      , "modify QB contribution for short channel" )
`MPRnb( NDEPLP    , 0.0       , ""                      , "modify QB contribution for short channel" )
`MPRnb( NINV      , 0.5       , ""                      , "inversion charge contribution on effective-electric field" )
`MPRnb( NINVL     , 0.0       , ""                      , "length dependence of NINV" )
`MPRnb( NINVLP    , 0.0       , ""                      , "length dependence of NINV" )
`MPRnb( NINVD     , 0.0       , "V^-1"                  , "reduced resistance effect for small Vds" )
`MPRnb( NINVDP    , 1.0       , "V^-1"                  , "reduced resistance effect for small Vds" )
`MPRnb( MUECB0    , 300.0     , "cm^2V^-1s^-1"          , "Coulomb scattering for current" )
`MPRnb( MUECB1    , 30.0      , "cm^2V^-1s^-1"          , "Coulomb scattering for current" )
`MPRnb( MUECB0LP  , 1.0       , ""                      , "length dependence of Coulomb scattering for current" )
`MPRnb( MUECB1LP  , 1.0       , ""                      , "length dependence of Coulomb scattering for current" )
`MPRnb( MUECB0L2  , 0.0       , ""                      , "length dependence of Coulomb scattering for current" )
`MPRnb( MUECB0L2P , 1.0       , ""                      , "length dependence of Coulomb scattering for current" )
`MPRnb( MUECB1L2  , 0.0       , ""                      , "length dependence of Coulomb scattering for current" )
`MPRnb( MUECB1L2P , 1.0       , ""                      , "length dependence of Coulomb scattering for current" )
`MPRnb( MUEPH0    , 300.0E-3  , ""                      , "phonon scattering for current" )
`MPRnb( MUEPHW    , 0.0       , "um^MUEPHP"             , "phonon-related mobility reduction" )
`MPRnb( MUEPWP    , 1.0       , ""                      , "phonon-related mobility reduction" )
`MPRnb( MUEPHL    , 0.0       , ""                      , "length dependence of phonon mobility reduction for current" )
`MPRnb( MUEPLP    , 1.0       , ""                      , "length dependence of phonon mobility for current" )
`MPRnb( MUEPHS    , 0.0       , "um^MUEPSP"             , "mobility change due to small size" )
`MPRnb( MUEPSP    , 1.0       , ""                      , "mobility change due to small size" )
`MPRnb( VTMP      , 0.0       , ""                      , "temperature-dependence of saturation velocity" )
`MPRnb( VTMPL     , 0.0       , ""                      , "temperature-dependence of saturation velocity" )
`MPRnb( VTMPLP    , 1.0       , ""                      , "temperature-dependence of saturation velocity" )
`MPRnb( WVTH0     , 0.0       , "Vum^WVTHP"             , "threshold voltage shift" )
`MPRnb( WVTHP     , 1.0       , ""                      , "threshold voltage shift" )
`MPRoo( MUESR1    , 2.0E15    , "cm^2V^-1s^-1" , 0, inf , "surface-roughness scattering for current" )
`MPRnb( MUESR0    , 2.0       , ""                      , "surface-roughness scattering for current" )
`MPRnb( MUESRL    , 0.0       , "um^MUESLP"             , "length dependence of surface roughness mobility reduction for current" )
`MPRnb( MUESRW    , 0.0       , "um^MUESWP"             , "surface roughness-related mobility change" )
`MPRnb( MUESWP    , 1.0       , ""                      , "surface roughness-related mobility change" )
`MPRnb( MUESLP    , 1.0       , ""                      , "length dependence of surface roughness mobility reduction for current" )
`MPRnb( MUETMP    , 1.5       , "um^MUEPLP"             , "temperature-dependence of phonon scattering" )
`MPRnb( MUETMPL   , 0.0       , ""                      , "temperature-dependence of phonon scattering" )
`MPRnb( MUETMPLP  , 1.0       , ""                      , "temperature-dependence of phonon scattering" )
`MPRoo( BB        , ((TYPE>0) ? 2:1), ""       , 0, inf , "high-field-mobility degradation" )
`MPRco( DDLTMAX   , 10.0      , ""             , 1, inf , "smoothing coefficient for Vds" )
`MPRco( DDLTSLP   , 50.0      , "um^-1"        , 0, inf , "Lgate-dependence of smoothing coefficient" )
`MPRnb( DDLTICT   , 0.0       , ""                      , "Lgate-dependence of smoothing coefficient" )
`MPRnb( SUB1      , 10.0      , "V^-1"                  , "substrate current coefficient of magnitude" )
`MPRnb( SUB2      , 20.0      , "V"                     , "substrate current coefficient of exponential term" )
`MPRnb( SUB1L     , 2.5E-3    , "m"                     , "Lgate-dependence of SUB1" )
`MPRnb( SUB1LP    , 1.0       , ""                      , "Lgate-dependence SUB1" )
`MPRnb( SUB2L     , 2.0E-6    , "m"                     , "Lgate-dependence of SUB2" )
`MPRnb( SVDS      , 0.8       , ""                      , "substrate current dependence on Vds" )
`MPRco( SLG       , 3.0E-8    , "m"            , 0, inf , "substrate current dependence on Lgate" )
`MPRnb( SVBS      , 0.5       , ""                      , "substrate current dependence on Ves" )
`MPRnb( SVBSL     , 0.0       , "m^SVBSLP"              , "Lgate-dependence of SVBS" )
`MPRnb( SVBSLP    , 1.0       , ""                      , "Lgate-dependence of SVBS" )
`MPRnb( SVGS      , 0.8       , ""                      , "substrate current dependence on Vgs" )
`MPRnb( SVGSL     , 0.0       , "m^SVGSLP"              , "Lgate-dependence of SVGS" )
`MPRnb( SVGSLP    , 1.0       , ""                      , "Lgate-dependence of SVGS" )
`MPRnb( SVGSW     , 0.0       , "m^SVGSWP"              , "Wgate-dependence of SVGS" )
`MPRnb( SVGSWP    , 1.0       , ""                      , "Wgate-dependence of SVGS" )
`MPRnb( VFBSUB    , -1.0      , "V"                     , "flatband voltage for Isub calculation" )
`MPRnb( VFBSUBL   , 0.0       , "um^VFBSUBLP"           , "Lgate-dependence of VFBSUB" )
`MPRnb( VFBSUBLP  , 1.0       , ""                      , "Lgate-dependence of VFBSUB" )
`MPRnb( SUBDLT    , 2.0E-3    , ""                      , "smoothing parameter (hisimsoi\_fb only)" )
`MPRnb( HIST1     , 10E-9     , "V"                     , "history-effect parameter" )
`MPRnb( HIST2     , 1E-20     , "A"                     , "history-effect parameter" )
`MPRnb( QHE1      , 1.5       , ""                      , "FBE parameter" )
`MPRnb( QHE2      , 0.55      , "V"                     , "FBE parameter" )
`MPRnb( EVB1      , 0.0       , "V^-2s^-1"              , "electron tunneling from valence band" )
`MPRnb( EVB2      , 0.0       , "V*m^-1"                , "electron tunneling from valence band" )
`MPRnb( EVB3      , 0.0       , ""                      , "electron tunneling from valence band" )
`MPRnb( FVBS      , 0.0       , ""                      , "Ves dependence of Fowler-Nordheim current" )
`MPRnb( IBPC1     , 0.0       , "Ohm"                   , "impact-ionization-induced bulk potential change" )
`MPRnb( IBPC2     , 0.0       , "V^-1"                  , "impact-ionization-induced bulk potential change" )
`MPRoo( NSTI      , 5.0E17     , "1/cm^3"   ,   0 , inf , "Parameter for STI  ")
`MPRnb( NSTIL     , 0.0        , ""                     , "Parameter for STI  ")
`MPRnb( NSTILP    , 1.0        , ""                     , "Parameter for STI  ")
`MPRnb( NSTIW     , 0.0        , ""                     , "Parameter for STI  ")
`MPRnb( NSTIWP    , 1.0        , ""                     , "Parameter for STI  ")
`MPRnb( WSTI      , 0.0        , "m"                    , "Parameter for STI  ")
`MPRnb( RATWSTI   , 0.0        , "m"                    , "Parameter for STI  ")
`MPRnb( WSTIL     , 0.0        , ""                     , "Parameter for STI  ")
`MPRnb( WSTILP    , 1.0        , ""                     , "Parameter for STI  ")
`MPRnb( WSTIW     , 0.0        , ""                     , "Parameter for STI  ")
`MPRnb( WSTIWP    , 1.0        , ""                     , "Parameter for STI  ")
`MPRnb( SCSTI1    , 0.0        , ""                     , "Parameter for STI  ")
`MPRnb( SCSTI2    , 0.0        , "1/V"                  , "Parameter for STI  ")
`MPRnb( VTHSTI    , 0.0        , ""                     , "Parameter for STI  ")
`MPRnb( VDSTI     , 0.0        , ""                     , "Parameter for STI  ")
`MPRco( MUESTI1   , 0.0       , "cm"          ,  0, inf , "mobility change due to diffusion length" )
`MPRoo( MUESTI2   , 0.0       , ""            , -1, inf , "mobility change due to diffusion length" )
`MPRnb( MUESTI3   , 1.0       , ""                      , "mobility change due to diffusion length" )
`MPRco( NSUBPSTI1 , 0.0       , "cm"          ,  0, inf , "pocket concentration modifier" )
`MPRoo( NSUBPSTI2 , 0.0       , ""            , -1, inf , "pocket concentration modifier" )
`MPRnb( NSUBPSTI3 , 1.0       , ""                      , "pocket concentration modifier" )
`MPRco( NSUBSSTI1 , 0.0       , "cm"         ,  0 , inf , "Channel concentration change due to diffusion-region length between gate and STI" )
`MPRoo( NSUBSSTI2 , 0.0       , ""           , -1 , inf , "Channel concentration change due to diffusion-region length between gate and STI" )
`MPRnb( NSUBSSTI3 , 1.0       , ""                      , "Channel concentration change due to diffusion-region length between gate and STI" )
`MPRnb( TPOLY     , 0.0       , "m"                     , "height of poly-Si gate for fringing cap" )
`MPRco( CGBO      , 0.0       , "F*m^-1"       , 0, inf , "gate-to-bulk overlap cap" )
`MPRco( CGDO      , 0.0       , "F*m^-1"       , 0, inf , "gate-to-drain overlap cap" )
`MPRco( CGSO      , 0.0       , "F*m^-1"       , 0, inf , "gate-to-source overlap cap" )
`MPRnb( LOVER     , 30E-9     , "m"                     , "overlap length" )
`MPRnb( CLM1      , 700.0E-3  , ""                      , "hardness coefficient of channel/contact junction" )
`MPRnb( CLM2      , 2.0       , ""                      , "coefficient for QB contribution" )
`MPRnb( CLM3      , 1.0       , ""                      , "coefficient for QI contribution" )
`MPRnb( CLM5      , 1.0       , ""                      , "CLM parameter" )
`MPRnb( CLM6      , 0.0       , "um^-CLM5"              , "CLM parameter" )
`MPRnb( VOVER     , 10.0E-3   , "um^VOVERP"             , "velocity overshoot effect" )
`MPRnb( VOVERP    , 100.0E-3  , ""                      , "Leff dependence of velocity overshoot" )
`MPRnb( VOVERS    , 0.0       , ""                      , "modification of max velocity due to small size" )
`MPRnb( VOVERSP   , 1.0       , ""                      , "modification of max velocity due to small size" )
`MPRnb( VOVERL    , 0.0       , ""                      , "velocity overshoot effect parameter" )
`MPRnb( VOVERLP   , 1.0       , ""                      , "velocity overshoot effect parameter" )
`MPRnb( VOVERW    , 0.0       , ""                      , "velocity overshoot effect parameter" )
`MPRnb( VOVERWP   , 1.0       , ""                      , "velocity overshoot effect parameter" )
`MPRnb( WFC       , 0.0       , "F*m"                   , "Threshold voltage change due to cap change" )
`MPRnb( NSUBSW    , 0.0       , "um^NSUBSWP"            , "substrate concentration modifier" )
`MPRnb( NSUBSWP   , 1.0       , ""                      , "substrate concentration modifier" )
`MPRnb( NSUBSMAX  , 5E18      , "cm^-3"                 , "upper limit of substrate concentration" )
`MPRnb( QME1      , 0.0       , "mV"                    , "Vgs-dependence of quantum mechanical effect" )
`MPRnb( QME2      , 0.0       , "V"                     , "Vgs-dependence of quantum mechanical effect" )
`MPRnb( QME3      , 0.0       , "m"                     , "minimum Tfox modification" )
`MPRnb( GIDL1     , 5.0E-6    , "A*V^-3/2C^-1m^1/2"     , "magnitude of GIDL" )
`MPRnb( GIDL2     , 1.0E6     , "V^-2m^-1F^-3/2"        , "field-dependence of GIDL" )
`MPRnb( GIDL3     , 300.0E-3  , ""                      , "Vds-dependence of GIDL" )
`MPRnb( GIDL4     , 0.0       , "V"                     , "threshold for Vds dependence" )
`MPRnb( GIDL5     , 0.2E0     , ""                      , "high-field correction" )
`MPRnb( GIDLBPL1  , 1.0E-6    , "m"                     , "Length for GIDL/GISL parasitic bipolar effect" )
`MPRnb( GIDLBPLT  , 0.0       , ""                      , "Temperature effect for GIDLBPL1" )
`MPRnb( GLEAK1    , 10.0E3    , "V^-3/2*s^-1"           , "gate-to-channel current coefficient" )
`MPRnb( GLEAK2    , 20.0E6    , "V^-1/2*m^-1"           , "gate-to-channel current coefficient" )
`MPRnb( GLEAK3    , 300.0E-3  , ""                      , "gate-to-channel current coefficient" )
`MPRnb( GLEAK4    , 0.0       , "m^-1"                  , "gate-to-channel current coefficient" )
`MPRnb( GLEAK5    , 7.5E3     , "V*m^-1"                , "G-t-C short channel correction" )
`MPRnb( GLEAK6    , 250E-3    , "V"                     , "G-t-C Vds-dependence correction" )
`MPRnb( GLEAK7    , 1E-6      , "m^2"                   , "G-t-C L and W dependence correction" )
`MPRnb( GLKSD1    , 1.0E-15   , "A*m*V^-2"              , "G-t-S/D current coefficient" )
`MPRnb( GLKSD2    , 5E6       , "V^-1*m^-1"             , "G-t-S/D current coefficient" )
`MPRnb( GLKSD3    , -5E6      , "m^-1"                  , "G-t-S/D current coefficient" )
`MPRnb( GLKB1     , 5E-16     , "A*V^-2"                , "G-t-S/D current coefficient" )
`MPRnb( GLKB2     , 1E0       , "m*V^-1"                , "G-t-S/D current coefficient" )
`MPRnb( GLKB3     , 0E0       , "V"                     , "G-t-S/D current coefficient" )
`MPRnb( VZADD0    , 10.0E-3   , "V"                     , "symmetry conservation coefficient" )
`MPRnb( PZADD0    , 5.0E-3    , "V"                     , "symmetry conservation coefficient" )
`MPRnb( NFTRP     , 10E9      , "V^-1"                  , "ratio of trap density to attenuation coefficient" )
`MPRnb( NFALP     , 1.0E-16   , "cm*s"                  , "contribution of mobility fluctuation" )
`MPRnb( CIT       , 0.0       , "F*cm^-2"               , "cap caused by the interface trapped carriers" )
`MPRnb( FALPH     , 1.0       , "sm^3"                  , "power of f describing deviation of 1/f" )
`MPRcc( TNOM      , 27.0      , "degC"        , 22,  32 , "temperature selected as a nominal value" )
`MPRnb( DLY1      , 100.0E-12 , "s"                     , "coefficient for delay due to diffusion of carriers" )
`MPRnb( DLY2      , 0.7E0     , ""                      , "coefficient for delay due to conduction of carriers" )
`MPRnb( DLY3      , 0.8E-6    , "Ohm"                   , "coefficient for RC delay of bulk carriers" )
`MPRoo( TFOX      , 3.5E-9    , "m"            , 0, inf , "front oxide thickness" )
`MPRoo( TSOI      , 10E-9     , "m"            , 0, inf , "silicon film thickness" )
`MPRnb( TFOXGIDL  , TFOX      , "m"                     , "TFOX for GIDL" )
`MPRoo( TBOX      , 10E-9     , "m"            , 0, inf , "buried oxide thickness" )
`MPRoo( NSUBS     , 1E+17     , "cm^-3"        , 0, inf , "SOI layer impurity concentration" )
`MPRoo( NSUBB     , 1E+18     , "cm^-3"        , 0, inf , "substrate impurity concentration" )
`MPRnb( NSUBBL    , 0.0       , "um^NSUBBLP"            , "channel-length dependence of NSUBB" )
`MPRnb( NSUBBLP   , 1.0       , ""                      , "channel-length dependence of NSUBB" )
`MPRnb( NSUBBW    , 0.0       , "um^NSUBBWP"            , "W dependence of NSUBB" )
`MPRnb( NSUBBWP   , 1.0       , ""                      , "W dependence of NSUBB" )
`MPRnb( NSUBBMIN  , 1E+14     , "cm^-3"                 , "minimum values of NSUBB" )
`MPRnb( RTH0      , 0.1       , "K*cm*W^-1"             , "Thermal resistance" )
`MPRnb( CTH0      , 1.0E-7    , "W*s*(K*cm)^-1"         , "thermal capacitance" )
`MPRnb( PTL       , 0.0       , "V^PTP-1m^PTLP"         , "strength in front current" )
`MPRnb( PTP       , 3.5       , ""                      , "strength in front current" )
`MPRnb( PT2       , 0.0       , "V^-1"                  , "Vds dependence in front current" )
`MPRnb( PTLP      , 1.0       , ""                      , "Lgate dependence in front current" )
`MPRnb( PT4       , 0.0       , ""                      , "punchthrough parameter" )
`MPRnb( PT4P      , 1.0       , ""                      , "Ves dependence in front current" )
`MPRnb( PTDLT     , 100.0     , ""                      , "punchthrough parameter" )
`MPRnb( GDL       , 0.0       , "m^GDLP"                , "strength of high-field effect in back current" )
`MPRnb( GDLP      , 0.0       , ""                      , "Lgate dependent high-field effect in front current" )
`MPRnb( GDLD      , 0.0       , "m"                     , "Lgate dependent high-field effect in front current" )
`MPRnb( MUEPH1    , 25.0E3    , "cm^2V^-1s^-1"          , "phonon scattering for current" )
`MPRnb( SC5       , 0.0       , ""                      , "SCE parameter" )
`MPRoo( XLDL      , 20.0e-9   , "m"            , 0, inf , "channel-length dependence of XLD" )
`MPRoo( XLDLMIN   , 10.0e-9   , "m"            , 0, inf , "minimum value of XLDL" )
`MPRnb( MUETMP1   , 0.0       , "um^MUEPLP"             , "temperature-dependence of phonon scattering" )
`MPRnb( VOTMP     , 0.0       , ""                      , "temperature-dependence coefficient" )
`MPRnb( VBSBND    , 1.0       , "V"                     , "Vbs for smoothing" )
`MPRnb( VBSMAX    , 1.2       , "V"                     , "Maximum Vbs" )
`MPRnb( GLEAK8    , 1.0E0     , "m^2"                   , "gate-to-channel current coefficient" )
`MPRnb( GLEAK9    , 5.0E-1    , "m^2"                   , "gate-to-channel current coefficient" )
`MPRnb( GLEAK10   , 0.0E0     , "m^2"                   , "gate-to-channel current coefficient" )
`MPRnb( GLKSD4    , 0.0E0     , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKSD5    , 1.0E0     , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB4     , 1E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB5     , 1E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB6     , 1E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB7     , 10E-12    , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB8     , 15E-12    , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB21    , 5E-16     , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB22    , 1E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB23    , 0E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB24    , 1E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB25    , 1E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB26    , 1E0       , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB27    , 10E-12    , ""                      , "G-t-S/D current coefficient" )
`MPRnb( GLKB28    , 15E-12    , ""                      , "G-t-S/D current coefficient" )
`MPRnb( PTMUEPH   , 1.0       , ""                      , "front side mobility of punch-through" )
`MPRnb( VOTMP2    , 0.0       , ""                      , "temperature-dependence coefficient" )

`MPRnb( MUEPH0B   , MUEPH0    , ""                      , "phonon scattering for current" )
`MPRnb( MUEPH1B   , MUEPH1    , ""                      , "phonon scattering for current" )
`MPRnb( MUEPHWB   , MUEPHW    , "um^MUEPHP"             , "phonon-related mobility reduction" )
`MPRnb( MUEPWPB   , MUEPWP    , ""                      , "phonon-related mobility reduction" )
`MPRnb( MUEPHSB   , MUEPHS    , "um^MUEPSP"             , "mobility change due to small size" )
`MPRnb( MUEPSPB   , MUEPSP    , ""                      , "mobility change due to small size" )
`MPRnb( MUEPHLB   , MUEPHL    , ""                      , "length dependence of phonon mobility for current" )
`MPRnb( MUEPLPB   , MUEPLP    , ""                      , "length dependence of phonon mobility for current" )
`MPRnb( MUESR0B   , MUESR0    , ""                      , "surface-roughness scattering for current" )
`MPRoo( MUESR1B   , MUESR1    , ""             , 0, inf , "surface-roughness scattering for current" )
`MPRnb( MUESRLB   , MUESRL    , ""                      , "length dependence of surface roughness mobility for current" )
`MPRnb( MUESLPB   , MUESLP    , ""                      , "length dependence of surface roughness mobility for current" )
`MPRnb( MUESRWB   , MUESRW    , "um^MUESWP"             , "surface roughness-related mobility change" )
`MPRnb( MUESWPB   , MUESWP    , ""                      , "surface roughness-related mobility change" )
`MPRnb( MUECB0B   , MUECB0    , ""                      , "Coulomb scattering for current" )
`MPRnb( MUECB1B   , MUECB1    , ""                      , "Coulomb scattering for back current" )
`MPRnb( MUECB0LPB , MUECB0LP  , ""                      , "length dependence of Coulomb scattering for back current" )
`MPRnb( MUECB1LPB , MUECB1LP  , ""                      , "length dependence of Coulomb scattering for back current" )
`MPRnb( MUECB0L2B  , MUECB0L2  , ""                     , "length dependence of Coulomb scattering for back current" )
`MPRnb( MUECB0L2PB , MUECB0L2P , ""                     , "length dependence of Coulomb scattering for back current" )
`MPRnb( MUECB1L2B  , MUECB1L2  , ""                     , "length dependence of Coulomb scattering for back current" )
`MPRnb( MUECB1L2PB , MUECB1L2P , ""                     , "length dependence of Coulomb scattering for back current" )
`MPRnb( PTHROU    , 0.0       , ""                      , "Modify subthreshold slope" )
`MPRnb( VFBSHIFT  , 0.0       , ""                      , "Scaling factor for Vfb shift" )
`MPRnb( MUEQB     , 1.0       , ""                      , "magnitude of QbL for front side mobility" )
`MPRnb( MUEQBL    , 0.0       , ""                      , "length dependence of MUEQB and MUEQBB" )
`MPRnb( MUEQBLP   , 1.0       , ""                      , "length dependence of MUEQB and MUEQBB" )
`MPRnb( MUEQBB    , MUEQB     , ""                      , "magnitude of QbL for back side mobility" )
`MPIsw( COCINV    , 0         , ""                      , "Inversion capacitance flag" )

`MPRnb( WEB       , 0.0       , "-"                     , "Modification of layout characterization factor" )
`MPRnb( WEC       , 0.0       , "-"                     , "Modification of layout characterization factor" )
`MPRnb( NSUBSWPE  , 0.0       , "1/cm^3"                , "Channel concentration change due to WPE" )
`MPRnb( NSUBPWPE  , 0.0       , "1/cm^3"                , "Pocket concentration change due to WPE" )

// alias parameters for older version.
`ALIAS( NSUBCW    , NSUBSW    )
`ALIAS( NSUBCWP   , NSUBSWP   )
`ALIAS( NSUBCMAX  , NSUBSMAX  )
 
// Output Physical Values in operating point analysis //
`OPP( idse      , "A"   , "Drain-Source current")
`OPP( isuba     , "A"   , "Substrate current")
`OPP( igidle    , "A"   , "Gate-Induced Drain Leakage current")
`OPP( igisle    , "A"   , "Gate-Induced Source Leakage current")
`OPP( igde      , "A"   , "Gate-Drain current")
`OPP( igse      , "A"   , "Gate-Source current")
`OPP( igbe      , "A"   , "Gate-Substrate current") 
`OPP( ggm       , "S"   , "Transconductance")
`OPP( ggds      , "S"   , "Channel conductance")
`OPP( ggmbs     , "S"   , "Body effect(Back gate) transconductance")
`OPP( ggmt      , "S"   , "Temperature transconductance")
`OPP( deltemp   , "K"   , "Temperature ")
`OPP( vone      , "V"   , "Threshold voltage")
`OPP( vdsate    , "V"   , "Saturation voltage")
`OPP( qge       , "C"   , "Gate charge")
`OPP( qde       , "C"   , "Drain charge")
`OPP( qse       , "C"   , "Bulk charge")
`OPP( cggbd     , "F"   , " g-g MOSFET capacitance")
`OPP( cgdbd     , "F"   , " g-d MOSFET capacitance")
`OPP( cgsbd     , "F"   , " g-s MOSFET capacitance")
`OPP( cbgbd     , "F"   , " b-g MOSFET capacitance")
`OPP( cbsbd     , "F"   , " b-s MOSFET capacitance")
`OPP( cbdbd     , "F"   , " b-d MOSFET capacitance")
`OPP( cdgbd     , "F"   , " d-g MOSFET capacitance")
`OPP( cddbd     , "F"   , " d-d MOSFET capacitance")
`OPP( cdsbd     , "F"   , " d-s MOSFET capacitance")
// End of Output Physical Values //

// Local Parameters for Model Control
   localparam real TN = 2 ; 

//--------------------------------------------------
//  Local Variables
//
// Constants ----------------------- //
   integer lp_s0_max, lp_sl_max ;
//
   real Vbs_max ;
   real Vbs_bnd ;
//
   real sti2_dlt ;
// Internal flags --------------------//
   integer flg_pprv ;
   integer flg_noqi ;
   integer flg_ign ;
   integer flg_dPpg ;
   integer flg_qme ;
   integer flg_nqs ;
// integer flg_SL_CP ;
   integer flg_depmode ;
// Important Variables in HiSIM -------//
// external bias //
   real Vbse, Vdse, Vgse ;
// confine bias //
   real Vbsc, Vdsc, Vgsc, Vbsc_dVbse ;
// internal bias //
   real Vbs, Vds, Vgs, Vgp, Vgs_fb ;
   real Vgs_shift ;
// Ps0 : surface potential at the source side //
   real Ps0 ;
// Psl : surface potential at the drain side //
   real Psl, Psl_lim ;
// Pds :=Psl - Ps0 //
   real Pds, Pds_ini, Pds_max ;
// iteration numbers of Ps0 and Psl equations. //
   integer lp_s0, lp_sl ;
// Xi0 :=beta * ( Ps0 - Vbs ) - 1. //
   real Xi0, Xi0p12, Xi0p32 ;
// Xil :=beta * ( Psl - Vbs ) - 1. //
   real Xilp12, Xilp32, Xil ;
// modified bias and potential for sym.//
   real Vbsz, Vdsz, Vgsz, Vzadd, Ps0z, Pzadd, Vgpz ;
// Chi :=beta * ( Ps{0/l} - Vbs ) //
   real Chi ;
// threshold voltage //
   real Vth, Vth0 ;
// variation of threshold voltage //
   real dVth, dVth0, dVthSC ;
   real dVthSCR ;
   real dVthW ;
// Alpha and related parameters //
   real Alpha, VgVt, Pslsat, VdsatS, Vdsat ;
//
// Q_B and capacitances //
   real Qb ;
// Q_I and capacitances //
   real Qi , Qidep ;
// Q_D and capacitances //
   real Qd ;
// channel current //
   real Ids, Ids0 , Ids01 , Ids02 ;
// STI //
   real dVthSCSTI, Vgssti, costi0, costi1, costi3, costi4, costi5, costi6, costi7 ;
   real Psasti, Asti, Psbsti, Psab, Psti, expsti, sq1sti, sq2sti, Qn0sti , Idssti ;
   real costi00 , nsti_p2 , costi0_p2 ;
// constants ------- //
   real beta, beta2, beta_inv ;
// device instances //
   real Leff, Weff, Ldby, q_Nsub, Nin, Pb2, Pb20, Pb20b, Pbsum ;
   real wdpl , Lgatesm , Wgatesm , sqrt_Pbsum ;
   real Pb2c, Eg, Vfb ;
   real Psi_a , Pb20a ;
// PART-1 ---------- //
   real cnst0SOI, cnst1SOI, cnst1bulk, fac1, fac1p2 ;
//
   real fb, exp_Chi, fb_dChi ; // fb_dChi used in COQOVSM==1 block (Qover)
//
   real Qn0, Qb0 ;
//
   real Idd  , Idd0 , Idd1 , Idd2 , Pbds ;
//
   real Eeff, Rns, Mu, Muun, Ey, Em, Vmaxe ;
   real Eeffb , Eyb ;
   real Mub , Muunb , Qibu ;
   real NINVDPdsz ;
   real Ids1, Ids2, Ids1_fac, Ids2_fac, IdsPT, IdsPTb , IdsPTtot ;
//
   real Ps0_min, Acn, Acd, Ac1, Ac2, Ac3, Ac4, Ac31, Ac41 ;
// PART-2 (Isub)---------- //
   real Isub ;
// (Isub)+//
   real Psislsat, Psisubsat ;
// IBPC //
   real dVbsIBPC, betaWL, dG3, dG4, dIdd, IdsIBPC ;
// PART-3 (overlap) //
   integer flg_overgiven ;
   real Lov, Qgos, Qgod, Cgdoe, Cgsoe, Cgbe, Qgob ;
   real exp_bPs0, exp_bVbs, cfs1, fi, fi_dChi, fs01 ;
   real fs01_dPs0, fs02, fs02_dPs0, Fs0, Fs0_dPs0, dPs0, dPlim ;
// fringing capacitance //
   real Cf, Qfd, Qfs ;
// Cqy //
   real Pslk, Qy ;
   real arg ;
// PART-5 (NQS) //
   real tau, taub ;
// PART-6 (noise) //
   real NFalpe, NFtrpe, Cite, Nflic ;
// thermal //
   real Eyd, Mu_Ave, Nthrml, Mud_hoso ;
// induced gate noise ( Part 0/3 ) //
   real kusai00, kusaidd, kusaiL, kusai00L, sqrtkusaiL, kusai_ig, gds0_ign ;
   real gds0_h2, GAMMA, crl_f ;
   real Nign0, MuModA, MuModB, correct_w1 ;
// Igate , Gidl , Gisl //
   real Egp12, Egp32, E1, Egidl, Egisl, Igs, Igd ;
   real Igb1, Igb2, Igb, Igate, GLPART1, Igidl, Igisl ;
// Accumulation zone //
   real Psa ;
// CLM //
   real Psdl, Ec, Lred, Wd, Aclm ;
// Pocket Implant //
   real Vthp, dVthLP ;
// Poly-Depletion Effect //
   real dPpg ;
// Quantum Effect //
   real Tfoxe, dTfox, C_fox, C_fox_inv, Tfox0, C_fox0, C_fox0_inv ;
   real Vthq ;
// FMD* parameters for dPpg model , referring to HiSIM2. //
   real FMDVDS ;
// Phonon scattering //
   real Lgate ;
// temporary vars.-- //
   real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T12, TX, TY ;
   integer flg_zone ;
   real C_box_FD_inv, C_box, C_box_inv, Q_FD_SOI ;
   real e0 ;
   real Vbi_SOI, phi_s0_SOI_ini, phi_b0_SOI_ini, phi_s0_bulk_ini, phi_sL_SOI_ini ;
   real phi_bL_SOI_ini, phi_sL_bulk_ini, phi_s0_SOI, phi_b0_SOI, phi_s0_bulk ;
   real phi_sL_SOI, phi_bL_SOI, phi_sL_bulk, Q_n0, Q_s0_bulk ;
   real Q_nL, Q_sL_bulk ;
// Idd parameters. //
   real Ps0s, PsLs, Ps0_iniA, Ps0_iniB, Ps0_ini ;
   real Pb0s , PbLs;
   real psb_iniA, psb_iniB, Pb2_bulk, shift ;
   real FD_start, FD_end, Q_s0_bulk_0, phi_s0_bulk_0 ;
   real phi_b_dep ;
   real phi_b_dep_dPsb, phi_b_dep0, phi_b_dep0_dPsb, Qsub ;
// Qh0* and QhL* are History Effect parameters. //
   real Qhs, Ids_isub, Ps0_isub ;
// Qhs history effect by higashig //
   real Qhs_prev, tauh, Rsb ;
// 
   real Q_s0_bulk_dPsb ;
   real Q_sL_bulk_dPsb ;
   real WdSOI ;
   real PF1, PF11, PF12, PF13, PF2, PF21, PF22, PF23, PF3, PF32, PF33 ;
   real PDJ, PDJI, PJI11, PJI12, PJI13, PJI21, PJI22, PJI23, PJI31, PJI32 ;
   real PJI33, dPss, dPbsP, dPsb ;
// 
   real RRR_P0, RRR_alpha_SOI, RRR_CC ;
// 
   real TTEMP, LG, WG, WLG, mtmp ;
   integer flg_conv ;
   real ptovr, cnstC_foxi ;
// constants //
   real Vbsz2, Qiu, Qdepu, Qdrat ;
   real Lch, T11 ;
   real Vgpsub, vfbsub1 ;
// Disable Vbs dependence of SCx SCPx models //
   real Ievb, phib ;
   real Pds_qwe, Ievb0, Mfactor ;
// Vdseff //
   real Vdseff, Vdsorg ;
// G/S and G/D Overlap Charges: Qovs/Qovd //
   real Qovd, Qovs ;
   integer lcover, flg_ovloops, flg_ovloopd, flg_overs, flg_overd ;
   real VgpLD, QbdLD, QbsLD, QbuLD, QsuLD, QiuLD, Ps0LD ;
   integer flg_ovzone ;
// Mode flag (=0 | 1 ) //
   real ModeNML, ModeRVS ;
// Overlap Charge: Qover //
   real Vgbgmt, Vxbgmt, Vxbgmtcl ;
   real Pb2over ;
// Qover Iterative and Analytical Model // 
   integer lp_ld ;
   real Vgb_fb_LD, VgpLD_shift, Ta, Tb, Tc, Tp, Td, Tq, Tu, Tv;
   real cnst1over, gammaChi, Chi_A, Chi_B, Chi_1, psi ;
   real Cox0, Cox0_inv, cnst0over ; // only used in (surface-potential based Qover).
// for consts //
   real c0bulk, cnst0bulk ;
   real Vbsbiz ;
// Qb for FB devices //
   real Qs_dep, Qb_dep , Qfd_box , Qfs_box ;
// UC_*** Vars. for Device and Model Parameters
   real UC_TNOM     , UC_CLM2 ;
   real UC_TEMP     , UC_MUECB0  , UC_MUECB1 , UC_MUECB0B  , UC_MUECB1B ;
   real UC_NSTI     , UC_WSTI     ;
   real C_MUEEY0    , C_MUEEY0B ;
// Vars. for temp.c 
   real Wgate  , Nsub   , Lod_half , Lod_half_ref , Nsubpp , Nsubps , N_subbl;
// Vars. for eval.c 
   real temp_Given , betatnom , egtnom , weff_nf , rth   ;
   real cth    , CGS_mphn0  , muesr  , UC_NSUBS;
   real qnsub_esi , qnsub_esi2 , qnbulk_esi , ptl0   , pt40  ;
   real gdl0   , ptovr0 , cnstpgd , vmax0 ;
   real DDLTe   , dVthsm , clmmod , grg    , zvgs   , xvbs  ;
   real xgate  , xsub1  , xsub2  , cqyb0  , UC_SVGS;
   real qbe    , cgsb   , isube  , noiigate;
   real noicross ; 
// Vars for capacitance fitting
   real dW , dWCV , dWSTI , weff_cv , weffcv_nf ;
// Local Vars. for eval.c 
   integer i      , flg_fbcase ;
   real Cthe  ;
   real CGBO_GIVEN , CGDO_GIVEN , CGSO_GIVEN ;
   real nume   , pfi_case , phi_b0_SOIP;
   real Q_s0_dep , Q_s0_dep_dPss , Q_s0_dep_dPbsP , Q_n0_dPss , Q_n0_dPbsP;
   real Q_b0   , Q_b0_dPbs , Q_b0_dPbsP , Q_b0_dep , Q_b0_dep_dPbs , Q_b0_dep_dPbsP;
   real phi_b0_SOIP_ini , C_soi, C_soi_inv ;
   real T4_dPss , T4_dPbsP , T4_dPbs ;
   real Vgsi   ;
   real Isubs  , Rpower  ;
   real Qb_nqs , Iqi_nqs , Iqb_nqs , Qi_nqs , Qd_nqs , Qs_nqs , Qg_nqs;
   real Qi_qs  , Qb_qs   , Gth    ;
// Local Definition Vars. by User 
   real Iqh_nqs , vfbsub0 , Nsubb0  ,  Qg     , Qhs_hist;
   real noiflick , noithrml , Vdsei   , Vgsei   , Vbsei   , ggdss ;
   real cgbbd  , cdbbd  , csgbd  , csdbd  , cssbd  , csbbd  , cbbbd  , whi_noise ;
// Others
   integer flg_brk10 ;
   integer mode ;

// for flat_phibP
   real Q_sL_dep, Q_sL_dep_dPss, Q_sL_dep_dPbsP, Q_nL_dPss, Q_nL_dPbsP ;
   real phi_bL_SOIP_ini, phi_bL_SOI_dPsb , phi_b0_SOI_dPsb , phi_bL_SOIP ;
   real Q_bL_dep, Q_bL_dep_dPbs, Q_bL_dep_dPbsP ;
   real Q_bL, Q_bL_dPbs, Q_bL_dPbsP ;

// 
`ifdef DISABLE_COPPRV
`else
   integer flg_conv_0, flg_conv_L;
`endif

   real Ninv, Ndep , Vbs_prime; 
   real muesrb, CGS_mphbn0;
   real Pb0Ls , Ps0Lb , Pdsz ;
   real T1_gamma, T2_gamma, T1_alpha, T1_delta, T1_beta, T1_dPsb, T2_dPsb ;
   real scale_fac , PSCONV_3D ;
   real sid , ci, sigrat ; // Noise

   real MKS_VMAX , MKS_NSUBP , MKS_VTMP  , MKS_NSUBSMAX , MKS_NFALP , MKS_NFTRP ;
   real MKS_CIT  , MKS_NSUBS , MKS_NSUBB , MKS_RTH0 , MKS_CTH0 , MKS_NOVER ;
   real MKS_NSUBBMIN, UC_WFC , MKS_GIDL2, UC_GIDL1;
   real UC_GIDLBPL1;

// WPE
   real MKS_NSUBSWPE , MKS_NSUBPWPE ;

//*-----------------*/
real TMF0, TMF1 , TMF2 , TMF3 , TMF4   ; 
real x2 , xmax2 , xp , xmp , dnm , m0, mm ;
//===========================================================* 
//* pow
//*=================*/
`define Fn_Pow( x , y )  pow( x , y )
//===========================================================* 
//* Exp() for PGD.
//* - ExpLim(-3)=0
//*=================*/
`define Fn_ExpLim( y , x , dx ) begin \
    if((x) < -3.0 ) begin \
      dx = 0.0 ; \
      y = 0.0 ; \
    end else if((x) < 0.0 ) begin \
      dx =  1.0 + (x) * ( 2 * (1.0/3.0) + (x) * 3 * (1.0/27.0) )  ; \
      y = 1.0 + (x) * ( 1.0 + (x) * ( (1.0/3.0) + (x) * (1.0/27.0) ) ) ; \
    end else begin \
      dx =  1.0 + (x) * ( 2 * (1.0/3.0) + (x) * ( 3 * 0.0402052934513951 \
                + (x) * 4 * 0.148148111111111 ) ) ; \
      y = 1.0 + (x) * ( 1.0 + (x) * ( (1.0/3.0) + (x) * ( 0.0402052934513951 \
              + (x) * 0.148148111111111 ) ) ) ; \
    end \
end
//===========================================================* 
//* Macro Functions for ceiling/flooring/symmetrization.
//*=================*/

//---------------------------------------------------* 
//* smoothUpper: ceiling.
//*      y = xmax - 0.5 ( arg + sqrt( arg^2 + 4 xmax delta ) )
//*    arg = xmax - x - delta
//*-----------------*/
`define Fn_SU( y , x , xmax , delta , dx ) begin \
    TMF1 = ( xmax ) - ( x ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmax ) * ( delta) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    dx = 0.5 * ( 1.0 + TMF1 / TMF2 ) ; \
    y = ( xmax ) - 0.5 * ( TMF1 + TMF2 ) ; \
  end
`define Fn_SUtemp( y , x , xmax , delta ) begin \
    TMF1 = ( xmax ) - ( x ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmax ) * ( delta) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    y = ( xmax ) - 0.5 * ( TMF1 + TMF2 ) ; \
  end
`define Fn_SU2( y , x , xmax , delta , dy_dx , dy_dxmax ) begin \
    TMF1 = ( xmax ) - ( x ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmax ) * ( delta) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    dy_dx = 0.5 * ( 1.0 + TMF1 / TMF2 ) ; \
    dy_dxmax = 0.5 * ( 1.0 - ( TMF1 + 2.0 * delta ) / TMF2 ) ; \
    y = ( xmax ) - 0.5 * ( TMF1 + TMF2 ) ; \
  end

//---------------------------------------------------* 
//* smoothLower: flooring.
//*      y = xmin + 0.5 ( arg + sqrt( arg^2 + 4 xmin delta ) )
//*    arg = x - xmin - delta
//*-----------------*/
`define Fn_SL( y , x , xmin , delta , dx ) begin \
    TMF1 = ( x ) - ( xmin ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmin ) * ( delta ) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    dx = 0.5 * ( 1.0 + TMF1 / TMF2 ) ; \
    y = ( xmin ) + 0.5 * ( TMF1 + TMF2 ) ; \
  end
`define Fn_SLtemp( y , x , xmin , delta ) begin \
    TMF1 = ( x ) - ( xmin ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmin ) * ( delta ) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    y = ( xmin ) + 0.5 * ( TMF1 + TMF2 ) ; \
  end
`define Fn_SL2( y , x , xmin , delta , dy_dx, dy_dxmin ) begin \
    TMF1 = ( x ) - ( xmin ) - ( delta ) ; \
    TMF2 = 4.0 * ( xmin ) * ( delta ) ; \
    TMF2 = TMF2 > 0.0 ?  TMF2 : - ( TMF2 ) ; \
    TMF2 = sqrt ( TMF1 * TMF1 + TMF2 ) ; \
    dy_dx = 0.5 * ( 1.0 + TMF1 / TMF2 ) ; \
    dy_dxmin = 0.5 * ( 1.0 - ( TMF1 - 2.0 * delta ) / TMF2 ) ; \
    y = ( xmin ) + 0.5 * ( TMF1 + TMF2 ) ; \
  end

//---------------------------------------------------* 
//* smoothZero: flooring to zero.
//*      y = 0.5 ( x + sqrt( x^2 + 4 delta^2 ) )
//*-----------------*/
`define Fn_SZ( y , x , delta , dx ) begin \
    TMF2 = sqrt ( ( x ) *  ( x ) + 4.0 * ( delta ) * ( delta) ) ; \
    dx = 0.5 * ( 1.0 + ( x ) / TMF2 ) ; \
    y = 0.5 * ( ( x ) + TMF2 ) + 1e-10 * delta ; \
    if( y < 0.0 ) begin y=0.0; dx=0.0; end \
  end
`define Fn_SZtemp( y , x , delta ) begin \
    TMF2 = sqrt ( ( x ) *  ( x ) + 4.0 * ( delta ) * ( delta) ) ; \
    y = 0.5 * ( ( x ) + TMF2 ) + 1e-10 * delta ; \
    if( y < 0.0 ) begin y=0.0; end \
  end

//---------------------------------------------------* 
//* CeilingPow: ceiling for positive x, flooring for negative x.
//*      y = x * xmax / ( x^{2m} + xmax^{2m} )^{1/(2m)}
//* note: 
//*   - xmax has to be positive.
//*   - -xmax < y < xmax.
//*   - dy/dx|_beginx=0end = 1.
//*-----------------*/
`define Fn_CP( y , x , xmax , pw , dx ) begin \
  x2 = (x) * (x) ; \
  xmax2 = (xmax) * (xmax) ; \
  xp = 1.0  ;\
  xmp = 1.0 ; \
  m0 = 0 ;\
  mm =0 ; \
  arg = 0.0 ;\
  dnm =0.0 ; \
  for ( m0 = 0 ; m0 < pw ; m0 = m0 + 1 ) begin xp = xp * x2 ; xmp = xmp * xmax2 ; end \
  arg = xp + xmp ; \
  dnm = arg ; \
  if( pw == 1 || pw == 2 || pw == 4 || pw == 8 ) begin \
    if ( pw == 1 ) begin mm = 1 ; \
    end else if ( pw == 2 ) begin mm = 2 ; \
    end else if ( pw == 4 ) begin mm = 3 ; \
    end else if ( pw == 8 ) begin mm = 4 ; end \
    for ( m0 = 0 ; m0 < mm ; m0 = m0 + 1 ) begin dnm = sqrt( dnm ) ; end \
  end else begin dnm = `Fn_Pow( dnm , 1.0 / ( 2.0 * pw ) ) ; end \
  dnm = 1.0 / (dnm+`Small); \
  y = (x) * (xmax) * dnm ; \
  dx = (xmax) * xmp * dnm / (arg+`Small) ; \
end

`define Fn_SU_CP( y , x , xmax , delta , pw , dx ) begin \
 if(x > xmax - delta && delta >= 0.0) begin \
   TMF1 = x - xmax + delta ; \
   `Fn_CP( TMF0 , TMF1 , delta , pw , dx )  \
   y = xmax - delta + TMF0 ; \
   dx = dx ; \
 end else begin \
   y = x ; \
   dx = 1.0 ; \
 end \
end

`define Fn_SL_CP( y , x , xmin , delta , pw , dx ) begin \
 if(x < xmin + delta && delta >= 0.0) begin \
   TMF1 = xmin + delta - x ; \
   `Fn_CP( TMF0 , TMF1 , delta , pw , dx )  \
   y = xmin + delta - TMF0 ; \
   dx = dx ; \
 end else begin \
   y = x ; \
   dx = 1.0 ; \
 end \
end


//---------------------------------------------------* 
//* "flatUpper" using a polynomial
//*-----------------*/
//`Fn_DclPoly4( y , TMF1 , dx ) ; 
`define Fn_SUPoly4( y , x , xmax , dx ) begin \
  TMF1 = (x) / xmax ; \
  TMF2 = TMF1 * TMF1 ; \
  TMF3 = TMF2 * TMF1 ; \
  TMF4 = TMF2 * TMF2 ; \
  y = 1.0 / ( 1.0 + (TMF1) + TMF2 + TMF3 + TMF4 ) ; \
  dx = - ( 1.0 + 2.0 * (TMF1) + 3.0 * TMF2 + 4.0 * TMF3 )  * y * y  ; \
  y = xmax * ( 1.0 - y ) ; \
  dx = - dx ; \
end
//---------------------------------------------------* 
//* SymAdd: evaluate additional term for symmetry.
//*-----------------*/
`define Fn_SymAdd( y , x , add0 , dx ) begin \
  TMF1 = 2.0 * ( x ) / ( add0 ) ; \
  TMF2 = 1.0 + TMF1 * ( (1.0/2) + TMF1 * ( (1.0/6) \
             + TMF1 * ( (1.0/24) + TMF1 * ( (1.0/120) \
             + TMF1 * ( (1.0/720) + TMF1 * (1.0/5040) ) ) ) ) ) ; \
  TMF3 = (1.0/2) + TMF1 * ( (1.0/3) \
             + TMF1 * ( (1.0/8) + TMF1 * ( (1.0/30) \
             + TMF1 * ( (1.0/144) + TMF1 * (1.0/840) ) ) ) ) ; \
  y = add0 / TMF2 ; \
  dx = - 2.0 * TMF3 / ( TMF2 * TMF2 ) ; \
end

`define Fn_Sqr(x)   ( (x)*(x) ) // x^2 */
`define Fn_Max(x,y) ( (x) >= (y) ? (x) : (y) ) // max[x,y] */
`define Fn_Min(x,y) ( (x) <= (y) ? (x) : (y) ) // min[x,y] */
`define Fn_Sgn(x)   ( (x) >= 0  ?  (1) : (-1) )    // sign[x] */

`define EXP_LIMIT(y, x, dx) \
begin \
    if(x >= `EXP_THRES) begin \
        y  = `MAX_EXP * (1.0 + x - `EXP_THRES) ; \
        dx = `MAX_EXP ; \
    end else begin \
        y  = exp(x) ; \
        dx = y ; \
    end \
end
// End of eval.c for definition

// Begin: temp.c for definition
`define BINNING(UC_PARAM, PARAM, LPARAM, WPARAM, PPARAM) UC_PARAM = PARAM \
  + LPARAM / Lbin + WPARAM / Wbin \
  + PPARAM / LWbin ;
`define RANGECHECK(param, min, max, pname) begin \
  if((param) <(min) ||(param) >(max) ) begin \
    $write("warning(HiSIM_SOTB): (%M) The model/instance parameter %s (= %g) must be in the range [%g , %g].\n", \
           pname, (param), (min), (max) ) ; \
  end \
end
`define MINCHECK(param, min, pname) \
  if((param) <= (min) ) begin \
    $write("warning(HiSIM_SOTB): (%M) The model/instance parameter %s (= %g) must be greater than %g.\n", \
           pname, (param), (min) ) ;                     \
  end
`define MINCHECKF(param, min, pname) \
  if((param) <= (min) ) begin \
    $write(" *** Fatal(HiSIM_SOTB): (%M) The model/instance parameter %s (= %g) must be greater than %g.\n", \
           pname, (param), (min) ) ;                     \
    FATAL_flag = 1; \
  end

`define PMINCHECK(param, min, mesg) \
  if( (param) < (min) ) begin \
    $write(" *** Fatal(HiSIM_SOTB): (%M) %s\n",mesg ); \
    FATAL_flag = 1; \
  end

`define  Nsubmin     (1e15 / `C_cm2m_p3) 
`define  Nsubmin_dlt (0.01 / `C_cm2m_p3)

// End of temp.c for definition

  //================ Start of executable code.=================//

   analog function real expm1 ;
      input x ; real x ;
      expm1=exp(x)-1.0 ;
   endfunction

   analog function real log1p ;
      input x ; real x ;
      log1p=ln (1.0+x) ;
   endfunction

   analog function real FPOW ;
      input x , y ; real x , y ;
      FPOW = (x==0.0 && y==0.0) ? 1.0 : pow(x,y) ;
   endfunction

//start_of_routine
   analog begin
     
     // Initial Settings
     
     i          = 0 ;
     flg_brk10  = 0 ;
     gds0_ign   = 1e-12 ;
     lp_s0_max  = 200 ;
     lp_sl_max  = 200 ;
     sti2_dlt   = 2.0e-3 ;
     flg_nqs    = CONQS ;
     Vbsc_dVbse = 1.0 ;
     flg_dPpg   = 1 ;

     // for hidden states
     phi_s0_SOI  = 0.0 ;
     phi_b0_SOI  = 0.0 ;
     phi_s0_bulk = 0.0 ;
     phi_sL_SOI  = 0.0 ;
     phi_bL_SOI  = 0.0 ;
     phi_sL_bulk = 0.0 ;
     Q_s0_bulk   = 0.0 ;
     Q_sL_bulk   = 0.0 ;
     Q_n0        = 0.0 ;
     Q_nL        = 0.0 ;
     fs01       = 0.0 ; 
     fs02       = 0.0 ;
     Q_b0_dep   = 0.0 ;
     Q_b0       = 0.0 ;
     Q_bL_dep   = 0.0 ;
     Q_bL       = 0.0 ;
     Q_s0_dep   = 0.0 ;
     Q_sL_dep   = 0.0 ;
     Qi_qs      = 0.0 ;
     Qb_qs      = 0.0 ;
     Pb0s       = 0.0 ;
     shift      = 0.0 ;
     FD_end     = 0.0 ;
     Q_s0_bulk_0 = 0.0 ;
     phi_s0_bulk_0 = 0.0 ;
     phi_b_dep0 = 0.0 ;
     Qsub       = 0.0 ;
     Qhs        = 0.0 ;
     WdSOI      = 0.0 ;
     Qiu        = 0.0 ;
     Qdrat      = 0.5 ;
     Qs_dep     = 0.0 ;
     Qb_dep     = 0.0 ;
     Ievb       = 0.0 ;
     Iqh_nqs    = 0.0 ;
     QbdLD      = 0.0 ;
     QbsLD      = 0.0 ;
     Qovd       = 0.0 ;
     Qovs       = 0.0 ;
     Vgbgmt     = 0.0 ;

     flg_noqi   = 0 ;
     flg_ign    = 0 ;
     flg_zone   = 0 ;
     qse        = 0.0 ;
     Pds_ini    = 0.0 ;
     Psl_lim    = 0.0 ;
     Ps0z       = 1.0 ;
     Alpha      = 0.0 ;
     Qi         = 0.0 ;
     Qd         = 0.0 ;
     Ids        = 0.0 ;
     Idd        = 0.0 ;
     Mu         = 0.0 ;
     Muun       = 0.0 ;
     Ey         = 0.0 ;
     Isub       = 0.0 ;
     betaWL     = 1.0 ;
     IdsIBPC    = 0.0 ;
     Qgos       = 0.0 ;
     Qgod       = 0.0 ;
     tau        = 0.0 ;
     taub       = 0.0 ;
     fb         = 0.0 ;
     Psdl       = 0.0 ;
     Vdsat      = 0.0 ;
     Mud_hoso   = 0.0 ;
     kusai00    = 0.0 ;
     kusaiL     = 0.0 ;
     kusai00L   = 0.0 ;
     sqrtkusaiL = 0.0 ;
     kusai_ig   = 0.0 ;
     crl_f      = 0.0 ;
     Vgs_shift  = 0.0 ;
     Chi        = 0.0 ;

                
     begin : initializeModel
     
       CGBO_GIVEN  = $param_given(CGBO) ;
       CGDO_GIVEN  = $param_given(CGDO) ;
       CGSO_GIVEN  = $param_given(CGSO) ;
       temp_Given  = $param_given(TEMP) ; 
       

       Mfactor = `MFACTOR_USE ;
       //-----------------------------------------------------------*
       //Range check of model parameters
       //-----------------//
       begin : PreParamCheck       

         integer FATAL_flag ;
         FATAL_flag = 0 ;
         if(PTL!= 0) `MINCHECKF(PTMUEPH , 0.0, "PTMUEPH")
         if(COIIGS)  `MINCHECKF(GLEAK5  , 0.0, "GLEAK5")
         if(COGIDL)  `MINCHECKF(TFOXGIDL, 0.0, "TFOXGIDL")
         if(COGIDL)  `MINCHECKF(GIDLBPL1, 0.0, "GIDLBPL1")
         if(NSUBPSTI1 == 0 && NSUBPSTI3 < 0) begin
            $write(" *** Fatal(HiSIM_SOTB): (NSUBPSTI1 == 0 && NSUBPSTI3 < 0) is not allowed.\n");
            FATAL_flag = 1;
         end
         if(MUESTI1 == 0 && MUESTI3 < 0) begin
            $write(" *** Fatal(HiSIM_SOTB): (MUESTI1 == 0 && MUESTI3 < 0) is not allowed.\n");
            FATAL_flag = 1;
         end
         if(FATAL_flag) $finish(0);

         // Change the CLM2 depends on NSUBS
         UC_CLM2 = ($param_given(CLM2)) ? CLM2 : 5.0e9/(TSOI * NSUBS) ;
         `Fn_SL_CP(UC_CLM2, UC_CLM2, 2.0, 0.1, 2 , T0)

       end // PreparamCheck

        //-----------------------------------------------------------*
        //Change units into MKS.
        //----------------//
        MKS_VMAX     = VMAX     * `C_cm2m;
        MKS_NSUBP    = NSUBP    / `C_cm2m_p3;
        MKS_VTMP     = VTMP     * `C_cm2m;
        MKS_NSUBSMAX = NSUBSMAX / `C_cm2m_p3;
        MKS_NFALP    = NFALP    * `C_cm2m;
        MKS_NFTRP    = NFTRP    / `C_cm2m_p2;
        MKS_CIT      = CIT      / `C_cm2m_p2;
        MKS_NSUBS    = NSUBS    / `C_cm2m_p3;
        MKS_NSUBB    = NSUBB    / `C_cm2m_p3;
        MKS_RTH0     = RTH0     * `C_cm2m;
        MKS_CTH0     = CTH0     / `C_cm2m;
        MKS_NOVER    = NOVER    / `C_cm2m_p3;
        MKS_NSUBBMIN = NSUBBMIN / `C_cm2m_p3;
        MKS_GIDL2    = GIDL2    / `C_cm2m;
	MKS_NSUBSWPE = NSUBSWPE / `C_cm2m_p3 ;
	MKS_NSUBPWPE = NSUBPWPE / `C_cm2m_p3 ;
        UC_WFC       = WFC      * `C_m2cm_p2 ;
        UC_NSTI      = NSTI     / `C_cm2m_p3;
        UC_GIDL1     = GIDL1    / `C_m2cm_p1o2 ;
        UC_TNOM      = TNOM + 273.15 ;      // [C] -> [K] //
        UC_TEMP      = TEMP  + 273.15 ;      // [C] -> [K] //
                
     end // initializeModel
              
     begin : initializeInstance
                
       dW = XWD  ;
       dWCV = XWDC ;
       Lgate = L ;
       Wgate = W / NF ;

       LG = Lgate * `C_m2um;
       WG = Wgate * `C_m2um;
       WLG = WG * LG ;

       // WLg dependence for short channel devices //
       T1 = WL1 / pow( WLG , WL1P ) ;
       Lgatesm = Lgate + T1 ;
       Wgatesm = Wgate + T1 ;
       dVthsm  = WL2 / pow( WLG , WL2P ) ;

       // Lg & Wg dependence of nsti & wsti //
       T1 = 1.0e0 + NSTIL / pow( Lgatesm * `C_m2um , NSTILP ) ;
       T2 = 1.0e0 + NSTIW / pow( Wgatesm * `C_m2um , NSTIWP ) ;
       UC_NSTI = UC_NSTI * T1 * T2 ;
       T1 = 1.0e0 + WSTIL / pow( Lgatesm * `C_m2um , WSTILP ) ;
       T2 = 1.0e0 + WSTIW / pow( Wgatesm * `C_m2um , WSTIWP ) ;
       UC_WSTI = WSTI * T1 * T2 ;
       dWSTI = 2.0 * UC_WSTI * RATWSTI ;

       Weff = Wgate - 2.0e0 * dW - dWSTI ;
       weff_cv = Wgate - 2.0e0 * dWCV  - dWSTI ;

       weff_nf = Weff * NF ;
       weffcv_nf = weff_cv * NF ;

       rth = MKS_RTH0 / (Mfactor * weff_nf) ;
       cth = MKS_CTH0 * (Mfactor * weffcv_nf) ;

       // WPE // derived from HiSIM2 3.0.0 on 26/May/2017.
       // EF_NSUBC --> MKS_NSUBS:
       T0 = MKS_NSUBSWPE * ( SCA + WEB * SCB + WEC * SCC ) ;
       MKS_NSUBS  = MKS_NSUBS + T0 ;
       `Fn_SLtemp( MKS_NSUBS , MKS_NSUBS , `Nsubmin, `Nsubmin_dlt) 
       // EF_NSUBP --> MKS_NSUBP:
       T0 = MKS_NSUBPWPE * ( SCA + WEB * SCB + WEC * SCC ) ;
       MKS_NSUBP  = MKS_NSUBP + T0 ;
       `Fn_SLtemp( MKS_NSUBP , MKS_NSUBP , `Nsubmin, `Nsubmin_dlt) 
       // WPE end //

       // Coulomb Scattering // 2015.11.19
       UC_MUECB0 = MUECB0 * pow( LG, MUECB0LP ) 
                 * ( 1.0 + MUECB0L2  / pow( LG, MUECB0L2P ) );
       UC_MUECB1 = MUECB1 * pow( LG, MUECB1LP )
                 * ( 1.0 + MUECB1L2  / pow( LG, MUECB1L2P ) );
       UC_MUECB0B = MUECB0B * pow( LG, MUECB0LPB )
                 * ( 1.0 + MUECB0L2B / pow( LG, MUECB0L2PB ) );
       UC_MUECB1B = MUECB1B * pow( LG, MUECB1LPB )
                 * ( 1.0 + MUECB1L2B / pow( LG, MUECB1L2PB ) );
                 
       // Surface Roughness Scattering //
       muesr = MUESR0 * (1.0e0 + (MUESRL / pow(LG, MUESLP)))
             * (1.0e0 + (MUESRW / pow(WG, MUESWP))) ;
       muesrb = MUESR0B * (1.0e0 + (MUESRLB / pow(LG, MUESLPB)))
             * (1.0e0 + (MUESRWB / pow(WG, MUESWPB))) ;
             
       T1 = `N_sub_bulk * (1 + NSUBBL / pow(LG, NSUBBLP)) ;
       `Fn_SLtemp(N_subbl, T1, MKS_NSUBBMIN, `N_sub_bulk * 0.001)

       if(CONEWMUB) begin 
         T1 = N_subbl * (1 + NSUBBW / pow(WG, NSUBBWP)) ;
         `Fn_SLtemp(N_subbl, T1, MKS_NSUBBMIN, `N_sub_bulk * 0.001)
       end

       // Surface impurity profile //
       Nsubpp = MKS_NSUBP * (1.0e0 + (NSUBP0 / pow(WG, NSUBWP))) ;
       Nsubps = Nsubpp ;        // LOD-related //
                
       // Half length of diffusion //
       T1 = 1.0 / (SAREF + 0.5 * L)
          + 1.0 / (SBREF + 0.5 * L) ;
       Lod_half_ref = 2.0 / T1 ;
                    
       if(SA > 0.0 && SB > 0.0
         &&(NF == 1.0 ||(NF > 1.0 && SD > 0.0))) begin
         T1 = 0.0 ;
         for (i = 0 ; i < NF ; i= i + 1) begin
           T1 = T1 + 1.0 / (SA + 0.5 * L + i * (SD + L))
              + 1.0 / (SB + 0.5 * L + i * (SD + L)) ;
         end
         Lod_half = 2.0 * NF / T1 ;
       end else begin
         Lod_half = 0.0 ;
       end
       if(Lod_half > 0.0) begin
         T1 = 1.0e0 / (1.0e0 + NSUBPSTI2) ;
         T2 = FPOW(NSUBPSTI1 / Lod_half, NSUBPSTI3) ;
         T3 = FPOW(NSUBPSTI1 / Lod_half_ref, NSUBPSTI3) ;
         Nsubps = Nsubpp * (1.0e0 + T1 * T2) / (1.0e0 + T1 * T3) ;
         T1 = 1.0e0 / (1.0e0 + NSUBSSTI2) ;
         T2 = pow (NSUBSSTI1 / Lod_half    , NSUBSSTI3) ;
         T3 = pow (NSUBSSTI1 / Lod_half_ref, NSUBSSTI3) ;
         MKS_NSUBS = MKS_NSUBS * (1.0e0 + T1 * T2) / (1.0e0 + T1 * T3) ;
       end else begin
         Nsubps = Nsubpp ;
       end

       T2 = 1.0e0 + (NSUBSW / pow(WG, NSUBSWP)) ;
       T3 = MKS_NSUBSMAX / MKS_NSUBS ;
       `Fn_SUtemp( T1, T2, T3, 0.01 ) 
       UC_NSUBS = MKS_NSUBS * T1 ;
       if(Lgate > LP) begin
         Nsub = (UC_NSUBS * (Lgate - LP) + Nsubps * LP) / Lgate ;
       end else begin
         Nsub = Nsubps + (Nsubps - UC_NSUBS) * (LP - Lgate) / LP ;
       end

       q_Nsub   = `C_QE * Nsub ;
       qnsub_esi = q_Nsub * `C_ESI ;
       qnsub_esi2 = 2.0 * qnsub_esi ;
       qnbulk_esi = `C_QE * N_subbl * `C_ESI ; 
                  
       // Parasitic component of the channel current //
       ptl0 = PTL * pow(LG, -PTLP) ;
       pt40 = PT4 * pow(LG, -PT4P) ;
       gdl0 = GDL * pow(LG + GDLD, -GDLP) ;
            
       // Pocket Overlap(temperature-independent part) //
       if(Lgate <= 2.0e0 * LP) begin
         Nsubb0 = 2.0e0 * Nsubps - (Nsubps - UC_NSUBS) * Lgate / LP - UC_NSUBS ;
         ptovr0 = ln (Nsubb0 / UC_NSUBS) ;
         // ptovr0 will be divided by beta later. //
       end else begin
         ptovr0 = 0.0e0 ;
       end
              
       // 2 phi_B //
       // @300K, with pocket //
       Pb20   = 2.0e0 / `C_b300 * ln (Nsub / `C_Nin0) ;
       // @300K, w/o pocket //
       Pb2c   = 2.0e0 / `C_b300 * ln (UC_NSUBS / `C_Nin0) ;

       // PGD //     
       cnstpgd = pow(1e0 + 1e0 / LG, PGD4) * PGD1 ;
          
       // Vdseff //
       T1 = DDLTSLP * LG ;                                        
       DDLTe = T1 * DDLTMAX / (T1 + DDLTMAX) + DDLTICT + `Small ;
            
       // CLM5 & CLM6 //
       clmmod = 1e0 + pow(LG, CLM5) * CLM6 ;
              
       // Gate resistance //
       if(CORG == 1) begin
         T1 = XGW + Weff / (3.0e0 * NGCON) ;
         grg = RSHG * T1 / (NGCON * (Lgate - XGL) * NF) ;
         if(grg > 1.0e-3) begin
           grg = Mfactor / grg ;
         end else begin
           grg = Mfactor * 1.0e3 ;
           $write("warning(HiSIM_SOTB): The gate conductance reset to 1.0e3 mho.\n") ;
         end
       end else begin
         grg = Mfactor * 1.0e3 ;
       end
       // Isub //
       zvgs = 1.0 + SVGSW / pow(WG, SVGSWP) ;
       xvbs = SVBS  * (1.0 + SVBSL / pow(LG, SVBSLP)) ;
       xgate = LG / (LG + SLG) ;
       xsub1 = SUB1  * (1.0  + SUB1L / pow(LG, SUB1LP)) ;
       xsub2 = SUB2 * (1.0 + SUB2L / LG) ;
             
       // Additional term of lateral-field-induced capacitance //
       cqyb0 = 1.0e4 * weffcv_nf * XQY1 / pow(LG, XQY2) ;
             
       // Lg dependence for Vfbsub //
       vfbsub0 = VFBSUB * (1.0e0 + (VFBSUBL / pow(LG, VFBSUBLP))) ;
              
       // Lg dependence for SVGS //
       UC_SVGS = SVGS * (1.0e0 + (SVGSL / pow(LG, SVGSLP))) ;

       // Depletion Width //
       T1 = 2.0e0 * `C_ESI / `C_QE ;
       wdpl = sqrt ( T1 / Nsub ) ;

     end // initializeInstance
             
//   get biases from CKT //
     Vgsi  = TYPE * V(BRgps) ;
     Vdsei = TYPE * V(BRds ) ;
     Vgsei = TYPE * V(BRgs) ;
     Vbsei = TYPE * V(BRbps) ;
//-------------SHE------------------//
     if(COSELFHEAT && RTH0 > 0.0) begin
       deltemp = (Temp(t) > 0.0) ? Temp(t) : 0.0 ;
     end else begin
       deltemp = 0.0 ;
     end
//   NQS nodes
     if(flg_nqs) begin
       Qi_nqs = `NQS_CAP * V(nqs_qi) ;
       Qb_nqs = `NQS_CAP * V(nqs_qb) ;
     end else begin
       Qi_nqs = 0.0 ; Qb_nqs = 0.0 ;
     end
//
     if(Vdsei >= 0)  begin  // normal mode //
       mode = 1 ;
       ModeNML = 1.0 ;
       ModeRVS = 0.0 ;
       Vgs  = Vgsi ;
       Vdse = Vdsei ;
       Vgse = Vgsei ;
       Vbse = Vbsei ;
     end  else  begin     // reverse mode //
       mode = -1 ;
       ModeNML = 0.0 ;
       ModeRVS = 1.0 ;
       Vgs  =  Vgsi - Vdsei ;
       Vdse = -Vdsei ;
       Vgse = Vgsei - Vdsei ;
       Vbse = Vbsei - Vdsei ;
     end
          
     if( INFO >= 5 )  begin  // mode, bias conditions ... //
       $write( "--- variables given to HSMSOTBevaluate() ----\n" ) ;
       $write( "TYPE   = %d\n" , TYPE ) ;
       $write( "mode   = %d\n" , mode ) ;
       $write( "Vbsei  = %5.10e \n" , Vbsei ) ;
       $write( "Vdsei  = %5.10e \n" , Vdsei ) ;
       $write( "Vgsei Vgsi    = %5.10e %5.10e\n" , Vgsei, Vgsi ) ;
     end
          
     if( INFO >= 6 )  begin  // input flags //
       $write( "corg    = %d\n" , CORG ) ;
       $write( "coadov  = %d\n" , COADOV ) ;
       $write( "cofbe   = %d\n" , COFBE ) ;
       $write( "coisub  = %d\n" , COISUB ) ;
       $write( "coievb  = %d\n" , COIEVB ) ;
       $write( "coiigs  = %d\n" , COIIGS ) ;
       $write( "cogidl  = %d\n" , COGIDL ) ;
       $write( "coovlp  = %d\n" , COOVLP ) ;
       $write( "coflick = %d\n" , COFLICK ) ;
       $write( "coisti  = %d\n" , COISTI ) ;
       $write( "conqs   = %d\n" , CONQS  ) ;
       $write( "cohist  = %d\n" , COHIST ) ;
       $write( "cothrml = %d\n" , COTHRML ) ;
       $write( "coign   = %d\n" , COIGN ) ;
       $write( "coselfheat = %d\n" , COSELFHEAT ) ;
     end
          
//start_of_evaluation ;
          
     //-----------------------------------------------------------*
     //* Temperature dependent constants.
     //*-----------------//
     TTEMP = $temperature ;
     if( temp_Given) TTEMP = UC_TEMP ;
     TTEMP = TTEMP + DTEMP + deltemp ;
           
     // Band gap //
     egtnom = EG0 - UC_TNOM
            * ( 90.25e-6 + UC_TNOM * 1.0e-7 ) ;
     T1 = TTEMP * TTEMP - UC_TNOM * UC_TNOM ;
     Eg = egtnom - BGTMP1 * (TTEMP - UC_TNOM) - BGTMP2 * T1 ;
     beta   = `C_QE / (`C_KB * TTEMP) ;
     beta2  = beta * beta ;
     beta_inv = 1.0 / beta ;
     betatnom = `C_QE / (`C_KB * UC_TNOM) ;

     UC_GIDLBPL1 = GIDLBPL1 * pow(TTEMP / UC_TNOM, GIDLBPLT) ;
        
     begin : MUEPH
        //CGS unit
        real CGS_mueph, CGS_muephb, T1, T2, T3;
        
        CGS_mueph = MUEPH1 * (1.0e0 + (MUEPHW / pow(WG, MUEPWP)))
              * (1.0e0 + (MUEPHL / pow(LG , MUEPLP)))
              * (1.0e0 + (MUEPHS / pow(WLG, MUEPSP))) ;
        CGS_muephb = MUEPH1B * (1.0e0 + (MUEPHWB / pow(WG, MUEPWPB)))
              * (1.0e0 + (MUEPHLB / pow(LG , MUEPLPB)))
              * (1.0e0 + (MUEPHSB / pow(WLG, MUEPSPB))) ;

        if(Lod_half > 0.0) begin
           T1 = 1.0e0 / (1.0e0 + MUESTI2) ;
           T2 = pow (MUESTI1 / Lod_half, MUESTI3) ;
           T3 = pow (MUESTI1 / Lod_half_ref, MUESTI3) ;
           CGS_mueph  = CGS_mueph * (1.0e0 + T1 * T2) / (1.0e0 + T1 * T3);
           CGS_muephb = CGS_muephb * (1.0e0 + T1 * T2) / (1.0e0 + T1 * T3);
        end

        // Phonon Scattering(temperature-dependent part) //
        T1 = (1.0e0 + (MUETMPL / pow(LG , MUETMPLP))) ;
        mtmp = MUETMP * T1 + MUETMP1 * (TTEMP / UC_TNOM - 1) * (TTEMP / UC_TNOM - 1); 
        T1 = pow(TTEMP / UC_TNOM, mtmp) ;
        CGS_mphn0  = T1 / CGS_mueph ;
        CGS_mphbn0 = T1 / CGS_muephb ;

     end

     // Pocket Overlap(temperature-dependent part) //
     ptovr = ptovr0 * beta_inv ;
           
     // Velocity LG,WG,S Dependence // 2015.11.13
     T1 = (1.0e0 + (VOVER  / pow(LG , VOVERP )))
        * (1.0e0 + (VOVERL / pow(LG , VOVERLP)))
        * (1.0e0 + (VOVERW / pow(WG , VOVERWP)))   
        * (1.0e0 + (VOVERS / pow(WLG, VOVERSP))) ; 
     `Fn_SZ(vmax0, T1, 0.001, T2) 

     // Velocity Temperature Dependence //
     T1 = TTEMP / UC_TNOM ;
     T2 = (1.0e0 + (VTMPL / pow(LG , VTMPLP))) ;
     Vmaxe = `C_cm2m * (vmax0 * MKS_VMAX
                        / (1.8 * `C_cm2m  + 0.4 * T1 * `C_cm2m + 0.1 * T1 * T1 * `C_cm2m - MKS_VTMP * T2 * (1.0 - T1))) ;
          
     Egp12 = sqrt(Eg) ; 
     Egp32 = Eg * Egp12 ;
           
     // Intrinsic carrier concentration //
     Nin   = `C_Nin0 * `Fn_Pow(TTEMP / UC_TNOM, 1.5e0)
            * exp(- Eg / 2.0e0 * beta + egtnom / 2.0e0 * betatnom) ;
           
     // costi0 and costi1 for STI transistor model(temperature-dependent part) //
     costi00 = sqrt (2.0 * `C_QE * UC_NSTI * `C_ESI ) ;
     nsti_p2 = 1.0 / ( UC_NSTI * UC_NSTI ) ;
     costi0 = costi00 * sqrt(beta_inv) ;
     costi0_p2 = costi0 * costi0 ; 
     costi1 = Nin * Nin * nsti_p2 ;

     //-----------------------------------------------------------*
     //Fixed part.
     //----------------//
           
     // Lgate in [cm] / [m] //
           
     // Metallurgical channel geometry //
     T1 = XLD / (XLDL + XLDLMIN) * L ;
     T3 = abs(XLD * 1e-3 + `epsm10/`C_m2cm) ;
     if(XLD > 0.0) begin
       `Fn_SU(T2, T1, XLD, T3, T1)
     end else begin
       `Fn_SL(T2, T1, XLD, T3, T1)
     end
     Leff = L - 2.0e0 * T2 ;
   
     // Flat band voltage //
     T1 = - VFBC * (1 + VFBCL1 / pow(LG, VFBCL1P)) ; 
     T2 = - VFBC * (1 + VFBCL2 / pow(LG, VFBCL2P)) ; //
     T3 = - (VFBC + VFBHAMP * LG) ;                  //
     `Fn_SL(Vfb,  T1, T2, 1e-12, T1)
     `Fn_SL(Vfb, Vfb, T3, 1e-12, T1)
     Vfb = - Vfb ;

     // 2 phi_B //
     // @temp, with pocket //
     Pb2   = 2.0 * beta_inv * ln (`N_sub_SOI / Nin) ;
           
     // Debye length //
     Ldby = sqrt((`C_ESI / q_Nsub) * beta_inv) ;
     // Coefficient of the F function for bulk charge //
     cnst0SOI = q_Nsub * `C_SQRT_2 * Ldby ;
     c0bulk = qnbulk_esi ;
            
     // cnst0bulk //
     cnst0bulk    = sqrt(2.0 * c0bulk * beta_inv) ;
                  
     // cnst1: n_{p0} / p_{p0} //
     T1 = Nin / `N_sub_SOI ;
     cnst1SOI = T1 * T1 ;
     T1 = Nin / N_subbl; 
     cnst1bulk = T1 * T1 ;
               
     // Tfox0 //
     Tfox0 = `t_fox ;
           
     C_fox0 = `C_EOX / Tfox0 ;
     C_fox0_inv = Tfox0 / `C_EOX ;
     C_box = `C_EOX / `t_box ;
     C_box_inv = `t_box / `C_EOX ;
     Q_FD_SOI = -`C_QE * `N_sub_SOI * `t_SOI ;
     C_soi = `C_ESI / `t_SOI ;
     C_soi_inv = 1.0 / C_soi;
     C_box_FD_inv = C_box_inv + C_soi_inv;
     
     begin : PostParamCheck
       
       integer FATAL_flag ;
       FATAL_flag = 0 ;
       `PMINCHECK(Weff   ,1e-9,"An effective channel width  < 1nm ")
       `PMINCHECK(weff_cv,1e-9,"An effective channel width for C-V < 1nm")
       `PMINCHECK(Leff   ,1e-9,"An effective channel length < 1nm")
       if(FATAL_flag) $finish(0);
       
     end // paramCheck
     
     //-----------------------------------------------------------*
     //Select Ves.
     //----------------//
     Vbs_bnd = VBSBND ;
     Vbs_max = VBSMAX ;
             
     //---------------------------------------------------*
     //Clamp too large biases.
     //----------------//
     if(Vbs_bnd > Vbs_max * 0.5) begin
       Vbs_bnd = 0.5 * Vbs_max ;
     end
     if(Vbse > Vbs_bnd) begin
       T2 = Vbse - Vbs_bnd ;
       T3 = Vbs_max - Vbs_bnd ;
       `Fn_CP(T4, T2, T3, 4, T8) 
       Vbsc = Vbs_bnd + T4 ;
       Vbsc_dVbse = T8 ;
     end else begin
       Vbsc = Vbse ;
       Vbsc_dVbse = 1.0 ;
     end
     
     Vdsc = Vdse ;
     Vgsc = Vgs ;
     
     
     begin : COPPRV_model // (copprv = 1)
       //
       // Definitions for Memory State Variables for COPPRV model
       //
       real Pss0_ini, Pbs0_ini, Psb0_ini ;
       real Pssl_ini, Pbsl_ini, Psbl_ini ;
       
`ifdef DISABLE_COPPRV
`else
       integer called , mode_prv , mode_prv2 ;
       real vtol_pprv ;
       real vbsc_prv  , vdsc_prv  , vgsc_prv ; 
       real vbsc_prv2 , vdsc_prv2 , vgsc_prv2 ;
       real Vbsc_dif  , Vdsc_dif  , Vgsc_dif  , sum_vdif ;
       real Vbsc_dif2 , Vdsc_dif2 , Vgsc_dif2 , sum_vdif2 ;
       real dVbs  , dVds  , dVgs  ;
       real ddVbs , ddVds , ddVgs ;
       real TXdvbs , TXdvds , TXdvgs ;
       real pss0_prv  , pbs0_prv  , psb0_prv ;
       real pss0_dvbs_prv  , pss0_dvgs_prv ;
       real pbs0_dvbs_prv  , pbs0_dvgs_prv ;
       real psb0_dvbs_prv  , psb0_dvgs_prv ;
       real pss0_dvbs_prv2 , pss0_dvgs_prv2 ;
       real pbs0_dvbs_prv2 , pbs0_dvgs_prv2 ;
       real psb0_dvbs_prv2 , psb0_dvgs_prv2 ;
       real pssl_prv  , pbsl_prv  , psbl_prv ;
       real pssl_dvbs_prv  , pssl_dvds_prv  , pssl_dvgs_prv ;
       real pbsl_dvbs_prv  , pbsl_dvds_prv  , pbsl_dvgs_prv ;
       real psbl_dvbs_prv  , psbl_dvds_prv  , psbl_dvgs_prv ;
       real pssl_dvbs_prv2 , pssl_dvds_prv2 , pssl_dvgs_prv2 ;
       real pbsl_dvbs_prv2 , pbsl_dvds_prv2 , pbsl_dvgs_prv2 ;
       real psbl_dvbs_prv2 , psbl_dvds_prv2 , psbl_dvgs_prv2 ;
       
       // End of Definitions
`endif // COPPRV
       
       flg_pprv = 0;
       
`ifdef DISABLE_COPPRV
       /* Initialization for hidden states */
       Pss0_ini=0.0; Pbs0_ini=0.0; Psb0_ini=0.0; 
       Pssl_ini=0.0; Pbsl_ini=0.0; Psbl_ini=0.0; 
`else
`define calPhis0_ini( Ps_ini, ps_prv, ps_dvbs_prv, ps_dvgs_prv, ps_dvbs_prv2, ps_dvgs_prv2 ) \
     begin \
       if( flg_pprv >= 1) begin \
         T1 = dVbs * ps_dvbs_prv + dVgs * ps_dvgs_prv ; \
         Ps_ini = ps_prv + T1 ; \
         if(flg_pprv == 2) begin \
           TXdvbs = ( Vbsc_dif2 > `epsm10 ) ? ((ps_dvbs_prv-ps_dvbs_prv2)/Vbsc_dif2) : 0.0 ; \
           TXdvgs = ( Vgsc_dif2 > `epsm10 ) ? ((ps_dvgs_prv-ps_dvgs_prv2)/Vgsc_dif2) : 0.0 ; \
           T2     = ddVbs * TXdvbs + ddVgs * TXdvgs ; \
           if( abs(T2) < abs(0.5*T1) ) Ps_ini = Ps_ini + T2 ; else flg_pprv = 1 ; \
           T1 = Ps_ini - ps_prv ; \
           if( T1 < - `dP_max || T1 > `dP_max ) flg_pprv = 0 ; \
         end \
       end \
     end
       
`define calPhis_ini( Ps_ini, ps_prv, ps_dvbs_prv, ps_dvds_prv, ps_dvgs_prv, ps_dvbs_prv2, ps_dvds_prv2, ps_dvgs_prv2 ) \
     begin \
       if( flg_pprv >= 1) begin \
         T1 = dVbs * ps_dvbs_prv + dVds * ps_dvds_prv + dVgs * ps_dvgs_prv ; \
         Ps_ini = ps_prv + T1 ; \
         if(flg_pprv == 2) begin \
           TXdvbs = ( Vbsc_dif2 > `epsm10 ) ? ((ps_dvbs_prv-ps_dvbs_prv2)/Vbsc_dif2) : 0.0 ; \
           TXdvds = ( Vdsc_dif2 > `epsm10 ) ? ((ps_dvds_prv-ps_dvds_prv2)/Vdsc_dif2) : 0.0 ; \
           TXdvgs = ( Vgsc_dif2 > `epsm10 ) ? ((ps_dvgs_prv-ps_dvgs_prv2)/Vgsc_dif2) : 0.0 ; \
           T2     = ddVbs * TXdvbs + ddVds * TXdvds + ddVgs * TXdvgs ; \
           if( abs(T2) < abs(0.5*T1) ) Ps_ini = Ps_ini + T2 ; else flg_pprv = 1 ; \
           T1 = Ps_ini - ps_prv ; \
           if( T1 < - `dP_max || T1 > `dP_max ) flg_pprv = 0 ; \
         end \
       end \
     end
       
       //-------------------------------------------------------------------*
       // Update initial potential values by previous values
       //----------------//
       vtol_pprv = 5.0e-2 ;
       if( COPPRV ) begin
         
         if(called >= 1)  begin
           Vbsc_dif = Vbsc - vbsc_prv ; Vdsc_dif = Vdsc - vdsc_prv ; Vgsc_dif = Vgsc - vgsc_prv ;
           sum_vdif = abs(Vbsc_dif) + abs(Vdsc_dif) + abs(Vgsc_dif) ;
           if(sum_vdif <= vtol_pprv && mode * mode_prv > 0 ) flg_pprv = 1 ; 
           if( called >=2 && flg_pprv ==1 ) begin
             Vbsc_dif2 = vbsc_prv - vbsc_prv2 ; Vdsc_dif2 = vdsc_prv - vdsc_prv2 ; Vgsc_dif2 = vgsc_prv - vgsc_prv2 ;
             sum_vdif2 = abs(Vbsc_dif2) + abs(Vdsc_dif2) + abs(Vgsc_dif2) ;
             if(`epsm10 < sum_vdif2 && sum_vdif2 <= vtol_pprv && mode_prv * mode_prv2 > 0 ) flg_pprv = 2 ; 
           end
           dVbs = Vbsc_dif ; dVds = Vdsc_dif ; dVgs = Vgsc_dif ;
           ddVbs = dVbs * dVbs /2 ; ddVds = dVds * dVds /2 ; ddVgs = dVgs * dVgs /2 ;
           //
           if( flg_pprv >= 1 ) begin
             `calPhis0_ini(Pss0_ini,pss0_prv,pss0_dvbs_prv,pss0_dvgs_prv,pss0_dvbs_prv2,pss0_dvgs_prv2)
             `calPhis0_ini(Pbs0_ini,pbs0_prv,pbs0_dvbs_prv,pbs0_dvgs_prv,pbs0_dvbs_prv2,pbs0_dvgs_prv2)
             `calPhis0_ini(Psb0_ini,psb0_prv,psb0_dvbs_prv,psb0_dvgs_prv,psb0_dvbs_prv2,psb0_dvgs_prv2)
           end
           if( flg_pprv >= 1 ) begin
             `calPhis_ini(Pssl_ini,pssl_prv,pssl_dvbs_prv,pssl_dvds_prv,pssl_dvgs_prv,pssl_dvbs_prv2,pssl_dvds_prv2,pssl_dvgs_prv2)
             `calPhis_ini(Pbsl_ini,pbsl_prv,pbsl_dvbs_prv,pbsl_dvds_prv,pbsl_dvgs_prv,pbsl_dvbs_prv2,pbsl_dvds_prv2,pbsl_dvgs_prv2)
             `calPhis_ini(Psbl_ini,psbl_prv,psbl_dvbs_prv,psbl_dvds_prv,psbl_dvgs_prv,psbl_dvbs_prv2,psbl_dvds_prv2,psbl_dvgs_prv2)
           end
         end else begin
           Vbsc_dif  = 0.0 ; Vdsc_dif  = 0.0 ; Vgsc_dif  = 0.0 ;
           Vbsc_dif2 = 0.0 ; Vdsc_dif2 = 0.0 ; Vgsc_dif2 = 0.0 ;
           sum_vdif  = 0.0 ; sum_vdif2 = 0.0 ; flg_pprv = 0 ;
         end
         
       end // End of (COPPRV)
`endif // COPPRV
       
       //   Vbs, Vds and Vgs are determined.   //
       Vbs = Vbsc ;
       Vds = Vdsc ;
       Vgs = Vgsc ;
       
       //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       //PART-1: Basic device characteristics.
       //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
       
       //-----------------------------------------------------------*
       //Initialization.
       //----------------//
       // Initialization of counters is needed for restart. //
       lp_s0 = 0 ;
       lp_sl = 0 ;
       
       //-----------------------------------------------------------*
       //    Vxsz: Modified bias introduced to realize symmetry at Vds=0.
       //    ----------------  from HiSIM 2.5.1 //
       T1 = Vbsc_dVbse * Vds / 2 ;
       `Fn_SymAdd(Vzadd, T1, VZADD0, T2) 
       if(Vzadd < `ps_conv) begin
         Vzadd = `ps_conv ;
       end
       
       Vbsz = Vbs + Vzadd ;
       Vdsz = Vds + 2.0 * Vzadd ;
       Vgsz = Vgs + Vzadd ;
       
       //---------------------------------------------------*
       //* Factor of modification for symmetry.
       //*-----------------//
       T1 = (2.0 * q_Nsub * `C_ESI) * C_fox0_inv * C_fox0_inv ;
       T2 = Vgs - Vfb ;
       T3 = 1 + 2.0 / T1 * (T2 - beta_inv - Vbs) ;
       `Fn_SZ(T4, T3, 1e-3, T5) 
       TX = sqrt(T4 + `Small) ;
       Pslsat = T2 + T1 * (1.0 - TX) ;
       VdsatS = Pslsat - Pb2 ;
       `Fn_SL(VdsatS, VdsatS, 0.1, 5e-2, T6) 
       T1 = Vds / VdsatS ;
       `Fn_SUPoly4(TX, T1, 1.0, T0) 
       FMDVDS = TX * TX ;
       
       //-----------------------------------------------------------*
       //* Quantum Mechanical Effect
       //*-----------------//
       if((QME1 == 0.0 && QME3 == 0.0) || QME2 == 0.0) begin
         flg_qme = 0 ;
       end else begin
         flg_qme = 1 ;
       end
       Vthq = Pb20 + Vfb + sqrt(2.0 * q_Nsub * `C_ESI * Pb20) / C_fox0 ;
       if(flg_qme == 0) begin
         Tfoxe = Tfox0 ;
         C_fox = C_fox0 ;
         C_fox_inv = C_fox0_inv ;
         T0 = cnst0SOI * C_fox0_inv * C_fox0_inv ;
         cnstC_foxi = T0 * cnst0SOI ;
       end else begin             //!if( flg_qme == 0 )
         T5     = Vgs  - Vbs - Vthq + QME2 ;
         `Fn_SZ( T2 , T5 , `qme_dlt, T3) 
         T3 = 1.0 /  T2 ;
         T4 = 2.0 * abs(Vthq) ;
         T6 = Vfb - Vthq + QME2 ;
         if(T6 > T4) begin T4 = T6 ; end
         `Fn_SU( T2 , T3 , 1.0 / T4  , `qme_dlt, T6 ) 
         dTfox = QME1 * T2 + QME3 ;
         if( dTfox * 1.0e12 < Tfox0 ) begin
           dTfox = 0.0 ;
           flg_qme = 0 ;
         end
         Tfoxe = Tfox0 + dTfox ;
         C_fox = `C_EOX / Tfoxe ;
         C_fox_inv  = Tfoxe / `C_EOX ;
         cnstC_foxi = cnst0SOI * cnst0SOI * C_fox_inv * C_fox_inv ;
       end                        // end of flg_qme if-blocks //
       
       //---------------------------------------------------*
       //* Vbsz2 : Vbs for dVth
       //*-----------------//
       `Fn_SU(Vbsz2, Vbsz, 0.5, 1.0e-3, T0) 
       
       //---------------------------------------------------*
       //* Vthp : Vth with pocket.
       //*-----------------//
       // Disable Vbs dependence for Vthp(Pocket) //
       Qb0 = sqrt(qnsub_esi2 * Pb20) ;
       Vthp = Pb20 + Vfb + Qb0 * C_fox_inv + ptovr ;
       Pb20b = Pb20 ;
       T0 = 0.95 ;
       T1 = T0 * Pb20b - Vbsz2 - 1.0e-3 ;
       T2 = sqrt(T1 * T1 + 4.0 * T0 * Pb20b * 1.0e-3) ;
       Pbsum = Pb20b - (T0 * Pb20b - 0.5 * (T1 + T2));

       sqrt_Pbsum = sqrt( Pbsum ) ;
       
       //-------------------------------------------*
       //     dVthLP : Short-channel effect induced by pocket.
       //     - Vth0 : Vth without pocket.
       //    -----------------//
       if(LP != 0.0) begin
         
         // Disable Vbs dependence for Vth0(Pocket) //
         T0 = sqrt((2.0 * `C_QE * UC_NSUBS * `C_ESI) * Pb2c) ;
         Vth0 = Pb2c + Vfb + T0 * C_fox_inv ;
         
         // Fixed Wd to Tsoi(Pocket) //
         T0 = 2.0e0 * `t_SOI / (LP * LP) ;
         dVth0 = (`C_ESI * C_fox_inv) * T0 * (VBI - Pb20b) ;
         
         T0 = (SCP1 + (SCP3 / LP) * Pbsum) + SCP2 * Vdsz ;
         dVthLP = (Vthp - Vth0) * dVth0 * T0 ;
       end else begin
         dVthLP = 0.0 ;
       end
       
       //---------------------------------------------------*
       //* dVthSC : Short-channel effect.
       //*-----------------//
       
       if( PTHROU != 0.0 ) begin
         // Modify Pb20 to Pb20b //
         T10 = beta_inv - cnstC_foxi * beta * 0.25 + Vfb + `Small ;
         T1 = Vgsz - T10 - `psia2_dlt ;
         T0 = `Fn_Sgn(T10) ;
         T2 = sqrt (T1 * T1 + T0 * 4.0 * T10 * `psia2_dlt) ;
         T3 = T10 + 0.5 * (T1 + T2) - Vfb ; // Vgpa for sqrt calc. //
         T4 = 4.0 / cnstC_foxi * beta_inv * beta_inv ;
         T5 = beta * T3 - 1.0 ;
         T1 = 1.0 + T5 * T4 ;
         `Fn_SZ( T1 ,T1, `psia_dlt, T7)
         T2 = sqrt (T1 + `epsm10) ;
         Psi_a = T3 + cnstC_foxi * 0.5 * beta * (1.0 - T2) ;
         `Fn_SU( Pb20a , Psi_a, Pb20, `psia2_dlt, T2)
         Pb20b = Pb20 + PTHROU * (Pb20a - Pb20) ;
       end
       
       // Fixed Wd to Tsoi //
       T1 = C_fox_inv * `C_ESI * `t_SOI * 2.0e0 ;
       T2 = VBI - Pb20b ;
       T3 = Lgate - PARL2 ;
       dVth0 = T1 * T2 / (T3 * T3) ;
       
       `Fn_SZ( Vbs_prime, Vbs, 1e-3, T0 ) 
       
       T5 = SC1 + (SC3 / Lgate) * Pbsum + SC2 * Vdsz + SC5 * Vbs_prime;         
       dVthSC = dVth0 * T5 ;
       
       //---------------------------------------------------*
       //* dVthSCR : back-field effect.
       //*------------------------//
       if(SCR1 > 0.0) begin
         T1 = Eg + Pb2 - 2.0 * SCR3 + SCR2 * Vdsz ;
         T2 = Lgate * 0.5 + PARL1 ;
         T3 = SCR1 * `t_SOI / T2 ;
         dVthSCR = T1 * T3 ;
       end else begin
         dVthSCR = 0.0 ;
       end
       
       //---------------------------------------------------*
       //* dVthW : narrow-channel effect.
       //*-----------------//
       T3 = 1.0 / (C_fox + UC_WFC / Weff) ;
       T5 = (C_fox_inv) - T3 ;
       dVthW = Qb0 * T5 + WVTH0 / WG ;
       
       //---------------------------------------------------*
       //    dVth : Total variation.
       //    - Positive dVth means the decrease in Vth.
       //    ----------------//
       dVth = dVthSC + dVthLP + dVthW + dVthSCR + dVthsm ;
       
       //---------------------------------------------------*
       //    Vth : Threshold voltage.
       //    ----------------//
       Vth = Vthp - dVth ;
       
       //---------------------------------------------------*
       //Poly-Depletion Effect
       //( transplanted from HiSIM2.4.3 ) 
       //----------------//
       if(PGD1 == 0.0) begin
         flg_dPpg = 0 ;
       end else begin
         flg_dPpg = 1 ;
       end
       if(flg_dPpg == 0) begin
         dPpg = 0.0 ;
       end else begin
         T3 = Vgsz - PGD2 ;
         `Fn_ExpLim( dPpg , T3 , T6 ) 
         `Fn_SZ( dPpg , dPpg - 1.0 , 0.1 , T6 ) 
         dPpg = dPpg * cnstpgd ;
         `Fn_SU( dPpg , dPpg , `pol_b , `pol_dlt , T9 ) 
       end                        // end of flg_dPpg if-blocks //
       
       //---------------------------------------------------*
       //    Vgp : Effective gate bias with SCE & RSCE & flatband.
       //    ----------------//
       Vgp = Vgs - Vfb + dVth - dPpg ;
       Vgpz = Vgp ;               
       
       //---------------------------------------------------*
       //    Vbi_SOI : Difference of built-in potential between SOI and bulk.
       //    Vgs_fb : Flatband voltage taking account Vbs.
       //    -----------------//
       Vbi_SOI = beta_inv * ln (`N_sub_SOI / N_subbl) ; 
       Vgs_fb = Vfb - dVth + dPpg ; 

       //-----------------------------------------------------------*
       //Constants in the equation of Ps0 .
       //----------------//
       fac1 = cnst0SOI * C_fox_inv ;
       fac1p2 = fac1 * fac1 ;
       
       //-----------------------------------------------------------*
       //Solve Poisson's equation for FB devices
       //----------------//
       
       if(COVBSBIZ) Vbsbiz = Vbsz + Vbi_SOI ;
              else  Vbsbiz = Vbs  + Vbi_SOI ;
       
 begin : HSOTB_new_phi_s0_bulk_0

     // new phi_s0_bulk_0 
     if( Vbsbiz < 0.0 ) begin
       T0 = N_subbl / `N_sub_SOI ; T1 = T0 + 1.0 ; // n, n'
       T2 = beta_inv - Vbsbiz + T0 * (beta_inv + Vbsbiz) ; // A
       T3 = cnst0bulk * cnst0bulk * C_box_inv * C_box_inv ; // B
       T4 = 2.0 * T2 * T1 - T3 * beta  ;
       T5 = T2 * T2  + T3 * beta * Vbsbiz + T3 ; // C
       T7 = `Fn_Max((T4 * T4 - 4.0 * T1 * T1 * T5), `Small) ;
       phi_s0_bulk_0 = ( T4 + sqrt( T7 ) )/( 2.0 + T1 * T1 ) ;
     end else begin
       T1 = cnst0bulk * cnst0bulk * beta ; // A
       T2 = cnst0SOI  * cnst0SOI  * beta ; // B
       T3 = - ( beta_inv + 2.0 * Vbsbiz ) ; // C
       T4 = 1.0 + T2 / T1 ;  // D
       T5 = cnst0SOI * cnst0SOI * C_box_inv * C_box_inv ; // E
       T6 = T5 * beta - 2.0 * T3 * T4 ;
       T7 = `Fn_Max((T6 * T6 - 4.0 * T4 * T4 * T3 * T3), `Small) ;
       phi_s0_bulk_0 = ( T6 + sqrt( T7 ) ) / ( 2.0 * T4 * T4 ) ;
     end
                      
     //---------------------------------------------------*
     //    phi_s0_bulk_0 :
     // -----------------//
     // initial value(phi_s0_bulk_0) start //

     Pb2_bulk = 2 / beta * ln (N_subbl / Nin) ;
     T0 = cnst0bulk * cnst0bulk * C_box_FD_inv * C_box_FD_inv ;
     T1 = -(Vbsbiz) ;
     T2 = (2 * T1 + T0 * beta) * (2 * T1 + T0 * beta) - 4 * (T1 * T1 + T0) ;
     T2 = `Fn_Max(T2, `epsm10) ;
     T2 = sqrt(T2) ;
     T3 = 2 * T1 + T0 * beta ;
     psb_iniA = (T3 - T2) / 2 ;
     psb_iniB = ln (T1 * T1 / T0 / cnst1bulk) / (beta + 2 / T1) ;
     if(psb_iniA < Pb2_bulk) begin
       phi_s0_bulk_0 = psb_iniA ;
     end else begin
       `Fn_SU(phi_s0_bulk_0, psb_iniA, psb_iniB, `c_ps0ini_2, T1) 
     end
     // initial value(phi_s0_bulk_0) end //
                   
     // newton loop(phi_s0_bulk_0) start //
     for (lp_s0 = 0 ; lp_s0 < lp_s0_max ;  lp_s0 = lp_s0 + 1 ) begin
       T1 = cnst0bulk ;
       T2 = beta * phi_s0_bulk_0 ;
       T3 = exp(-T2) ;
       if(phi_s0_bulk_0 > `C_PHI_1_MINIMUM) begin
         T0 = exp(beta * phi_s0_bulk_0) ;
         T4 = -T1 * sqrt(T3 + T2 - 1 + cnst1bulk * (T0 - 1)) ;  //Qbulk
         T5 = c0bulk / T4 * (-T3 + 1 + cnst1bulk * (T0)) ;      //dQbulk_dPsb
       end else if(phi_s0_bulk_0 < -`C_PHI_1_MINIMUM) begin
         T4 = T1 * sqrt(T3 + T2 - 1) ;  //Qbulk
         T5 = c0bulk / T4 * (-T3 + 1) ; //dQbulk_dPsb
       end else begin
         T4 = -sqrt(c0bulk / beta) * beta * phi_s0_bulk_0 ;     //Qbulk
         T5 = -sqrt(c0bulk * beta) ;    //dQbulk_dPsb
       end
       `Fn_SZ(T6, T4, 1e-6 , T7) 
       `Fn_SU(T6, T6, (-Q_FD_SOI), 1e-9 , T8) 
       T7 = T7 * ( T5 * T8 ) ;
       phi_b_dep0 = T6 * T6 / 2 / `C_ESI / `C_QE / `N_sub_SOI ;
       phi_b_dep0_dPsb = 2 * phi_b_dep0 * T7 / T6 ;
                       
       T6 = phi_s0_bulk_0 - ((-phi_s0_bulk_0 + T4 / C_box - Vbsbiz + phi_b_dep0)
          / (-1 + T5 / C_box + phi_b_dep0_dPsb)) ;
       if(abs(T6 - phi_s0_bulk_0) < `ps_conv_ini) begin
         lp_s0 = lp_s0_max ;
       end
       phi_s0_bulk_0 = T6 ;
       Q_s0_bulk_0 = T4 ;
     end
     // newton loop(phi_s0_bulk_0) end //

 end  // HSOTB_new_phi_s0_bulk_0

     // Vgs_fb shift for initial guess(start) //
     phi_b_dep = phi_b_dep0 ;
     T1 = sqrt(`cnst_2esi_q * phi_b_dep / `N_sub_SOI) ;
     if(T1 > 0.99 * `t_SOI) begin
       T0 = 1 / C_fox ;
       T2 = 1 / C_box ;
       T3 = 1 / (T0 + C_soi_inv + T2) ;
       T4 = 1 - T3 * T0 ;
       T5 = T0 * (T3 * (- Vbsbiz + (T2 + 0.5 * C_soi_inv) * (-Q_FD_SOI))) ;
       shift = T5 / T4 ;
       Vgs_fb = Vgs_fb + shift ;
       Vgp = Vgp - VFBSHIFT * shift ; 
       Vgpz = Vgp ;
     end
       
     //-----------------------------------------------------------*
     //* Initial Guess for Source Side.
     //*-----------------//
     if( flg_pprv >= 1 ) begin
       phi_s0_SOI  = Pss0_ini ;
       phi_b0_SOI  = Pbs0_ini ;
       phi_s0_bulk = Psb0_ini + Vbsbiz ;
       FD_start = (-Q_FD_SOI) * C_soi_inv / 2.0 + beta_inv ;
       FD_end = FD_start - Q_s0_bulk_0 * C_soi_inv ;
     end else begin
   
       // Calc Vfb_shift for initial guess
       if(Vbsbiz < 0.0) begin
         Vgs_shift = 0 ; 
         for (lp_s0 = 1 ; lp_s0 <= lp_s0_max ;  lp_s0 = lp_s0 + 1 ) begin
           T0 = C_box / (2 * `C_QE * `C_ESI * N_subbl) ;
           T1 = 1 + C_box * C_soi_inv ;
           T2 = C_box * (0.5 * (-Q_FD_SOI) * C_soi_inv + beta_inv + Vbsbiz) ;
           T7 = 2 * T0 * C_fox * C_fox ;
           T4 = C_box + T1 * C_fox + 2 * T0 * C_fox * Q_FD_SOI + T7 * Vgs_shift ;
           T8 = 2 * C_box * C_fox * 2 * T0 * C_fox ;
           T5 = C_box * C_box + (T1 * T1 - 4 * T0 * T2) * C_fox * C_fox +
           2 * C_box * C_fox * (T1 + 2 * T0 * Q_FD_SOI) + T8 * Vgs_shift ;
           T5 = sqrt(T5) ; 
           T8 = T8 / ( 2 * T5 ) ;
           T6 = 1 / ( 2 * T0 * C_fox * C_fox ) ;
           
           PF1  = T6 * (T4 - T5) ;
           PF11 = T6 * (T7 - T8) ;
           dPsb = - PF1 / PF11 ;
           if(abs(dPsb) < `ps_conv) begin
             lp_s0 = lp_s0_max ; // break
           end else if(dPsb > `dP_max) begin
             dPsb = `dP_max ;
           end else if(dPsb < - `dP_max) begin
             dPsb = - `dP_max ;
           end
           Vgs_shift = Vgs_shift + dPsb ;
         end 
       end // Calc Vfb_shift for initial guess


       //-----------------------------------------------------------*
       //* Initial Guess for SOI (start) .
       //*-----------------//

       if(Vgs < Vgs_fb + Vgs_shift ) begin

         flg_depmode = 1 ;
         flg_zone = -1 ;

 begin : HSOTB_calc_ini_for_Accum

       // initial guess for phi_s0_bulk calculation(start) //
       phi_b_dep = phi_b_dep0 ;
       T1 = sqrt(`cnst_2esi_q * phi_b_dep / `N_sub_SOI) ;
       T0 = cnst0bulk * cnst0bulk * C_box_FD_inv * C_box_FD_inv ;
          
       if(WdSOI + T1 < `t_SOI) begin    // note that WdSOI=0 //
         T1 = -(Vbsbiz) + `epsm10 ;
         T2 = (2 * T1 + T0 * beta) * (2 * T1 + T0 * beta) - 4 * (T1 * T1 + T0) ;
         T2 = `Fn_Max(T2, `epsm10) ;
         T2 = sqrt(T2) ;
         T3 = 2 * T1 + T0 * beta ;
         psb_iniA = (T3 - T2) / 2 ;
         psb_iniB = ln (T1 * T1 / T0 / cnst1bulk) / (beta + 2 / T1) ;
         if(psb_iniA < Pb2_bulk) begin
           phi_s0_bulk = psb_iniA ;
         end else begin
           `Fn_SU(phi_s0_bulk, psb_iniA, psb_iniB, `c_ps0ini_2, T1) 
         end
       end else begin
         T1 = -(Vbsbiz - phi_s0_SOI - Q_FD_SOI / 2 * `t_SOI / `C_ESI) ;
         T2 = (2 * T1 + T0 * beta) * (2 * T1 + T0 * beta) - 4 * (T1 * T1 + T0) ;
         T2 = `Fn_Max(T2, `epsm10) ;
         T2 = sqrt(T2) ;
         T3 = 2 * T1 + T0 * beta ;
         psb_iniA = (T3 - T2) / 2 ;
         psb_iniB = ln (T1 * T1 / T0 / cnst1bulk) / (beta + 2 / T1) ;
         if(psb_iniA < Pb2_bulk) begin
           phi_s0_bulk = psb_iniA ;
         end else begin
           `Fn_SU(phi_s0_bulk, psb_iniA, psb_iniB, `c_ps0ini_2, T1) 
         end
       end
                   
       // initial guess for phi_s0_bulk calculation(end) //
                   
       // newton loop for phi_s0_bulk(start) //
       T1 = sqrt(`cnst_2esi_q * phi_b_dep / `N_sub_SOI) ;
          
       if(WdSOI + T1 < `t_SOI) begin    // note that WdSOI=0 //
         for (lp_s0 = 0 ; lp_s0 < lp_s0_max ;  lp_s0 = lp_s0 + 1 ) begin
           T1 = cnst0bulk ;
           T2 = beta * phi_s0_bulk ;
           T3 = exp(-T2) ;
           if(phi_s0_bulk > `C_PHI_1_MINIMUM) begin
             T0 = exp(beta * phi_s0_bulk) ;
             T4 = -T1 * sqrt(T3 + T2 - 1 + cnst1bulk * (T0 - 1)) ;      //Qbulk
             T5 = c0bulk / T4 * (-T3 + 1 + cnst1bulk * (T0)) ;  //dQbulk_dPsb
           end else if(phi_s0_bulk < -`C_PHI_1_MINIMUM) begin
             T4 = T1 * sqrt(T3 + T2 - 1) ;      //Qbulk
             T5 = c0bulk / T4 * (-T3 + 1) ;     //dQbulk_dPsb
           end else begin
             T4 = -sqrt(c0bulk / beta) * beta * phi_s0_bulk ;   //Qbulk
             T5 = -sqrt(c0bulk * beta) ;        //dQbulk_dPsb
           end
           `Fn_SZ(T6, T4, 1e-10, T7) 
           `Fn_SU(T6, T6, (-Q_FD_SOI), 1e-13, T8) 
           T7 = T7 * ( T5 * T8 ) ;
           phi_b_dep = T6 * T6 / 2 / `C_ESI / `C_QE / `N_sub_SOI ;
           phi_b_dep_dPsb = 2 * phi_b_dep * T7 / T6 ;
                          
           T6 = phi_s0_bulk - ((-phi_s0_bulk + T4 / C_box - Vbsbiz + phi_b_dep)
              / (-1 + T5 / C_box + phi_b_dep_dPsb)) ;
           if(abs(T6 - phi_s0_bulk) < `ps_conv_ini) begin
             lp_s0 = lp_s0_max ;
           end 
           phi_s0_bulk = T6 ;
           Q_s0_bulk = T4 ;
         end
         phi_s0_bulk = Vbsbiz + phi_s0_bulk ;
         phi_b0_SOI = phi_s0_bulk - Q_s0_bulk / C_box ;
       end else begin
         for (lp_s0 = 0 ; lp_s0 < lp_s0_max ;  lp_s0 = lp_s0 + 1 ) begin
           T1 = cnst0bulk ;
           T2 = beta * phi_s0_bulk ;
           T3 = exp(-T2) ;
           if(phi_s0_bulk > `C_PHI_1_MINIMUM) begin
             T0 = exp(beta * phi_s0_bulk) ;
             T4 = -T1 * sqrt(T3 + T2 - 1 + cnst1bulk * (T0 - 1)) ;      //Qbulk
             T5 = c0bulk / T4 * (-T3 + 1 + cnst1bulk * (T0)) ;  //dQbulk_dPsb
           end else if(phi_s0_bulk < -`C_PHI_1_MINIMUM) begin
             T4 = T1 * sqrt(T3 + T2 - 1) ;      //Qbulk
             T5 = c0bulk / T4 * (-T3 + 1) ;     //dQbulk_dPsb
           end else begin
             T4 = -sqrt(c0bulk / beta) * beta * phi_s0_bulk ;   //Qbulk
             T5 = -sqrt(c0bulk * beta) ;        //dQbulk_dPsb
           end
           `Fn_SZ(T6, T4, 1e-10, T7) 
           `Fn_SU(T6, T6, (-Q_FD_SOI), 1e-13, T8) 
           T7 = T7 * ( T5 * T8 ) ;
           phi_b_dep = T6 * T6 / 2 / `C_ESI / `C_QE / `N_sub_SOI ;
           phi_b_dep_dPsb = 2 * phi_b_dep * T7 / T6 ;
                          
           T6 = phi_s0_bulk - (phi_s0_SOI - phi_s0_bulk + T4 / C_box +
              (T4 + Q_FD_SOI / 2) * `t_SOI / `C_ESI - Vbsbiz +
              phi_b_dep) / (-1 + T5 / C_box + T5 * `t_SOI / `C_ESI + phi_b_dep_dPsb) ;
           if(abs(T6 - phi_s0_bulk) < `ps_conv_ini) begin
             lp_s0 = lp_s0_max ;
           end
           phi_s0_bulk = T6 ;
           Q_s0_bulk = T4 ;
         end
         phi_s0_bulk = Vbsbiz + phi_s0_bulk ;
         phi_b0_SOI = phi_s0_bulk - Q_s0_bulk / C_box ;
       end
       // newton loop for phi_s0_bulk(end) //

       // Initial Guess for SOI Accumulation case(end). //

 end  // HSOTB_calc_ini_for_Accum

     end 

 begin : HSOTB_calc_ini_for_phi_s0_SOI
     //-----------------------------------------------------------*
     //* Initial guess for Ps0. (start)
     //*-----------------//

     //---------------------------------------------------*
     //* Ps0_iniA: solution of subthreshold equation assuming zone-D1/D2.
     //*-----------------//
     TX = 1.0e0 + 4.0e0 * ( beta * ( Vgpz - Vbs ) - 1.0e0 ) / ( fac1p2 * beta2 ) ;
     TX = `Fn_Max( TX , `epsm10 ) ;
     Ps0_iniA = Vgpz + fac1p2 * beta * 0.5 * ( 1.0e0 - sqrt( TX ) ) ;
                
     //---------------------------------------------------*
     //* Ps0_iniA: solution of subthreshold equation assuming zone-D1/D2.
     //*-----------------//
     if ( Vgs - shift <= Vth ) begin
       //-----------------------------------*
       //* Accumulation & Weak inversion zone.
       //*-----------------//
       T0 = 1 / C_fox ;
       T1 = `t_SOI / `C_ESI ;
       T2 = 1 / C_box ;
       T3 = 1 / (T0 + T1 + T2) ;
       T5 = (Ps0_iniA > 0.0) ? sqrt(`C_QE * `N_sub_SOI * 2 * `C_ESI * Ps0_iniA) : 0.0 ;
       T5 = `Fn_Min(Q_FD_SOI, T5) ;
       T4 = T3 * (Vgpz - Vbsbiz + (T2 + 0.5 * T1) * (-T5)) ;
       Ps0_iniA = Vgpz - T4 / C_fox ;
       Ps0_ini = Ps0_iniA ;
     end else begin
       T0 = 1 / C_fox ;
       T1 = `t_SOI / `C_ESI ;
       T2 = 1 / C_box ;
       T3 = 1 / (T0 + T1 + T2) ;
       T4 = T3 * (Vgpz - Vbsbiz + (T2 + 0.5 * T1) * (-Q_FD_SOI)) ;
       Ps0_iniA = Vgpz - T4 / C_fox ;
       Ps0_ini=Ps0_iniA;

       T1 = 1.0 / cnst1SOI / cnstC_foxi ;
       T2 = T1 * (Vgpz - shift) * (Vgpz - shift) ;
       T3 = beta + 2.0 / (Vgpz - shift) ;
       Ps0_iniB = ln (T2) / T3 ;
       `Fn_SU_CP(Ps0_ini, Ps0_iniA, Ps0_iniB * 0.98 , 0.5 , 2, T1) 
     end
     WdSOI = (Ps0_ini > 0.0) ? sqrt(`cnst_2esi_q * Ps0_ini / `N_sub_SOI) : 0.0 ;
     if(WdSOI < `t_SOI) begin 
       flg_depmode = 1 ; /* PD mode */
     end else begin 
       flg_depmode = 2 ; /* FD mode */
     end // End of FD    
     

     //---------------------------------------------------*
     //* Assign initial guess.
     //*-----------------//
     phi_s0_SOI = Ps0_ini ;
     Psl_lim = Ps0_iniA ;
             
     // Initial guess for Ps0. (end) //

 end  // HSOTB_calc_ini_for_phi_s0_SOI

 begin : HSOTB_calc_ini_for_phi_s0_bulk
     // initial guess for phi_s0_bulk. (start) //
     T0 = cnst0bulk * cnst0bulk * C_box_FD_inv * C_box_FD_inv ;
     if(flg_depmode == 1) begin 
       T1 = -(Vbsbiz) ;
       T2 = (2 * T1 + T0 * beta) * (2 * T1 + T0 * beta) - 4 * (T1 * T1 + T0) ;
       T2 = `Fn_Max(T2, `epsm10) ;
       T2 = sqrt(T2) ;
       T3 = 2 * T1 + T0 * beta ;
       psb_iniA = (T3 - T2) / 2 ;
       psb_iniB = ln (T1 * T1 / T0 / cnst1bulk) / (beta + 2 / T1) ;
       if(psb_iniA < Pb2_bulk) begin
         phi_s0_bulk = psb_iniA ;
       end else begin
         `Fn_SU(phi_s0_bulk, psb_iniA, psb_iniB, `c_ps0ini_2, T1) 
       end
     end else begin
       T1 = -(Vbsbiz - phi_s0_SOI - Q_FD_SOI / 2 * `t_SOI / `C_ESI) ;
       T2 = (2 * T1 + T0 * beta) * (2 * T1 + T0 * beta) - 4 * (T1 * T1 + T0) ;
       T2 = `Fn_Max(T2, `epsm10) ;
       T2 = sqrt(T2) ;
       T3 = 2 * T1 + T0 * beta ;
       psb_iniA = (T3 - T2) / 2 ;
       psb_iniB = ln (T1 * T1 / T0 / cnst1bulk) / (beta + 2 / T1) ;
       if(psb_iniA < Pb2_bulk) begin
         phi_s0_bulk = psb_iniA ;
       end else begin
         `Fn_SU(phi_s0_bulk, psb_iniA, psb_iniB, `c_ps0ini_2, T1) 
       end
     end

     // initial guess for phi_s0_bulk. (end) //
                 
     // newton loop for phi_s0_bulk(start) //
     if(flg_depmode == 1 && 0) begin 
       // PD case(start) //
       flg_depmode = 1 ;        // 20100528 //
       for (lp_s0 = 0 ; lp_s0 < lp_s0_max ;  lp_s0 = lp_s0 + 1 ) begin
         T1 = cnst0bulk ;
         T2 = beta * phi_s0_bulk ;
         T3 = exp(-T2) ;
         if(phi_s0_bulk > `C_PHI_1_MINIMUM) begin
           T0 = exp(beta * phi_s0_bulk) ;
           T4 = -T1 * sqrt(T3 + T2 - 1 + cnst1bulk * (T0 - 1)) ;        //Qbulk
           T5 = c0bulk / T4 * (-T3 + 1 + cnst1bulk * (T0)) ;    //dQbulk_dPsb
         end else if(phi_s0_bulk < -`C_PHI_1_MINIMUM) begin
           T4 = T1 * sqrt(T3 + T2 - 1) ;        //Qbulk
           T5 = c0bulk / T4 * (-T3 + 1) ;       //dQbulk_dPsb
         end else begin
           T4 = -sqrt(c0bulk / beta) * beta * phi_s0_bulk ;     //Qbulk
           T5 = -sqrt(c0bulk * beta) ;  //dQbulk_dPsb
         end
         T6 = (phi_s0_bulk -
            (-phi_s0_bulk + T4 / C_box - Vbsbiz) / (-1 + T5 / C_box)) ;
         if(abs(T6 - phi_s0_bulk) < `ps_conv_ini) begin
           T7 = lp_s0 ;
           lp_s0 = lp_s0_max ;
         end
         phi_s0_bulk = T6 ;
         Q_s0_bulk = T4 ;
       end
       phi_s0_bulk = Vbsbiz + phi_s0_bulk ;
       phi_b0_SOI = phi_s0_bulk - Q_s0_bulk / C_box ;
     end
     // PD case(end) //
     else begin
       // FD case(start) //
       flg_depmode = 2 ;        // 20100528 //
       for (lp_s0 = 0 ; lp_s0 < lp_s0_max ;  lp_s0 = lp_s0 + 1 ) begin
         T1 = cnst0bulk ;
         T2 = beta * phi_s0_bulk ;
         T3 = exp(-T2) ;
         if(phi_s0_bulk > `C_PHI_1_MINIMUM) begin
           T0 = exp(beta * phi_s0_bulk) ;
           T4 = -T1 * sqrt(T3 + T2 - 1 + cnst1bulk * (T0 - 1)) ;        //Qbulk
           T5 = c0bulk / T4 * (-T3 + 1 + cnst1bulk * T0) ;      //dQbulk_dPsb
         end else if(phi_s0_bulk < -`C_PHI_1_MINIMUM) begin
           T4 = T1 * sqrt(T3 + T2 - 1) ;        //Qbulk
           T5 = c0bulk / T4 * (-T3 + 1) ;       //dQbulk_dPsb
         end else begin
           T4 = -sqrt(c0bulk / beta) * beta * phi_s0_bulk ;     //Qbulk
           T5 = -sqrt(c0bulk * beta) ;  //dQbulk_dPsb
         end
         T6 = (phi_s0_bulk -
            (phi_s0_SOI - phi_s0_bulk + T4 / C_box + (T4 + Q_FD_SOI / 2) * `t_SOI / `C_ESI - Vbsbiz )
            / (-1 + T5 / C_box + T5 * `t_SOI / `C_ESI )) ;
         if(abs(T6 - phi_s0_bulk) < `ps_conv_ini) begin
           T7 = lp_s0 ;
           lp_s0 = lp_s0_max ;
         end
         phi_s0_bulk = T6 ;
         Q_s0_bulk = T4 ;
       end
       phi_s0_bulk = Vbsbiz + phi_s0_bulk ;
       phi_b0_SOI = phi_s0_bulk - Q_s0_bulk / C_box ;
     end
     // FD case(end) //
     // newton loop for phi_s0_bulk(end) //
                
 end  // HSOTB_calc_ini_for_phi_s0_bulk

         phi_b0_SOIP = phi_b0_SOI ;
       end // End of Initial guess for Ps0s
       //-----------------------------------------------------------*

       if(COISUB == 1 &&(Vgs > Vgs_fb + 0.2)) begin
         //---------------------------------------------------*
         //*  Floating Body Effect(FBE) ***
         //----------------//
         
         vfbsub1 = vfbsub0 ;
         Vgpsub = Vgsz - vfbsub1 + dVth - dPpg ;
         
         sti2_dlt = SUBDLT ;
         
         //---------------------------------------------------*
         //***  Simplified Isub Model for FBE
         //*-----------------//
         
         Vgssti = Vgpsub ;
         costi0 = sqrt(2.0e0 * `C_QE * `N_sub_SOI * `C_ESI / beta) ;
         costi1 = Nin * Nin / `N_sub_SOI / `N_sub_SOI ;
         costi3 = costi0 * costi0 / C_fox / C_fox ;
         costi4 = costi3 * beta / 2.0e0 ;
         costi5 = costi4 * beta * 2.0e0 ;
         costi6 = sqrt(1.0e0 + 4.0e0 * (beta * Vgssti - 1.0e0) / costi5) ;
         Psasti = Vgssti + costi4 * (1.0e0 - costi6) ;
         Asti = 1.0e0 / costi1 / costi3 ;
         Psbsti = ln (Asti * (Vgssti * Vgssti)) / (beta + 2.0e0 / Vgssti) ;
         Psab = Psbsti - Psasti - sti2_dlt ;
         Psti = Psbsti - 0.5e0 * (Psab + sqrt(Psab * Psab + 4.0e0 * sti2_dlt * Psbsti)) ;
         
         expsti = exp(beta * Psti) ;
         sq1sti = (beta * Psti - 1.0e0 + costi1 * expsti) ;
         sq2sti = (beta * Psti - 1.0e0) ;
         if(sq1sti > 0 && sq2sti > 0) begin
           sq1sti = sqrt(beta * Psti - 1.0e0 + costi1 * expsti) ;
           sq2sti = sqrt(beta * Psti - 1.0e0) ;
           Qn0sti = costi0 * (sq1sti - sq2sti) ;
           costi7 = 2.0e0 * Weff / beta ;
           Mu = 300.0 * `C_cm2m_p2;
           Lred = 0.0 ;
           T1 = -expm1(-beta * Vdsz) ;    // expm1(x) = exp(x) - 1 //
           Idssti = costi7 * Mu * Qn0sti * T1 / (Leff - Lred);
           Ids_isub = Idssti ;
           Ps0_isub = Psti ;
           
           //---------------------------------------------------*
           //* Pds calculation for Psl from HiSIM2 
           //*-----------------//
           TX = 1.0e0 + 4.0e0 * (beta * Vgpz - 1.0e0) / (fac1p2 * beta2) ;
           if( TX < `epsm10 ) begin
             TX = `epsm10 ;
           end
           Ps0_iniA = Vgpz + fac1p2 * beta * 0.5 * (1.0e0 - sqrt(TX)) ;
           Psl_lim = Ps0_iniA ;
           
           //---------------------------------------------------*
           //* Analytical initial guess.
           //*-----------------//
           Pds_max = Ps0_iniA - Ps0_isub ;
           if( Pds_max < 0.0e0 ) begin
             Pds_max = 0.0 ;
           end
           T5 = (1.0e0 + `c_pslini_1) * Pds_max ;
           T6 = T5 - Vdsz - `c_pslini_2 ;
           T7 = sqrt ( T6 *  T6 + 4.0 * ( T5 ) * ( `c_pslini_2 ) ) ;
           Pds_ini = ( T5 ) - 0.5 * ( T6 + T7 ) ;
           if(Pds_ini > Pds_max ) begin
             Pds_ini = Pds_max ;
           end
           Pds_qwe = Pds_ini ;
           
           begin : COIEVB_model
             real EVB1_QE_WL , EVB1_QE_WL_p_Egp12 , Eevb_wo_Vox ;
             real reali, realN, r, Vox, d0, T0, T1, T2, T3, T5, T6, T7, T8 ; 
             real CGS_Tfox0, CGS_weff_nf, CGS_Leff;

             CGS_Tfox0 = Tfox0 * `C_m2cm;
             CGS_weff_nf = weff_nf * `C_m2cm;
             CGS_Leff = Leff * `C_m2cm;
             //---------------------------------------------------*
             //* Ievb induced by Fowler-Nordheim tunneling and direct tunneling
             //*------------------//
             if(COIEVB == 0) begin
               Ievb = 0e0 ;
             end else begin
               phib = 4.12 ;
               // = sqrt( phib ) //
               // = phib^(3/2) //
               EVB1_QE_WL = EVB1 * `C_QE * CGS_weff_nf * CGS_Leff ;
               EVB1_QE_WL_p_Egp12 = EVB1_QE_WL / Egp12 ;
               Eevb_wo_Vox = -(FVBS * Vbsz + dVthSC + dVthLP + Eg + EVB3) / CGS_Tfox0 ;
               for (i = 0 ; i <= `N - 1 ; i= i + 1) begin
                 reali = i ;  realN = `N ; r =  reali / realN ;
                 Vox = Vgp + Vzadd - (Pds_qwe * r + Ps0_isub) ;
                 d0 = 1.0 - Vox / phib ;
                 
                 // T2 = Eevb //
                 T2 = Eevb_wo_Vox + Vox / CGS_Tfox0 ;
                 T0 = T2 * T2 ;
                 `Fn_SZtemp(d0, d0, 1.0e-3) 
                 T1 = EVB2 * (1.0 - sqrt(d0) * d0) ;
                 T3 = -T1 / T2 ;
                 if(T3 < `EXP_THRES_MIN) begin
                   T5 = 0.0 ;
                 end else begin
                   T5 = exp(T3) ;
                 end
                 T6 = EVB1_QE_WL_p_Egp12 ;
                 T7 = 0.25e0 * T6 * T1 * T1 * `c_exp_2 ;
                 if(2e0 * T2 + T1 < 0e0) begin
                   Ievb0 = T7 ;     // 0.25e0 * T6 * T1 * T1 * c_exp_2 ; // minimum value //
                 end else begin
                   T8 = EVB1_QE_WL * T0 * T5 ;
                   if(T8 < T7 || T2 < 0e0) begin
                     Ievb0 = T7 ;   // 0.25e0 * T6 * T1 * T1 * c_exp_2 ; // minimum value //
                   end else begin
                     Ievb0 = T8 ;
                   end
                 end
                 Ievb = Ievb + Ievb0 ; // = Ievb + Ievb_0 ; //
                 if( Ievb0 < `Ievb_min ) begin 
                   i = `N ;  // break
                   lp_s0 = lp_s0_max ;
                 end
               end
             end
           end // End of COIEVB_model
           
           //---------------------------------------------------------//
           
           //-------------------------------------------*
           //* Conductive case.
           //*-----------------//
           if( xsub1 <= 0.0 || Vmaxe <= 0.0) begin    // Nakagawa 2014.9.11
             Isub = 0.0 ;
           end else begin
             T1 = Vgpsub ;        //ina_fin //
             T7 = C_fox * C_fox ;
             T4 = 1.0 + (2.0 / qnsub_esi) * T7 ;
             T5 = T1 - beta_inv - `X_vbs * Vbsz ;
             T6 = T4 * T5 ;
             `Fn_SZ(T6, T6, 1.0e-3, T9) 
             T6 = T6 + `Small ;
             Psislsat = T1 * `X_vgs + (qnsub_esi / T7) * (1.0 - sqrt(T6)) ;
             Psisubsat = `X_vds * Vdsz + Ps0_isub - `X_slg * `Z_vgs * Psislsat ;  //ina_fin //
             `Fn_SZ(Psisubsat, Psisubsat, 1.0e-2, T9)     // @@@ //
             Psisubsat = Psisubsat + `Small ; // @@@ //
             T2 = exp(-`X_sub2 / Psisubsat) ;
             Isub = `X_sub1 * Psisubsat * Ids_isub * T2 ;
             
           end            // end of !if( sub1 < 0 || vmax < 0 )  //
           
           // @@@  Qh vs Isub Calculation //
           if(COFBE == 1) begin
             // The following values should not be hard-coded. //
             T1 = `C_QE * `t_SOI * weff_nf * exp(-beta * QHE2) ;  // Vbi => qhe2
             T2 = `Lp * `Dn * `Nd + `Ln * `Dp * `N_sub_SOI ;
             T4 = `Lp * `Ln / (T1 * T2) ;
             nume = (Isub + Ievb) * T4 ;
             T5 = QHE1 * beta_inv * log1p(nume) ; // qhe1 : fitting param
             
             // Qb(Vb=Vbody) - Qb(Vb=0) //
             T6 = sqrt(2 * `C_ESI * `C_QE * `N_sub_SOI * beta_inv) ;
             T7 = sqrt(expm1(-beta * (Ps0_isub - T5)) + beta * (Ps0_isub - T5)) ;
             T8 = sqrt(expm1(-beta * Ps0_isub) + beta * Ps0_isub) ;
             Qhs = -T6 * (T7 - T8) ;
             
             if(COHIST) begin
               Rsb = HIST1 / (Isub + HIST2) ;
               tauh = Rsb * C_fox ;
               Qhs_prev = Qhs ;
               Qhs_hist = `NQS_CAP * V(nqs_qhs) ;
               Qhs      =  Qhs_hist ;
               Iqh_nqs  = (Qhs_hist - Qhs_prev) / tauh ;
             end
             
           end else begin // Case for  W/O FBE //
             Qhs = 0 ;
           end
           
         end else begin   // sq1sti,sq2sti < 0 //
           Isub = 0.0 ;
           Qhs = 0 ;
         end
         
       end else begin     //  coisub==0 || Vgs > Vgs_fb + 0.2 //
         Isub = 0.0 ;
         Qhs = 0 ;
       end
       
       // End of Qh Calculation  //
       
       // start_of_s0_loop:

 begin : HSOTB_Eval_Solve_Ps0_flat_phiBP
     //-----------------------------------------------------------*
     //*  Solve Poisson's equation for Ps0. (start)
     //*-----------------//
     // save the initial guesses for nonconverged cases //
     phi_s0_SOI_ini = phi_s0_SOI ;
     phi_b0_SOI_ini = phi_b0_SOI ;
     phi_s0_bulk_ini = phi_s0_bulk - Vbsbiz ;

     flg_conv = 0 ;

     //  ***********************************************
     //  Solve core equations with 3D-Newton
     //  ***********************************************
     flg_fbcase = 0 ;

     scale_fac=1.0;
     T1_dPsb=0.0; T2_dPsb=0.0;

     // coefficients of smooth transition in PF2, PF3:
     if(TN < 4) begin
     // coefficients for TN=2:
     T1_gamma = Q_FD_SOI ;
     T2_gamma = -T1_gamma ;
     T1_alpha = 0.004832 / (Q_FD_SOI * Q_FD_SOI * Q_FD_SOI) ;
     T1_beta  = -3.7477 * Q_FD_SOI ;
     T1_delta =  4.3495 * Q_FD_SOI ;
     end else begin
     // coefficients for TN=4:
     T1_gamma = 1.5*Q_FD_SOI ;
     T2_gamma = -T1_gamma ;
     T1_alpha = 0.001765 / (Q_FD_SOI * Q_FD_SOI * Q_FD_SOI) ;
     T1_beta  = -4.8303 * Q_FD_SOI ;
     T1_delta =  5.9661 * Q_FD_SOI ; 
     end

     phi_b0_SOI  = phi_b0_SOI_ini ;
     phi_b0_SOIP_ini = phi_b0_SOI_ini ;
     phi_b0_SOIP = phi_b0_SOIP_ini ;
     
     //  ***************************
     //  Start of 3D-Newton loop
     //  ***************************
     phi_s0_bulk = phi_s0_bulk_ini ; //Case B was inconsistent.
     for (lp_s0 = 1 ; lp_s0 <= lp_s0_max ;  lp_s0 = lp_s0 + 1 ) begin
       flg_fbcase = 0 ;
       // step 1: calculate Q_bulk from Phi_bulk
       // Eval_calc_Q_s0_bulk(begin)
       T1 = phi_s0_bulk ; 
       e0 = beta * (T1) ;
       T0 = exp(-e0) ;
       if(T1 < -`C_PHI_1_MINIMUM) begin
         flg_fbcase = 1 ;
         T2 = exp(beta*(phi_s0_bulk)) ; 
         Q_s0_bulk = cnst0bulk * sqrt(T0 + e0 - 1.0 + cnst1bulk*(T2-1.0)) ; 
         Q_s0_bulk_dPsb = c0bulk * (-T0 + 1.0 + cnst1bulk*T2) / Q_s0_bulk ; 
       end else if(T1 > `C_PHI_1_MINIMUM/10.0) begin
           flg_fbcase = flg_fbcase + 3 ;
           T2 = exp(beta*(phi_s0_bulk)) ; 
           Q_s0_bulk = -cnst0bulk * sqrt(T0 + e0 - 1.0 + cnst1bulk*(T2-e0-1.0)) ;
           Q_s0_bulk_dPsb = c0bulk * (-T0 + 1.0 + cnst1bulk*(T2-1.0)) / Q_s0_bulk ;
       end else begin
         flg_fbcase = 2 ;
         Q_s0_bulk = -cnst0bulk* e0/sqrt(2.0) ;
         Q_s0_bulk_dPsb = -cnst0bulk *  beta/sqrt(2.0) ;
       end
       // Eval_calc_Q_s0_bulk(end)
                      
       // step 2: calculate Phi_b from eq. (2)
       //         phi_b0_SOI_dPsb = d Phi_b / d Phi_bulk
       phi_b0_SOI      = phi_s0_bulk - Q_s0_bulk / C_box +  Vbs + Vbi_SOI ; 
       phi_b0_SOI_dPsb =      1.0    - Q_s0_bulk_dPsb / C_box ;
                       
       // Now calculation of Q_s0_dep and Q_n0 for usage in PF1
                  
       // Eval_calc_Q_n0 (begin)
       T1 = phi_s0_SOI - phi_b0_SOIP ;
       e0 = beta * (T1) ;
       `EXP_LIMIT(T0, -e0, T6) 
       if(T1 < -`C_PHI_1_MINIMUM) begin
         flg_fbcase = flg_fbcase + 10 ;
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_s0_dep = cnst0SOI * T2 ;
         Q_s0_dep_dPss =   cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_s0_dep_dPbsP = - Q_s0_dep_dPss ;
         Q_n0 = 0.0 ;
         Q_n0_dPss = 0.0 ;
         Q_n0_dPbsP = 0.0 ;
       end else if(T1 > `C_PHI_1_MINIMUM/1.0) begin
         flg_fbcase = flg_fbcase + 30 ;
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_s0_dep = -cnst0SOI * T2 ;
         Q_s0_dep_dPss = -cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_s0_dep_dPbsP =  - Q_s0_dep_dPss ;
         T0 = exp(e0) ;
         T3 = exp(beta * phi_b0_SOIP) ;
         T4 = sqrt(Q_s0_dep * Q_s0_dep /(cnst0SOI * cnst0SOI) + 2 * cnst1SOI * T3 *(T0 - e0 - 1.0)) ;
         T4_dPss  = ( 2.0 * Q_s0_dep * Q_s0_dep_dPss  /(cnst0SOI * cnst0SOI) + 2 * beta * cnst1SOI * T3 * (T0 - 1.0) )/( 2 * T4 ) ;
         T4_dPbsP = ( 2.0 * Q_s0_dep * Q_s0_dep_dPbsP /(cnst0SOI * cnst0SOI) - 2 * beta * cnst1SOI * T3 * e0 )/( 2 * T4 ) ;
         Q_n0 = -cnst0SOI * T4 - Q_s0_dep ;
         Q_n0_dPss  = - cnst0SOI * T4_dPss - Q_s0_dep_dPss ;
         Q_n0_dPbsP = - cnst0SOI * T4_dPbsP - Q_s0_dep_dPbsP ;
       end else begin
         flg_fbcase = flg_fbcase + 20 ;
         Q_s0_dep = -cnst0SOI * e0 / sqrt(2.0) ;
         Q_s0_dep_dPss = -cnst0SOI *  beta / sqrt(2.0) ;        
         Q_s0_dep_dPbsP =  -Q_s0_dep_dPss ;     
         Q_n0 = 0.0 ;
         Q_n0_dPss = 0.0 ;
         Q_n0_dPbsP = 0.0 ;
       end
       // Eval_calc_Q_n0 (end)

       // Eval_calc_Q_b0 (begin)
       T1 = phi_b0_SOI - phi_b0_SOIP ;
       e0 = beta * (T1) ;
       `EXP_LIMIT(T0, -e0, T6) 
       if(T1 < -`C_PHI_1_MINIMUM) begin
         flg_fbcase = flg_fbcase + 100 ;
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_b0_dep = cnst0SOI * T2 ;
         Q_b0_dep_dPbs = cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_b0_dep_dPbsP = - Q_b0_dep_dPbs ;
         Q_b0 = 0.0 ;
         Q_b0_dPbs = 0.0 ;
         Q_b0_dPbsP = 0.0 ;
       end else if(T1 > `C_PHI_1_MINIMUM/1.0) begin
         flg_fbcase = flg_fbcase + 300 ;
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_b0_dep = -cnst0SOI * T2 ;
         Q_b0_dep_dPbs = -cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_b0_dep_dPbsP = - Q_b0_dep_dPbs ;
         T0 = exp(e0) ;
         T3 = exp(beta * phi_b0_SOIP) ;
         T4 = sqrt(Q_b0_dep * Q_b0_dep /(cnst0SOI * cnst0SOI) + 2 * cnst1SOI * T3 * (T0 - e0 - 1.0)) ;
         T4_dPbs = ( 2.0 * Q_b0_dep * Q_b0_dep_dPbs /(cnst0SOI * cnst0SOI)  + 2 * beta * cnst1SOI * T3 * (T0 - 1.0) )/( 2 * T4 ) ;
         T4_dPbsP = ( 2.0 * Q_b0_dep * Q_b0_dep_dPbsP /(cnst0SOI * cnst0SOI) - 2 * beta * cnst1SOI * T3 * e0)/( 2 * T4 ) ;
         Q_b0 = -cnst0SOI * T4 - Q_b0_dep ;
         Q_b0_dPbs  = - cnst0SOI * T4_dPbs - Q_b0_dep_dPbs ;
         Q_b0_dPbsP = - cnst0SOI * T4_dPbsP - Q_b0_dep_dPbsP ;
       end else begin
         flg_fbcase = flg_fbcase + 200 ;
         Q_b0_dep = -cnst0SOI * e0 / sqrt(2.0) ;
         Q_b0_dep_dPbs = -cnst0SOI *  beta / sqrt(2.0) ;
         Q_b0_dep_dPbsP = - Q_b0_dep_dPbs ;     
         Q_b0 = 0.0 ;
         Q_b0_dPbs = 0.0 ;
         Q_b0_dPbsP = 0.0 ;
       end
       // Eval_calc_Q_b0 (end)
                     
       if(flg_conv == 1) begin
         flg_brk10 = lp_s0 ; // break
         lp_s0 = lp_s0_max ;
       end else begin
         // step 6: calculate PF1  = eq. (1)
         //                   PF2  = eq. (3)
         //                   PF3  = eq. (4)
         //         and       PFx1 = d PFx / d Phi_s
         //                   PFx2 = d PFx / d Phi_b'
         //                   PFx3 = d PFx / d Phi_bulk + d PF1 / d Phi_b * d Phi_b / d Phi_bulk
         //                   x = {1,2,3}
         //         no case distinction any more
         PF1  = phi_s0_SOI - Vgpz - (Q_s0_bulk + Q_n0 + Q_s0_dep + Q_b0 + Q_b0_dep + Qhs) / C_fox ;
         PF11 = 1.0 - (Q_n0_dPss + Q_s0_dep_dPss) / C_fox ;
         PF12 =     - (Q_n0_dPbsP + Q_s0_dep_dPbsP + Q_b0_dPbsP + Q_b0_dep_dPbsP) / C_fox ;
         PF13 = - (Q_s0_bulk_dPsb + (Q_b0_dPbs+Q_b0_dep_dPbs) * phi_b0_SOI_dPsb) / C_fox ;
         if(Q_s0_bulk <= T1_gamma) begin
           pfi_case = 0.1 ;
           T1 = sqrt(Q_FD_SOI*(2.0*Q_s0_bulk + Q_FD_SOI)) ;
           T1_dPsb = Q_FD_SOI*Q_s0_bulk_dPsb/T1 ;
         end else if(Q_s0_bulk <= T1_beta) begin
           pfi_case = 0.2 ;
           T1 = T1_alpha*(Q_s0_bulk-T1_beta)*(Q_s0_bulk-T1_beta)*(Q_s0_bulk-T1_beta)*(Q_s0_bulk-T1_delta);
           T1_dPsb = T1_alpha*(Q_s0_bulk-T1_beta)*(Q_s0_bulk-T1_beta)*(3.0*(Q_s0_bulk-T1_delta)+(Q_s0_bulk-T1_beta))*Q_s0_bulk_dPsb;
         end else begin
           pfi_case = 0.3 ;
           T1 = 0.0 ;
           T1_dPsb = 0.0 ;
         end
         PF2  = (Q_s0_dep + T1)/C_soi ;
         PF21 = Q_s0_dep_dPss/C_soi ;
         PF22 = Q_s0_dep_dPbsP/C_soi ;
         PF23 = T1_dPsb/C_soi ;

         T3 = -Q_s0_bulk/Q_FD_SOI ;
         `Fn_Sigmoidx( T2 , T3 , T0 )
         T2 = T2 * T2_gamma ;
         T2_dPsb = -Q_s0_bulk_dPsb/Q_FD_SOI * T0 * T2_gamma ;
         PF3  = (Q_b0_dep+T2)/C_soi ;
         PF32 = (Q_b0_dep_dPbsP)/C_soi ;
         PF33 = (Q_b0_dep_dPbs*phi_b0_SOI_dPsb + T2_dPsb)/C_soi ;

         // step 9: calculate Newton correction(dPsb ;dPbsP ;dPbs) for(Phi_s ;Phi_b' ;Phi_bulk)
         PDJ = PF11 * PF22 * PF33 - PF11 * PF23 * PF32 - PF12 * PF21 * PF33 + PF13 * PF21 * PF32 ;
         if( PDJ > 0.0 ) begin
           PDJI = 1.0 / (PDJ + `Small) ;
         end else begin
           PDJI = 1.0 / (PDJ - `Small) ;
         end
         PJI11 = PF22 * PF33 - PF23 * PF32 ;
         PJI12 = PF13 * PF32 - PF12 * PF33 ;
         PJI13 = PF12 * PF23 - PF13 * PF22 ;
         PJI21 = - PF21 * PF33 ;
         PJI22 = PF11 * PF33 ;
         PJI23 = PF13 * PF21 - PF11 * PF23 ;
         PJI31 = PF21 * PF32 ;
         PJI32 = - PF11 * PF32 ;
         PJI33 = PF11 * PF22 - PF12 * PF21 ;
   
         dPss  = -PDJI * (PJI11 * PF1 + PJI12 * PF2 + PJI13 * PF3) ;
         dPbsP = -PDJI * (PJI21 * PF1 + PJI22 * PF2 + PJI23 * PF3) ;
         dPsb  = -PDJI * (PJI31 * PF1 + PJI32 * PF2 + PJI33 * PF3) ;
         T1 = abs(dPss) ;
         if (T1 < abs(dPbsP)) T1 = abs(dPbsP) ;
         if (T1 < abs(dPsb) ) T1 = abs(dPsb ) ;
            scale_fac=1.0 ;
         if(lp_s0 > 80) begin
            scale_fac = 125.0 ;
         end else if(lp_s0 > 40) begin
            scale_fac = 125.0 ;
         end else if(lp_s0 > 20) begin
            scale_fac = 25.0 ;
         end else if(lp_s0 > 10) begin
            scale_fac = 5.0 ;
         end
                    
         if(T1 > `dP_max/scale_fac) begin
            dPss  = dPss * ( `dP_max/scale_fac / T1 ) ;
            dPbsP = dPbsP * ( `dP_max/scale_fac / T1 ) ;
            dPsb  = dPsb * ( `dP_max/scale_fac / T1 ) ;
         end
   
         phi_s0_SOI = phi_s0_SOI + dPss ;
         phi_b0_SOIP = phi_b0_SOIP + dPbsP ;
         phi_s0_bulk = phi_s0_bulk + dPsb ;
                      
         PSCONV_3D = `ps_conv * scale_fac ;
         if(T1 < PSCONV_3D) begin
            flg_conv = 1 ;
         end
       end 
     end
     if(flg_brk10 > 0) begin lp_s0 = flg_brk10; flg_brk10 = 0; end 
     //  ******************************                 
     //  end of 3D-Newton loop
     //  ******************************
              
     if(lp_s0 > lp_s0_max) begin        // reset to the initial guesses in nonconvergent cases //
       phi_s0_SOI = phi_s0_SOI_ini ;
       phi_b0_SOI = phi_b0_SOI_ini ;
       phi_s0_bulk = phi_s0_bulk_ini ;
       phi_b0_SOIP = phi_b0_SOIP_ini ;
     end
//   pfi_case_0 = pfi_case ;

     //-------------------------------------------*
     //Procedure for diverged case.
     //----------------//
     if(lp_s0 > lp_s0_max) begin
       $write("*** warning(HiSIM_SOTB): Went Over Iteration Maximum (%M:Ps0): \n") ;
       $write("Vgs  %e  Vds %e   Vbs  %e   ", Vgs, Vds, Vbs) ;
       $write("Vgsc %e  Vdsc %e  Vbsc %e   ", Vgsc, Vdsc, Vbsc) ;
       $write("Ids %e   ", Ids) ;
       $write("\n") ;
     end

     //  ***********************************************
     //  End of 3D-Newton code
     //  ***********************************************

 end // HSOTB_Eval_Solve_Ps0_flat_phiBP

`ifdef DISABLE_COPPRV
`else
       flg_conv_0 = flg_conv ;
`endif
       
       Ps0 = phi_s0_SOI ;
       Qn0 = -Q_n0 ;
       if(Qn0 <= `Small) begin
         Qn0 = `Small ;
         flg_noqi = 1 ;
       end
       Qb0 = -Q_b0 ;
       if(Qb0 <= `Small) begin
         Qb0 = `Small ;
       end
       
       
       
       //---------------------------------------------------*
       //    VgVt : Vgp - Vth_qi. ( Vth_qi is Vth for Qi evaluation. )
       //    ----------------//
       VgVt = Qn0 * C_fox_inv ;
       
       
       // @@@ //
       // Vdseff(begin) //
       Vdsorg = Vds ;
       T2 = qnsub_esi / (C_fox * C_fox) ;
       T0 = Vgpz - beta_inv ;
       T9 = 1.0e0 + 2.0e0 / T2 * T0 ;
       `Fn_SZ(T9, T9, 5e-2, T6) 
       T3 = sqrt(T9) ;
       T10 = Vgpz + T2 * (1.0e0 - T3) ;
       `Fn_SZ(T10, T10, 0.01, T0) 
       Vdsat = T10 ;
       T1 = Vds / Vdsat + `Small ;
       T2 = `Fn_Pow(T1, DDLTe - 1.0e0) ;
       T3 = 1.0 + T2 * T1 ;
       T4 = `Fn_Pow(T3, 1.0 / DDLTe - 1.0) ;
       T6 = T4 * T3 ;
       Vdseff = Vds / T6 ;
       Vds = Vdseff  ;
       // Vdseff(end) //
       
       //---------------------------------------------------*
       //* Skip Psl calculation when Vds is very Small.
       //*-----------------//
       if(Vds < 0.0) begin
         Psl = Ps0 ;
         Pds = Psl - Ps0 ;
         phi_sL_SOI = Psl ;
         phi_bL_SOI = phi_b0_SOI ;
         phi_bL_SOIP= phi_b0_SOIP;
         phi_sL_bulk = phi_s0_bulk ;
         flg_conv = 1 ;
       end else begin
         
         //-----------------------------------------------------------*
         //* Initial Guess for Drain Side.
         //*-----------------//
         if( flg_pprv >= 1 || VgVt < `VgVt_Small ) begin
           phi_sL_SOI  = Pssl_ini ;
           phi_bL_SOI  = Pbsl_ini ;
           phi_sL_bulk = Psbl_ini +  Vbsbiz ;
         end else begin
           
           //-----------------------------------------------------------*
           //* Initial guess of  Psl(start)
           //*-----------------//
           
           //---------------------------------------------------*
           //* Analytical initial guess.
           //*-----------------//
           Pds_max = `Fn_Max(Psl_lim - phi_s0_SOI, 0.0) ;
           `Fn_SU(Pds_ini, Vds, (1.0e0 + `c_pslini_1*0.5) * Pds_max, `c_pslini_2, T1) 
           Pds_ini = `Fn_Min(Pds_ini, Pds_max) ;
           if(Pds_ini < 0.0) begin
             Pds_ini = 0.0 ;
           end else begin
             if(Pds_ini > Vds) Pds_ini = Vds ;
           end
           
           //---------------------------------------------------*
           //* Assign initial guess.
           //*-----------------//
           Pds = Pds_ini ;
           Psl = phi_s0_SOI + Pds ;
           TX = `ps_conv / 2 ;
           if(Psl < TX) Psl = TX ;
           phi_sL_SOI = Psl ;
           phi_sL_SOI = ( flg_zone == -1 ) ? phi_s0_SOI : Psl ;
           
           // Initial guess of  Psl(end) //
           
           //-----------------------------------------------------------*
           //* Initial guess of  phi_sL_bulk(start)
           //*-----------------//
           
           // initial value for phi_sL_bulk(start) //
           T0 = cnst0bulk * cnst0bulk * C_box_FD_inv * C_box_FD_inv ;
           if(phi_sL_SOI < FD_end) begin
             T1 = -(Vbsbiz) ;
             T2 = (2 * T1 + T0 * beta) * (2 * T1 + T0 * beta) - 4 * (T1 * T1 + T0) ;
             T2 = `Fn_Max(T2, `epsm10) ;
             psb_iniA = (2 * T1 + T0 * beta - sqrt(T2)) / 2 ;
             psb_iniB = ln (T1 * T1 / T0 / cnst1bulk) / (beta + 2 / T1) ;
             if(psb_iniA < Pb2_bulk) begin
               phi_sL_bulk = psb_iniA ;
             end else begin
               `Fn_SU(phi_sL_bulk, psb_iniA, psb_iniB, `c_ps0ini_2, T1) 
             end
           end else begin
             T1 = -(Vbsbiz - phi_sL_SOI - Q_FD_SOI / 2 * C_soi_inv) ;
             T2 = (2 * T1 + T0 * beta) * (2 * T1 + T0 * beta) - 4 * (T1 * T1 + T0) ;
             T2 = `Fn_Max(T2, `epsm10) ;
             psb_iniA = (2 * T1 + T0 * beta - sqrt(T2)) / 2 ;
             psb_iniB = ln (T1 * T1 / T0 / cnst1bulk) / (beta + 2 / T1) ;
             if(psb_iniA < Pb2_bulk) begin
               phi_sL_bulk = psb_iniA ;
             end else begin
               `Fn_SU(phi_sL_bulk, psb_iniA, psb_iniB, `c_ps0ini_2, T1) 
             end
           end
           // initial value for phi_sL_bulk(end) //
           
           // newton loop for phi_sL_bulk(start) //
           if(phi_sL_SOI < FD_end && 0) begin
             for (lp_sl = 0 ; lp_sl < lp_sl_max ; lp_sl= lp_sl + 1) begin
               T2 = beta * phi_sL_bulk ;
               T3 = exp(-T2) ;
               if(phi_sL_bulk > `C_PHI_1_MINIMUM) begin
                 T0 = exp(beta * phi_sL_bulk) ;
                 T4 = -cnst0bulk * sqrt(T3 + T2 - 1 + cnst1bulk * (T0 - 1)) ;        //Qbulk
                 T5 = c0bulk / T4 * (-T3 + 1 + cnst1bulk * (T0)) ;    //dQbulk_dPsb
               end else if(phi_sL_bulk < -`C_PHI_1_MINIMUM) begin
                 T4 = cnst0bulk * sqrt(T3 + T2 - 1) ;        //Qbulk
                 T5 = c0bulk / T4 * (-T3 + 1) ;       //dQbulk_dPsb
               end else begin
                 T4 = -sqrt(c0bulk / beta) * beta * phi_sL_bulk ;     //Qbulk
                 T5 = -sqrt(c0bulk * beta) ;  //dQbulk_dPsb
               end
               `Fn_SZ(T6, T4, 1e-6 , T7) 
               `Fn_SU(T6, T6, (-Q_FD_SOI), 1e-9 , T8) 
               T7 = T7 * ( T5 * T8 ) ;
               phi_b_dep = T6 * T6 / 2 / `C_ESI / `C_QE / `N_sub_SOI ;
               phi_b_dep_dPsb = 2 * phi_b_dep * T7 / T6 ;
               
               T6 = phi_sL_bulk - ((-phi_sL_bulk + T4 / C_box - Vbsbiz + phi_b_dep)
               / (-1 + T5 / C_box + phi_b_dep_dPsb)) ;
               if(abs(T6 - phi_sL_bulk) < `ps_conv) begin
                 lp_sl = lp_sl_max ;
               end
               phi_sL_bulk = T6 ;
               Q_sL_bulk = T4 ;
             end
             phi_sL_bulk = Vbsbiz + phi_sL_bulk ;
             phi_bL_SOI = phi_sL_bulk - Q_sL_bulk / C_box ;
           end else begin
             for (lp_sl = 0 ; lp_sl < lp_sl_max ; lp_sl= lp_sl + 1) begin
               T1 = cnst0bulk ;
               T2 = beta * phi_sL_bulk ;
               T3 = exp(-T2) ;
               if(phi_sL_bulk > `C_PHI_1_MINIMUM) begin
                 T0 = exp(beta * phi_sL_bulk) ;
                 T4 = -T1 * sqrt(T3 + T2 - 1 + cnst1bulk * (T0 - 1)) ;        //Qbulk
                 T5 = c0bulk / T4 * (-T3 + 1 + cnst1bulk * (T0)) ;    //dQbulk_dPsb
               end else if(phi_sL_bulk < -`C_PHI_1_MINIMUM) begin
                 T4 = T1 * sqrt(T3 + T2 - 1) ;        //Qbulk
                 T5 = c0bulk / T4 * (-T3 + 1) ;       //dQbulk_dPsb
               end else begin
                 T4 = -sqrt(c0bulk / beta) * beta * phi_sL_bulk ;     //Qbulk
                 T5 = -sqrt(c0bulk * beta) ;  //dQbulk_dPsb
               end
               `Fn_SZ(T6, T4, 1e-6 , T7) 
               `Fn_SU(T6, T6, (-Q_FD_SOI), 1e-9 , T8) 
               T7 = T7 * ( T5 * T8 ) ;
               phi_b_dep = T6 * T6 / 2 / `C_ESI / `C_QE / `N_sub_SOI ;
               phi_b_dep_dPsb = 2 * phi_b_dep * T7 / T6 ;
               
               T6 = (phi_sL_bulk -
               (phi_sL_SOI - phi_sL_bulk + T4 / C_box + (T4 + Q_FD_SOI / 2) * C_soi_inv - Vbsbiz +
               phi_b_dep) / (-1 + T5 / C_box + T5 * C_soi_inv + phi_b_dep_dPsb)) ;
               if(abs(T6 - phi_sL_bulk) < `ps_conv) begin
                 lp_sl = lp_sl_max ;
               end
               phi_sL_bulk = T6 ;
               Q_sL_bulk = T4 ;
             end
             phi_sL_bulk = Vbsbiz + phi_sL_bulk ;
             phi_bL_SOI = phi_sL_bulk - Q_sL_bulk / C_box ;
           end
           // if(phi_bL_SOI < 0) begin
           //   phi_bL_SOI = 0 ;
           // end  //miyamoto
           phi_bL_SOIP = phi_bL_SOI ;
           // newton loop for phi_sL_bulk(end) //
           
           // Initial guess of phi_sL_bulk(end) //
           
         end // End of Initial guess For Psls
         //-----------------------------------------------------------*
         
       end // start_of_loopl 

//  flg_fbcase_0 = flg_fbcase ;

 begin : HSOTB_Eval_Solve_Psl_flat_phiBP
     //-----------------------------------------------------------*
     //*  Solve Poisson's equation for Psl. (start)
     //*-----------------//
     // save the initial guesses for nonconverged cases //
     if ( VgVt < `VgVt_Small ) begin
       phi_sL_SOI_ini  = phi_s0_SOI ;
       phi_bL_SOI_ini  = phi_b0_SOI ;
       phi_sL_bulk_ini = phi_s0_bulk ;
       phi_bL_SOIP_ini = phi_b0_SOIP ;
     end else begin
       phi_sL_SOI_ini  = phi_sL_SOI ;
       phi_bL_SOI_ini  = phi_bL_SOI ;
       phi_sL_bulk_ini = phi_sL_bulk - Vbsbiz ;
       phi_bL_SOIP_ini = (phi_bL_SOI_ini < phi_sL_SOI_ini) ? phi_bL_SOI_ini : phi_sL_SOI_ini;
     end

     flg_conv = (flg_zone < 0) ? 1 : 0 ;

     //  ***********************************************
     //  Solve core equations with 3D-Newton
     //  ***********************************************
     flg_fbcase = 0 ;
     phi_sL_SOI = phi_sL_SOI_ini ;
     phi_bL_SOI = phi_bL_SOI_ini ;
     phi_sL_bulk = phi_sL_bulk_ini ;
     phi_bL_SOIP = phi_bL_SOIP_ini ;

     //  ***************************
     //  Start of 3D-Newton loop
     //  ***************************
     for (lp_sl = 1 ; lp_sl <= lp_sl_max ;  lp_sl = lp_sl + 1 ) begin
       flg_fbcase = 0 ;
       // step 1: calculate Q_bulk from Phi_bulk
       // Eval_calc_Q_sL_bulk(begin)
       T1 = phi_sL_bulk ; 
       e0 = beta * (T1) ;
       T0 = exp(-e0) ;
       if(T1 < -`C_PHI_1_MINIMUM) begin
         flg_fbcase = 1 ;
         T2 = exp(beta*(phi_sL_bulk)) ; 
         Q_sL_bulk = cnst0bulk * sqrt(T0 + e0 - 1.0 + cnst1bulk*(T2-1.0)) ; 
         Q_sL_bulk_dPsb = c0bulk * (-T0 + 1.0 + cnst1bulk*T2) / Q_sL_bulk ; 
       end else if(T1 > `C_PHI_1_MINIMUM/10.0) begin
         flg_fbcase = flg_fbcase + 3 ;
         T2 = exp(beta*(phi_sL_bulk)) ; 
         Q_sL_bulk = -cnst0bulk * sqrt(T0 + e0 - 1.0 + cnst1bulk*(T2-e0-1.0)) ;
         Q_sL_bulk_dPsb = c0bulk * (-T0 + 1.0 + cnst1bulk*(T2-1.0)) / Q_sL_bulk ;
       end else begin
         flg_fbcase = 2 ;
         Q_sL_bulk = -cnst0bulk* e0/sqrt(2.0) ;
         Q_sL_bulk_dPsb = -cnst0bulk *  beta/sqrt(2.0) ;
       end
       // Eval_calc_Q_sL_bulk(end)
                      
       // step 2: calculate Phi_b from eq. (2)
       //         phi_bL_SOI_dPsb = d Phi_b / d Phi_bulk
       pfi_case = 0 ;
       phi_bL_SOI      = phi_sL_bulk - Q_sL_bulk / C_box +  Vbs + Vbi_SOI ; 
       phi_bL_SOI_dPsb =      1.0    - Q_sL_bulk_dPsb / C_box ;
                       
       // Now calculation of Q_sL_dep and Q_nL for usage in PF1
       
       // Eval_calc_Q_nL (begin)
       T1 = phi_sL_SOI - phi_bL_SOIP ;
       e0 = beta * (T1) ;
       `EXP_LIMIT(T0, -e0, T6) 
       if(T1 < -`C_PHI_1_MINIMUM) begin
         flg_fbcase = flg_fbcase + 10 ;
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_sL_dep = cnst0SOI * T2 ;
         Q_sL_dep_dPss =   cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_sL_dep_dPbsP = - Q_sL_dep_dPss ;
         Q_nL = 0.0 ;
         Q_nL_dPss = 0.0 ;
         Q_nL_dPbsP = 0.0 ;
       end else if(T1 > `C_PHI_1_MINIMUM/1.0) begin
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_sL_dep = -cnst0SOI * T2 ;
         Q_sL_dep_dPss = -cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_sL_dep_dPbsP =  - Q_sL_dep_dPss ;
         T0 = exp(e0) ;
         T3 = exp(beta * (phi_bL_SOIP - Vds)) ;
         flg_fbcase = flg_fbcase + 30 ;
         T4 = sqrt(Q_sL_dep * Q_sL_dep /(cnst0SOI * cnst0SOI) + 2 * cnst1SOI * T3 * (T0 - e0 - 1.0)) ;
         T4_dPss  = ( 2.0 * Q_sL_dep * Q_sL_dep_dPss  /(cnst0SOI * cnst0SOI) + 2 * beta * cnst1SOI * T3 * (T0 - 1.0) )/( 2 * T4 ) ;
         T4_dPbsP = ( 2.0 * Q_sL_dep * Q_sL_dep_dPbsP /(cnst0SOI * cnst0SOI) - 2 * beta * cnst1SOI * T3 * e0 )/( 2 * T4 ) ;
         Q_nL = -cnst0SOI * T4 - Q_sL_dep ;
         Q_nL_dPss  = - cnst0SOI * T4_dPss - Q_sL_dep_dPss ;
         Q_nL_dPbsP = - cnst0SOI * T4_dPbsP - Q_sL_dep_dPbsP ;
       end else begin
         flg_fbcase = flg_fbcase + 20 ;
         Q_sL_dep = -cnst0SOI * e0 / sqrt(2.0) ;
         Q_sL_dep_dPss = -cnst0SOI *  beta / sqrt(2.0) ;        
         Q_sL_dep_dPbsP =  -Q_sL_dep_dPss ;     
         Q_nL = 0.0 ;
         Q_nL_dPss = 0.0 ;
         Q_nL_dPbsP = 0.0 ;
       end
       // Eval_calc_Q_nL (end)

       // Eval_calc_Q_bL (begin)
       T1 = phi_bL_SOI - phi_bL_SOIP ;
       e0 = beta * (T1) ;
       `EXP_LIMIT(T0, -e0, T6) 
       if(T1 < -`C_PHI_1_MINIMUM) begin
         flg_fbcase = flg_fbcase + 100 ;
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_bL_dep = cnst0SOI * T2 ;
         Q_bL_dep_dPbs = cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_bL_dep_dPbsP = - Q_bL_dep_dPbs ;
         Q_bL = 0.0 ;
         Q_bL_dPbs = 0.0 ;
         Q_bL_dPbsP = 0.0 ;
       end else if(T1 > `C_PHI_1_MINIMUM/1.0) begin
         T2 = sqrt(T0 + e0 - 1.0) ;
         Q_bL_dep = -cnst0SOI * T2 ;
         Q_bL_dep_dPbs = -cnst0SOI * beta * (-T6 + 1.0) / (2 * T2) ;
         Q_bL_dep_dPbsP = - Q_bL_dep_dPbs ;
         T0 = exp(e0) ;
         T3 = exp(beta * (phi_bL_SOIP - Vds)) ;
         flg_fbcase = flg_fbcase + 300 ;
         T4 = sqrt(Q_bL_dep * Q_bL_dep /(cnst0SOI * cnst0SOI) + 2 * cnst1SOI * T3 * (T0 - e0 - 1.0)) ;
         T4_dPbs = ( 2.0 * Q_bL_dep * Q_bL_dep_dPbs /(cnst0SOI * cnst0SOI)  + 2 * beta * cnst1SOI * T3 * (T0 - 1.0) )/( 2 * T4 ) ;
         T4_dPbsP = ( 2.0 * Q_bL_dep * Q_bL_dep_dPbsP /(cnst0SOI * cnst0SOI) - 2 * beta * cnst1SOI * T3 * e0 )/( 2 * T4 ) ;
         Q_bL = -cnst0SOI * T4 - Q_bL_dep ;
         Q_bL_dPbs  = - cnst0SOI * T4_dPbs - Q_bL_dep_dPbs ;
         Q_bL_dPbsP = - cnst0SOI * T4_dPbsP - Q_bL_dep_dPbsP ;
       end else begin
         flg_fbcase = flg_fbcase + 200 ;
         Q_bL_dep = -cnst0SOI * e0 / sqrt(2.0) ;
         Q_bL_dep_dPbs = -cnst0SOI *  beta / sqrt(2.0) ;
         Q_bL_dep_dPbsP = - Q_bL_dep_dPbs ;     
         Q_bL = 0.0 ;
         Q_bL_dPbs = 0.0 ;
         Q_bL_dPbsP = 0.0 ;
       end
       // Eval_calc_Q_bL (end)
                     
       if(flg_conv == 1) begin
         flg_brk10 = lp_sl; // break
         lp_sl = lp_sl_max ;
       end else begin
         // step 6: calculate PF1  = eq. (1)
         //                   PF2  = eq. (3)
         //                   PF3  = eq. (4)
         //         and       PFx1 = d PFx / d Phi_s
         //                   PFx2 = d PFx / d Phi_b'
         //                   PFx3 = d PFx / d Phi_bulk + d PF1 / d Phi_b * d Phi_b / d Phi_bulk
         //                   x = {1,2,3}
         //         no case distinction any more
         pfi_case = pfi_case + 0.1 ;
         PF1  = phi_sL_SOI - Vgpz - (Q_sL_bulk + Q_nL + Q_sL_dep + Q_bL + Q_bL_dep + Qhs) / C_fox ;
         PF11 = 1.0 - (Q_nL_dPss + Q_sL_dep_dPss) / C_fox ;
         PF12 =     - (Q_nL_dPbsP + Q_sL_dep_dPbsP + Q_bL_dPbsP + Q_bL_dep_dPbsP) / C_fox ;
         PF13 = - (Q_sL_bulk_dPsb + (Q_bL_dPbs+Q_bL_dep_dPbs) * phi_bL_SOI_dPsb) / C_fox ;
         if(Q_sL_bulk <= T1_gamma) begin
           T1 = sqrt(Q_FD_SOI*(2.0*Q_sL_bulk + Q_FD_SOI)) ;
           T1_dPsb = Q_FD_SOI*Q_sL_bulk_dPsb/T1 ;
         end else if(Q_sL_bulk <= T1_beta) begin
           T1 = T1_alpha*(Q_sL_bulk-T1_beta)*(Q_sL_bulk-T1_beta)*(Q_sL_bulk-T1_beta)*(Q_sL_bulk-T1_delta);
           T1_dPsb = T1_alpha*(Q_sL_bulk-T1_beta)*(Q_sL_bulk-T1_beta)*(3.0*(Q_sL_bulk-T1_delta)+(Q_sL_bulk-T1_beta))*Q_sL_bulk_dPsb;
         end else begin
           T1 = 0.0 ;
           T1_dPsb = 0.0 ;
         end
         PF2  = (Q_sL_dep + T1)/C_soi ;
         PF21 = Q_sL_dep_dPss/C_soi ;
         PF22 = Q_sL_dep_dPbsP/C_soi ;
         PF23 = T1_dPsb/C_soi ;

         T3 = -Q_sL_bulk/Q_FD_SOI ;
         `Fn_Sigmoidx( T2 , T3 , T0 )
         T2 = T2 * T2_gamma ;
         T2_dPsb = -Q_sL_bulk_dPsb/Q_FD_SOI * T0 * T2_gamma  ;
         PF3  = (Q_bL_dep+T2)/C_soi ;
         PF32 = (Q_bL_dep_dPbsP)/C_soi ;
         PF33 = (Q_bL_dep_dPbs*phi_bL_SOI_dPsb + T2_dPsb)/C_soi ;

         // step 9: calculate Newton correction(dPsb ;dPbsP ;dPbs) for(Phi_s ;Phi_b' ;Phi_bulk)
         PDJ = PF11 * PF22 * PF33 - PF11 * PF23 * PF32 - PF12 * PF21 * PF33 + PF13 * PF21 * PF32 ;
         if( PDJ > 0.0 ) begin
           PDJI = 1.0 / (PDJ + `Small) ;
         end else begin
           PDJI = 1.0 / (PDJ - `Small) ;
         end
         PJI11 = PF22 * PF33 - PF23 * PF32 ;
         PJI12 = PF13 * PF32 - PF12 * PF33 ;
         PJI13 = PF12 * PF23 - PF13 * PF22 ;
         PJI21 = - PF21 * PF33 ;
         PJI22 = PF11 * PF33 ;
         PJI23 = PF13 * PF21 - PF11 * PF23 ;
         PJI31 = PF21 * PF32 ;
         PJI32 = - PF11 * PF32 ;
         PJI33 = PF11 * PF22 - PF12 * PF21 ;
   
         dPss  = -PDJI * (PJI11 * PF1 + PJI12 * PF2 + PJI13 * PF3) ;
         dPbsP = -PDJI * (PJI21 * PF1 + PJI22 * PF2 + PJI23 * PF3) ;
         dPsb  = -PDJI * (PJI31 * PF1 + PJI32 * PF2 + PJI33 * PF3) ;
         T1 = abs(dPss) ;
         if (T1 < abs(dPbsP)) T1 = abs(dPbsP) ;
         if (T1 < abs(dPsb) ) T1 = abs(dPsb ) ;
            scale_fac=1.0 ;
         if(lp_sl > 80) begin
            scale_fac = 125.0 ;
         end else if(lp_sl > 40) begin
            scale_fac = 125.0 ;
         end else if(lp_sl > 20) begin
            scale_fac = 25.0 ;
         end else if(lp_sl > 10) begin
            scale_fac = 5.0 ;
         end
                    
         if(T1 > `dP_max/scale_fac) begin
            dPss  = dPss  * ( `dP_max/scale_fac / T1 ) ;
            dPbsP = dPbsP * ( `dP_max/scale_fac / T1 ) ;
            dPsb  = dPsb  * ( `dP_max/scale_fac / T1 ) ;
         end
   
         phi_sL_SOI = phi_sL_SOI + dPss ;
         phi_bL_SOIP = phi_bL_SOIP + dPbsP ;
         phi_sL_bulk = phi_sL_bulk + dPsb ;
                      
         PSCONV_3D = `ps_conv * scale_fac ;
         if(T1 < PSCONV_3D) begin
            flg_conv = 1 ;
         end
       end 
     end
     if(flg_brk10 > 0) begin lp_sl = flg_brk10; flg_brk10 = 0; end 

     //  ******************************                 
     //  end of 3D-Newton loop
     //  ******************************
              
     if(lp_sl > lp_sl_max) begin        // reset to the initial guesses in nonconvergent cases //
       phi_sL_SOI = phi_sL_SOI_ini ;
       phi_bL_SOI = phi_bL_SOI_ini ;
       phi_sL_bulk = phi_sL_bulk_ini ;
       phi_bL_SOIP = phi_bL_SOIP_ini ;
     end

     //-------------------------------------------*
     //Procedure for diverged case.
     //----------------//
     if(lp_sl > lp_sl_max) begin
       $write("*** warning(HiSIM_SOTB): Went Over Iteration Maximum (%M:Psl): \n") ;
       $write("Vgs %e   Vds %e   Vbs %e   ", Vgs, Vds, Vbs) ;
       $write("Vgsc %e   Vdsc %e   Vbsc %e   ", Vgsc, Vdsc, Vbsc) ;
       $write("Ids %e   ", Ids) ;
       $write("\n") ;
     end

     //  ***********************************************
     //  End of 3D-Newton code
     //  ***********************************************

 end // HSOTB_Eval_Solve_Psl_flat_phiBP

       //---------------------------------------------------*
       //Assign Pds.
       //----------------//
       
       Psl = phi_sL_SOI ;
       Pds = Psl - Ps0 ;
       
       // Vdseff //
       Vds = Vdsorg ;
     
`ifdef DISABLE_COPPRV
`else
       flg_conv_L = flg_conv ;
       //-----------------------------------------------------------*
       //Restore values for next calculation.
       //----------------//
       if( COPPRV && flg_conv_0+flg_conv_L == 2 ) begin
         // Confined biases //
         if( called >= 1 ) begin
           vbsc_prv2 = vbsc_prv ;
           vdsc_prv2 = vdsc_prv ;
           vgsc_prv2 = vgsc_prv ;
           mode_prv2 = mode_prv ;
         end
         vbsc_prv = Vbsc ;
         vdsc_prv = Vdsc ;
         vgsc_prv = Vgsc ;
         mode_prv = mode ;
         // Surface potentials //
         if( called >= 1 ) begin
           pss0_dvbs_prv2 = pss0_dvbs_prv ;
           pss0_dvgs_prv2 = pss0_dvgs_prv ;
           pbs0_dvbs_prv2 = pbs0_dvbs_prv ;
           pbs0_dvgs_prv2 = pbs0_dvgs_prv ;
           psb0_dvbs_prv2 = psb0_dvbs_prv ;
           psb0_dvgs_prv2 = psb0_dvgs_prv ;
           pssl_dvbs_prv2 = pssl_dvbs_prv ;
           pssl_dvds_prv2 = pssl_dvds_prv ;
           pssl_dvgs_prv2 = pssl_dvgs_prv ;
           pbsl_dvbs_prv2 = pbsl_dvbs_prv ;
           pbsl_dvds_prv2 = pbsl_dvds_prv ;
           pbsl_dvgs_prv2 = pbsl_dvgs_prv ;
           psbl_dvbs_prv2 = psbl_dvbs_prv ;
           psbl_dvds_prv2 = psbl_dvds_prv ;
           psbl_dvgs_prv2 = psbl_dvgs_prv ;
         end
         pss0_prv = phi_s0_SOI ;
         pbs0_prv = phi_b0_SOI ;
         psb0_prv = phi_s0_bulk ;
         pss0_dvbs_prv = ddx(phi_s0_SOI,V(bp));
         pss0_dvgs_prv = ddx(phi_s0_SOI,V(gp));
         pbs0_dvbs_prv = ddx(phi_b0_SOI,V(bp));
         pbs0_dvgs_prv = ddx(phi_b0_SOI,V(gp));
         psb0_dvbs_prv = ddx(phi_s0_bulk,V(bp));
         psb0_dvgs_prv = ddx(phi_s0_bulk,V(gp));
         pssl_prv = phi_sL_SOI ;
         pbsl_prv = phi_bL_SOI ;
         psbl_prv = phi_sL_bulk ;
         pssl_dvbs_prv = ddx(phi_sL_SOI,V(bp));
         pssl_dvds_prv = (mode>0) ? ddx(phi_sL_SOI,V(d )) : ddx(phi_sL_SOI,V(s ));
         pssl_dvgs_prv = ddx(phi_sL_SOI,V(gp));
         pbsl_dvbs_prv = ddx(phi_bL_SOI,V(bp));
         pbsl_dvds_prv = (mode>0) ? ddx(phi_bL_SOI,V(d )) : ddx(phi_bL_SOI,V(s ));
         pbsl_dvgs_prv = ddx(phi_bL_SOI,V(gp));
         psbl_dvbs_prv = ddx(phi_sL_bulk,V(bp));
         psbl_dvds_prv = (mode>0) ? ddx(phi_sL_bulk,V(d )) : ddx(phi_sL_bulk,V(s ));
         psbl_dvgs_prv = ddx(phi_sL_bulk,V(gp));
         
       end // (COPPRV)
`endif
       
       if(flg_zone <= -1 || phi_s0_SOI < 0.0) begin
         flg_noqi = 1 ;
       end
       
       //---------------------------------------------------*
       // start_of_calIdd:
       //*-----------------//
       Ps0s = phi_s0_SOI ;
       PsLs = phi_sL_SOI ;
       Pds = PsLs - Ps0s ;
       Pb0s = phi_b0_SOI ;
       PbLs = phi_bL_SOI ;
       Pbds = PbLs - Pb0s ;
       
       //---------------------------------------------------*
       //*  Idd: Idd1(Front) + Idd2(Back)
       //*-----------------//
       
       //-------------- Idd1 by front carrier --------------*
       // the 1st term of Idd1 //
       Idd1  = (Q_nL - Q_n0) - beta * (Q_nL + Q_n0) * (PsLs - Ps0s) * 0.5 ;
       //---------- End of Idd1 by front carrier -----------*
       
       //-------------- Idd2 by back carrier ---------------*
       Idd2  = (Q_bL - Q_b0) - beta * (Q_bL + Q_b0) * (PbLs - Pb0s) * 0.5 ; 
       //---------- End of Idd2 by back carrier ------------*
       
       // final equation of Idd //
       if(Idd1 < 0.0 || Vds == 0.0) Idd1 = 0.0 ;
       if(Idd2 < 0.0 || Vds == 0.0) Idd2 = 0.0 ;
       Idd = Idd1  + Idd2 ; 
       
       //---------------------------------------------------*
       //* Qdepu : -Qb in unit area.
       //*-----------------//
       Qdepu  = -0.5 * (Q_sL_dep + Q_s0_dep) ;
       
       //-----------------------------------------------------------*
       //* Alpha(=eta) : parameter to evaluate charges.
       //*-----------------//
       RRR_P0 = phi_sL_SOI - phi_s0_SOI + `ps_conv ;
       RRR_CC = -(Q_nL - Q_n0) ;
       
       if(-RRR_CC < 1e-18) begin
         RRR_CC = 0.0 ;  // avoid a spike of Cgs/Cgd
       end
       
       RRR_alpha_SOI = 1.0 + 2.0 * (-RRR_CC) / (beta * C_fox * RRR_P0 * RRR_P0) ;
       Alpha = 1.0 - RRR_alpha_SOI * RRR_P0 / VgVt ;
       if(Alpha <= 0) begin
         Alpha = 0.0 ;
       end
       
       // start_of_charges:
         
       //-----------------------------------------------------------*
       //* Qiu : -Qi in unit area.
       //*-----------------//
       Qiu  = - 0.5 * (Q_n0 + Q_nL) ;
       Qibu = - 0.5 * (Q_b0 + Q_bL) ;
         
       //-----------------------------------------------------------*
       //* Skip CLM and integrated charges if zone==D1
       //*-----------------//
       Lred = 0.0 ;
       if(flg_noqi == 0) begin    
         
         //-----------------------------------------------------------*
         //* Channel Length Modulation. Lred: \Delta L
         //*-----------------//
         if(UC_CLM2 < `epsm10 && CLM3 < `epsm10) begin
           Lred = 0.0 ;
           Psdl = Psl ;
           if(Psdl > Ps0 + Vdsz - `epsm10) begin
             Psdl = Ps0 + Vdsz - `epsm10 ;
           end
           
         end else begin              //if( clm2 < epsm10 && clm3 < epsm10 )
           Wd = `t_SOI ;
           T4 = `C_ESI / (UC_CLM2 * q_Nsub + CLM3 * Qn0 / Wd) ;
           Psdl = CLM1 * (Vds + Ps0) + (1.0e0 - CLM1) * Psl ;
           if(Psdl > Ps0 + Vdsz - `epsm10) begin
             Psdl = Ps0 + Vdsz - `epsm10 ;
           end
           T6 = Psdl - Psl ;        // can be negative //
           `Fn_SZ(T6, T6, 1e-3, T0)         // limited //
           T5 = Idd / (beta * Qn0) ;
           T10 = q_Nsub / `C_ESI ;
           T1 = 1.0e9 ;
           T11 = (2.0 * T5 + 2.0 * T10 * T6 * T4 + T1 * T4) / Leff ;
           T7 = T11 * T4 ;
           T11 = 4.0 * (2.0 * T10 * T6 + T1) ;
           T8 = T11 * T4 * T4 ;
           T9 = sqrt(T7 * T7 + T8) ;        // can be nan if Psdl < Psl //
           Lred = 0.5 * (-T7 + T9) ;           
           //---------------------------------------------------*
           //* Modify Lred for symmetry.
           //*-----------------//
           T1 = Lred ;
           Lred = FMDVDS * T1 ;
         end                //if( clm2 < epsm10 && clm3 < epsm10 )
         
         // CLM5 & CLM6 //
         Lred = Lred * clmmod ;
         
         //-------------------------------------------*
         //End point of CLM. (label)
         //----------------//
       end 
       // end_of_CLM:
       
       //---------------------------------------------------*
       //    Lch: actual channel length
       //    ----------------//
       Lch = Leff - Lred ;
       if(Lch < 1.0e-9) begin
         Lch = 1.0e-9 ;
         $write("*** warning(HiSIM_SOTB): actual channel length is too Small. (Lch=%e[m])\n", Lch) ;
         $write("                       CLM5 and/or CLM6 might be too large.\n") ;
       end
       
       //----------------------------------------------------------*
       //* Evaluate integrated charges in unit [C].
       //*----------------------//
       Qi = -weffcv_nf * Leff * (Qiu + Qibu);
       
       //----------------------------------------------------------*
       //* Evaluate substrate charge.
       //*----------------------//
       Qsub = 0.5 * (Q_s0_bulk + Q_sL_bulk) * Leff * weffcv_nf ;
       
       //-----------------------------------------------------------*
       //* Modified potential for symmetry.
       //*----------------- //
       T1 = (Vds - Pds) / 2 ;
       `Fn_SymAdd(Pzadd, T1, PZADD0, T2) 
       if(Pzadd < `epsm10) begin
         Pzadd = `epsm10 ;
       end
       Ps0z = Ps0 + Pzadd ;
       
       begin : HSOTB_Muunb
         
         real MUEqb , MUEqbb, CGS_ESI, CGS_Q_nL, CGS_Q_bL, CGS_Qiu, CGS_Qibu, CGS_Q_b0_dep, CGS_Q_bL_dep, CGS_Qdepu;
         real CGS_TBOX, CGS_Qbdepu;
         CGS_ESI      = `C_ESI   / `C_m2cm;
         CGS_Q_nL     = Q_nL     / `C_m2cm_p2;
         CGS_Q_bL     = Q_bL     / `C_m2cm_p2;
         CGS_Q_b0_dep = Q_b0_dep / `C_m2cm_p2;
         CGS_Q_bL_dep = Q_bL_dep / `C_m2cm_p2;
         CGS_Qiu      = Qiu      / `C_m2cm_p2;
         CGS_Qibu     = Qibu     / `C_m2cm_p2;
         CGS_Q_b0_dep = Q_b0_dep / `C_m2cm_p2;
         CGS_Q_bL_dep = Q_bL_dep / `C_m2cm_p2;
         CGS_Qdepu    = Qdepu    / `C_m2cm_p2;
         CGS_TBOX= `t_box * `C_m2cm;
         //-----------------------------------------------------------*
         //Evaluate universal mobility.
         //----------------//
         Ninv = NINV * (1 + NINVL / pow(LG, NINVLP)) / CGS_ESI ;
         Ndep = NDEP * (1 + NDEPL / pow(LG, NDEPLP)) / CGS_ESI ;
         
         // Muun for Front carrier
         `Fn_SZ(Pdsz, Pds , 1e-6, T0) 
         NINVDPdsz = sqrt(Pdsz*Pdsz + VZADD0) - sqrt(VZADD0) ;
         NINVDPdsz = pow( NINVDPdsz , NINVDP ) ;
         
         T4 = 1.0 + (NINVDPdsz) * NINVD ;
         MUEqb = MUEQB    * (1 + MUEQBL    / pow(LG, MUEQBLP   )) ; 
         T10 = CGS_Qiu - MUEqb * CGS_Q_bL ;
         T5 = Ndep * CGS_Qdepu + Ninv * T10 ; 
         
         Eeff = T5 / T4 ;
         if(CONEWMUB) begin 
           Pb0Ls = (phi_b0_SOI  + phi_bL_SOI)  * 0.5 ;
           Ps0Lb = (phi_s0_bulk + phi_sL_bulk) * 0.5 ;
           Eeffb = ( 3.9 * (Pb0Ls-Ps0Lb-Vbsbiz) ) / (11.7 * CGS_TBOX);
           Eeff= Eeff + Eeffb  ;
         end else begin
           Pb0Ls = 0.0 ; Ps0Lb = 0.0 ; Eeffb = 0.0 ;
         end
                                           
         if(COMUUNSZ) begin 
           `Fn_SZ(T0, Eeff, 3E3, T1) 
         end else begin
           `Fn_SZ(T0, Eeff, 1e-2 , T1) 
         end
         Eeff = T0 ;
         
         T8 = pow(T0, MUEPH0 ) ;
         T6 = pow(T0, muesr ) ; 
         
         Rns = CGS_Qiu / `C_QE ;
         
         T1 = 1.0e0 / (UC_MUECB0 + UC_MUECB1 * Rns / 1.0e11)
            + CGS_mphn0 * T8 + T6 / MUESR1 ;
         
         Muun  = 1.0e0 / T1 ;
         Muun  = Muun * `C_cm2m_p2;
         
         // Muun for Back carrier
         if(CONEWMUB) begin
           Eeffb = ( 3.9 * (Pb0Ls-Ps0Lb) ) / (11.7 * CGS_TBOX);
         end else begin
           `Fn_SZ(Pdsz, Pbds , 1e-6, T0) 
           NINVDPdsz = sqrt(Pdsz*Pdsz + VZADD0) - sqrt(VZADD0) ;
           NINVDPdsz = pow( NINVDPdsz , NINVDP ) ;
           T4 = 1.0 + (NINVDPdsz) * NINVD ;
           MUEqbb = MUEQBB    * (1 + MUEQBL / pow(LG, MUEQBLP)) ; 
           T10 = CGS_Qibu - MUEqbb * CGS_Q_nL ; 
           CGS_Qbdepu = -0.5 * (CGS_Q_bL_dep + CGS_Q_b0_dep) ;
           T5 = Ndep * CGS_Qbdepu + Ninv * T10 ;
           Eeffb = T5 / T4 ;
         end
         
         if(COMUUNSZ) begin 
           `Fn_SZ(T0, Eeffb, 3E1, T1) 
         end else begin
           `Fn_SZ(T0, Eeffb, 1e-2 , T1) 
         end
         Eeffb = T0 ;
         
         T8 = pow(T0, MUEPH0B ) ;
         T6 = pow(T0, muesrb ) ;
         
         Rns = CGS_Qibu / `C_QE ;
         
         T1 = 1.0e0 / (UC_MUECB0B + UC_MUECB1B * Rns / 1.0e11)
            + CGS_mphbn0 * T8 + T6 / MUESR1B ;
         
         Muunb = 1.0e0 / T1 ;
         Muunb = Muunb * `C_cm2m_p2;
       end // HSOTB_Muunb
       
       //-----------------------------------------------------------*
       //    Mu : mobility for Front carrier
       //    -------------- --//
       C_MUEEY0  = (0.2 * Vmaxe / Muun) ;
       TY = Idd1 / (beta * (Qn0 + `Small) * Lch) ;
       Ey = sqrt(TY * TY + C_MUEEY0 * C_MUEEY0) ;
       Em = Muun * Ey ;
       T1 = Em / Vmaxe ;
       // note: bb = 2 (electron) ;1 (hole) //
       if(1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10) begin
         T3 = 1.0e0 ;
       end else if(2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10) begin
         T3 = T1 ;
       end else begin
         T3 = pow(T1, BB - 1.0e0) ;
       end
       T4 = 1.0e0 + T1 * T3 ;
       if(1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10) begin
         T5 = 1.0 / T4 ;
       end else if(2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10) begin
         T5 = 1.0 / sqrt(T4) ;
       end else begin
         T6 = pow(T4, (-1.0e0 / BB - 1.0e0)) ;
         T5 = T4 * T6 ;
       end
       Mu = Muun * T5 ;
       
       //-----------------------------------------------------------*
       //    Mu : mobility for Back carrier
       //    -------------- --//
       C_MUEEY0B = (0.2 * Vmaxe / Muunb) ;
       TY = Idd2 / (beta * (Qb0 + `Small) * Lch) ;
       Eyb = sqrt(TY * TY + C_MUEEY0B * C_MUEEY0B) ; 
       Em = Muunb * Eyb ;
       T1 = Em / Vmaxe ;
       // note: bb = 2 (electron) ;1 (hole) //
       if(1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10) begin
         T3 = 1.0e0 ;
       end else if(2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10) begin
         T3 = T1 ;
       end else begin
         T3 = pow(T1, BB - 1.0e0) ;
       end
       T4 = 1.0e0 + T1 * T3 ;
       if(1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10) begin
         T5 = 1.0 / T4 ;
       end else if(2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10) begin
         T5 = 1.0 / sqrt(T4) ;
       end else begin
         T6 = pow(T4, (-1.0e0 / BB - 1.0e0)) ;
         T5 = T4 * T6 ;
       end
       Mub = Muunb * T5 ;
       
       // end_of_mobility : ; //
       
       //-----------------------------------------------------------*
       //    Ids: channel current.
       //    ----------------//
       
       betaWL = weff_nf * beta_inv / (Leff - Lred) ;
       
       //   Cals. Ids0
       Ids01 = betaWL * Idd1 * Mu ;
       Ids02 = betaWL * Idd2 * Mub ;
       Ids0  = Ids01 + Ids02 ;

       //-----------------------------------------------------------*
       //* Adding parasitic components to the channel current.
       //*-----------------//
       IdsPT = 0.0 ; Ids1 = 0.0 ; 
       Ids1_fac = 0.0 ; Ids2_fac = 0.0 ;
       if(PTL != 0) begin
         T1 = 0.5 * (Vds - Pds) ;
         `Fn_SymAdd(T6, T1, 0.01, T2) 
         T1 = 1.1 - (Ps0 + T6) ;
         `Fn_SZ(T2, T1, 0.05, T0) 
         T9 = C_fox * beta * ptl0 * pow(T2, PTP) ;
         T4 = (1.0 + Vdsz * PT2) + Vdsz * pt40 * (Ps0 + T6 - Vbsz) ;
         T9 = T9 * T4 ;
       end else begin
         T9 = 0.0 ;
       end
       if(GDL != 0) begin
         T8 = C_fox * beta * gdl0  * Vdsz ;
       end else begin
         T8 = 0.0 ;
       end
       if((T9 + T8) > 0.0) begin
         Idd0 = Pds * (T9 + T8) ;       // / `C_cm2m_p2
         IdsPT = betaWL * Idd0 * Mu ;   // * `C_cm2m_p2
         `Fn_Sigmoid(Ids2_fac, PTDLT*Vbsbiz)
         Ids1_fac = 1.0 - Ids2_fac ;
         Ids1 = Ids1_fac * IdsPT ;
       end
       
       //-----------------------------------------------------------*
       //* Adding parasitic components to the channel current (back side).
       //*-----------------//
       IdsPTb = 0.0 ; Ids2 = 0.0 ;
       if(PTL != 0) begin
         T1 = 0.5 * (Vds - Pbds) ;
         `Fn_SymAdd(T6, T1, 0.01, T2) 
         T1 = 1.1 - (Pb0s + T6) ;
         `Fn_SZ(T2, T1, 0.05, T0) 
         T9 = C_fox * beta * ptl0 * pow(T2, PTP) ;
         T4 = 1.0 + Vdsz * PT2 + Vdsz * pt40 * (Pb0s + T6 - Vbsz) ;
         T9 = T9 * T4 ;
       end else begin
         T9 = 0.0 ;
       end
       if((T9 + T8) > 0.0) begin
         Idd0 = Pbds * (T9 + T8) ;       // / `C_cm2m_p2
         IdsPTb = betaWL * Idd0 * Mub ;  // * `C_cm2m_p2
         `Fn_SU_CP(IdsPTb , IdsPTb , IdsPT , IdsPT * 0.05 , 2 , T0 )
         Ids2 = Ids2_fac * IdsPTb ;
       end
      
       // Calc. the total current 
       IdsPTtot = Ids1 + Ids2;
       Ids = Ids0 + IdsPTtot ;
       
       //-----------------------------------------------------------*
       //* STI
       //*-----------------//
       if( COISTI != 0 ) begin
           //---------------------------------------------------*
           //* dVthSCSTI : Short-channel effect induced by Vds(STI).
           //*-----------------//
           T1 = `C_ESI * C_fox_inv ;
           T2 = wdpl ;
           T3 = Lgatesm - PARL2 ;
           T4 = 1.0 / (T3 * T3) ;
           T5 = 2.0 * (VBI - Pb20b) * T1 * T2 * T4 ;
           dVth0 = T5 * sqrt_Pbsum ;
           T4 = SCSTI1 ;
           T6 = SCSTI2 ;
           T1 = T4 + T6 * Vdsz ;
           dVthSCSTI = dVth0 * T1 ;
           T1 = VTHSTI - VDSTI * Vds ;
           Vgssti = Vgsz - Vfb + T1 + dVthSCSTI ;
                  
           costi3 = costi0_p2 * C_fox_inv * C_fox_inv ;
           costi4 = costi3 * beta * 0.5 ;
           costi5 = costi4 * beta * 2.0 ;
           T11 = beta * 0.25 ;
           T10 = beta_inv - costi3 * T11 + Vfb - VTHSTI - dVthSCSTI + `Small ;
           T1 = Vgsz - T10 - `psisti_dlt ;
           T0 = `Fn_Sgn(T10) ;
           T2 = sqrt (T1 * T1 + T0 * 4.0 * T10 * `psisti_dlt) ;
           T3 = T10 + 0.5 * (T1 + T2) - Vfb + VTHSTI + dVthSCSTI - Vbsz ;
           T4 = beta * T3 - 1.0 ;
           T5 = 4.0 / costi5 ;
           T1 = 1.0 + T4 * T5 ;
           `Fn_SZ( T1 , T1, 1.0e-2, T2) 
           T1 = T1 + `Small ;
           costi6 = sqrt (T1) ;
           T0 = costi4 * (1.0 - costi6) ;
           Psasti = Vgssti + T0 ;
           T0 = 1.0 / (beta + 2.0 / (Vgssti + `Small)) ;
           Psbsti = ln (1.0 / costi1 / costi3 * (Vgssti * Vgssti)) * T0 ;
           T3 = Psbsti / (Vgssti + `Small) ;
           Psab = Psbsti - Psasti - `sti2_dlt ;
           T0 = Psab * Psab + 4.0 * `sti2_dlt * Psbsti ;
           `Fn_SZ( T0 , T0 , 1.0e-6 , T2 ) 
           T0 = sqrt (T0) ;
           Psti = Psbsti - 0.5 * (Psab + T0) ;
           T1 = 1.0 / T0 ;
           T0 = costi1 * exp (beta * Psti) ;
           T1 = beta * (Psti - Vbsz) - 1.0 + T0 ;
           `Fn_SZ( T1 , T1, 1.0e-2, T0) 
           T1 = T1 + `epsm10 ;
           sq1sti = sqrt (T1);
           T1 = beta * (Psti - Vbsz) - 1.0;
           `Fn_SZ( T1 , T1, 1.0e-2, T0) 
           T1 = T1 + `epsm10 ;
           sq2sti = sqrt (T1);
           Qn0sti = costi0 * (sq1sti - sq2sti) ;
                  
           // T1: Vdsatsti //
           T1 = Psasti - Psti ;
           `Fn_SZ( T1 , T1 , 1.0e-1 , T2 ) 
           T1 = T1 + `epsm10 ;
           TX = Vds / T1 ;
           `Fn_CP( TY , TX , 1.0 , 4 , T2 ) 
           costi7 = 2.0 * UC_WSTI * NF * beta_inv ;
           T1 = Lch ;
           Idssti = costi7 * Mu * Qn0sti * TY / T1;
           Ids = Ids + Idssti ;

       end
       
       //----------------------------------------------------------*
       //* induced gate noise. ( Part 1/3 )
       //*---------------------- //
       if(COIGN != 0 && COTHRML != 0) begin
         kusai00 = VgVt * VgVt ;
         kusaidd = 2.0e0 * beta_inv * C_fox_inv * Idd ;
         kusaiL = kusai00 - kusaidd ;
         `Fn_SZ(kusai00, kusai00, 1.0e-3, T0) 
         `Fn_SZ(kusaiL, kusaiL, 1.0e-3, T0) 
         kusai00L = kusai00 - kusaiL ;
         if(Qn0 < `epsm10 || kusai00L < `epsm10)
         flg_ign = 0 ;
         else flg_ign = 1 ;
       end
       
       //-----------------------------------------------------------*
       //End of PART-1. (label)
       //----------------//
       // end_of_part_1:
       
       
`ifdef DISABLE_COPPRV
`else
       called = called + 1 ;
`endif
       
     end // End of COPPRV_model
     
     
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //* PART-2: Substrate / gate / leak currents
     //*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
     
     //---------------------------------------------------*
     //* Impact-Ionization Induced Bulk Potential Change(IBPC)
     //*-----------------//
     if(flg_noqi == 0 && Isub > 0e0 && IBPC1 != 0e0) begin
       
       // delta Vbs //
       T0 = 1e0 + IBPC2 * dVth ;
       dVbsIBPC = IBPC1 * T0 * Isub ;
       
       // 081127 //
       Xi0 = beta * Ps0 - 1.0 ;
       `Fn_SZtemp(Xi0, Xi0, 1e-1)
       Xi0p12 = sqrt(Xi0) ;
       Xi0p32 = Xi0 * Xi0p12 ;
       Xil = beta * Psl - 1.0 ;
       `Fn_SZtemp(Xil, Xil, 1e-1)
       Xilp12 = sqrt(Xil) ;
       Xilp32 = Xil * Xilp12 ;
       
       // dG3 & dG4 //
       T1 = beta * dVbsIBPC / Xi0 ;
       T2 = beta * dVbsIBPC / Xil ;
       dG3 = cnst0SOI * ( Xilp32 * T2 - Xi0p32 * T1 ) ;
       dG4 = cnst0SOI * 0.5 * ( - Xilp12 * T2 + Xi0p12 * T1 ) ;
       
       // Add IBPC current into Ids //
       dIdd = dG3 + dG4 ;
       IdsIBPC = betaWL * dIdd * Mu ;
       
     end // End if(IBPC) //
     
     begin : COIIGS_model // {
     real TX, T0, T1, T2, T3, T4, T5, T6, T7, T9, T10 ;
     real Etun, Psdlz;
     real CGS_Tfox0, CGS_C_fox, CGS_Leff, CGS_weff_nf, CGS_Ey, CGS_Qiu, CGS_cnst0SOI;

     CGS_Tfox0    = Tfox0    * `C_m2cm ;
     CGS_C_fox    = C_fox    / `C_m2cm_p2 ;
     CGS_Leff     = Leff     * `C_m2cm ;
     CGS_weff_nf  =  weff_nf * `C_m2cm ;
     CGS_Ey       = Ey       / `C_m2cm ;
     CGS_Qiu      = Qiu      / `C_m2cm_p2 ;
     CGS_cnst0SOI = cnst0SOI / `C_m2cm_p2 ;

     //-----------------------------------------------------------*
     //* Igate : Gate current induced by tunneling.
     //*----------------- //
     if(COIIGS == 0) begin
       Igate = 0.0 ;
       Igs = 0.0 ;
       Igd = 0.0 ;
       Igb = 0.0 ;
       GLPART1 = 0.0 ;
     end else begin
       
       // Igate //
       if(flg_noqi == 0) begin
         Psdlz = Ps0z + Vdsz - `epsm10 ;
         T1 = Vgsz - GLEAK8 * Vfb + ( - GLEAK10 * Vbs + GLEAK4 * (dVth - dPpg )) / CGS_Leff - Psdlz * GLEAK3 ;  
         T7 = 1.0 + CGS_Ey / GLEAK5 ;
         Etun = T7 * T1 / CGS_Tfox0;
         `Fn_SZ(Etun, Etun, `igate_dlt, T5) 
         `Fn_SZ(T3, Vgsz, 1.0e-3, T4) 
         TX = (T3 - VZADD0) / `cclmmdf ;
         T1 = 1.0 - 1.0 / (1.0 + TX * TX) ;
         Etun = Etun * T1 ;
         T0 = CGS_Leff * CGS_weff_nf ;
         T7 = GLEAK7 / (GLEAK7 + T0) ;
         T6 = GLEAK6 ;
         T9 = T6 / (T6 + Vdsz) ;
         T4 = 1 / (Etun * Etun + `Small ) ; 
         T1 = - GLEAK2 * Egp32 * T4 ;
         if(T1 < `EXP_THRES_MIN) begin
           Igate = 0.0 ;
         end else begin
           T3 = GLEAK1 / Egp12 * `C_QE * T0 ;
           T6 = pow((CGS_Qiu + CGS_C_fox * `VgVt_Small ) / CGS_cnst0SOI, GLEAK9 ) ;
           T10 = exp(T1) * T3 * T6 * Etun * Etun ;
           Igate = T7 * T9 * T10 ;
         end
       end else begin
         Igate = 0.0 ;
       end
       
       // Igs //
       T0 = -GLKSD2 * Vgs + GLKSD3 ;
       T2 = exp(CGS_Tfox0 * T0) ;
       T1 = GLKSD5 * Vgs ;
       T0 = 1 / CGS_Tfox0 / CGS_Tfox0 ;       
       T3 = T1 * T1 * T0 ;            
       T4 = GLKSD1 / 1.0e6 * CGS_weff_nf * pow(LG, GLKSD4) ; 
       Igs = T4 * T2 * T3 ;
       if(T1 >= 0.0e0) begin
         Igs = Igs * -1.0 ;
       end
       
       // Igd //
       T5 = Vgs - Vds ;
       T0 = -GLKSD2 * T5 + GLKSD3 ;
       T2 = exp(CGS_Tfox0 * T0) ;
       T1 = GLKSD5 * T5 ;
       T0 = 1 / CGS_Tfox0 / CGS_Tfox0 ;
       T3 = T1 * T1 * T0 ;
       T4 = GLKSD1 / 1.0e6 * CGS_weff_nf * pow(LG, GLKSD4) ; 
       Igd = T4 * T2 * T3 ;
       if(T1 >= 0.0e0) begin
         Igd = Igd * -1.0 ;
       end
       
       // Igb //
       Etun = (-Vgs + GLKB4 * Vbs + Vfb + GLKB3) / CGS_Tfox0 ; 
       `Fn_SZ(Etun, Etun, `igate_dlt, T5) 
       Etun = Etun + `Small ;
       T1 = -GLKB2 / pow(Etun, GLKB6) ; 
       if(T1 < `EXP_THRES_MIN) begin
         Igb = 0.0 ;
       end else begin
         T2 = exp(T1) ;
         T3 = LG + GLKB7 ;                      
         `Fn_SL( T3, T3, GLKB8, T3 * 0.001, T0) 
         T3 = T3 * GLKB1 / 1e6 * CGS_weff_nf ;      
         Igb1 = T3 * pow(Etun, GLKB5) * T2 ;    
         // Igb2 //
         Etun = (-Vgs + GLKB24 * Vbs + Vfb + GLKB23) / CGS_Tfox0 ; 
         `Fn_SZ(Etun, Etun, `igate_dlt, T5) 
         Etun = Etun + `Small ;
         T1 = -GLKB22 / pow(Etun, GLKB26) ;
         if(T1 < `EXP_THRES_MIN) begin
           Igb2 = 0.0 ;
         end else begin
           T2 = exp(T1) ;
           T3 = LG + GLKB27 ;                      
           `Fn_SL( T3, T3, GLKB28, T3 * 0.001, T0) 
           T3 = T3 * GLKB21 / 1e6 * CGS_weff_nf ;           
           Igb2 = T3 * pow(Etun, GLKB25) * T2 ;   
         end
         T1 = -Igb1 * 0.001 ;
         if(T1 < `Small) T1 = `Small ;
         `Fn_SLtemp( Igb, -Igb1, -Igb2, T1)
         Igb = -Igb;
       end
       GLPART1 = 0.5 ;
       
     end                // if( coiigs == 0 ) //
     end // } COIIGS_model
     
     //-----------------------------------------------------------*
     //* Igidl : GIDL
     //*----------------- //
     if(COGIDL == 0) begin
       Igidl = 0.0e0 ;
     end else begin
       T1 = GIDL3 * (Vds + GIDL4) - Vgs - (dVthSC + dVthLP) * GIDL5 ;
       E1 = T1 / TFOXGIDL ;
       `Fn_SZ(Egidl, E1, `eef_dlt, T5) 
       T0 = - MKS_GIDL2 * Egp32 / (Egidl + `Small) ;
       if(T0 < `EXP_THRES_MIN) begin
         Igidl = 0.0 ;
       end else begin
         T2 = UC_GIDL1 / Egp12 * `C_QE * weff_nf ;
         Igidl = T2 * Egidl * Egidl * exp(T0) ;       
         Igidl = Igidl / (1.0 + exp(-beta * Vds));
         Igidl = Igidl / (1.0 - exp(-Leff / UC_GIDLBPL1));             
       end
     end
     
     //-----------------------------------------------------------*
     //* Igisl : GISL
     //*----------------- //
     if(COGIDL == 0) begin
       Igisl = 0.0e0 ;
     end else begin
       T1 = GIDL3 * (-Vds + GIDL4)
       - (Vgs - Vds) - (dVthSC + dVthLP) * GIDL5 ;
       E1 = T1 / TFOXGIDL ;
       `Fn_SZ(Egisl, E1, `eef_dlt, T5) 
       T0 = - MKS_GIDL2 * Egp32 / (Egisl + `Small) ;
       if(T0 < `EXP_THRES_MIN) begin
         Igisl = 0.0 ;
       end else begin
         T2 = UC_GIDL1 / Egp12 * `C_QE * weff_nf ;
         Igisl = T2 * Egisl * Egisl * exp(T0) ;       
         Igisl = Igisl / (1.0 + exp(beta * Vds));     
         Igisl = Igisl / (1.0 - exp(-Leff / UC_GIDLBPL1));             
       end
     end
     
     //-----------------------------------------------------------*
     //End of PART-2. (label)
     //----------------//
     // end_of_part_2: ; //
     
     
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //PART-3: Overlap charge
     //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
     
     //-------------------------------------------*
     //Calculation of Psdl for cases of flg_noqi==1.
     //----------------//
     Aclm = CLM1 ;
     Ec = 0.0 ;
     if(flg_noqi != 0) begin
       T2 = Vds + Ps0 ;
       Psdl = Aclm * T2 + (1.0e0 - Aclm) * Psl ;
       if(Psdl > Ps0 + Vds - `epsm10) begin
         Psdl = Ps0 + Vds - `epsm10 ;
       end
     end else begin
       // Ec is removed from Lred calc. part //
       if(XQY !=0) begin
         if( Idd > `C_IDD_MIN ) begin
           Ec = Idd * beta_inv / Leff / Qn0 ;
         end
       end
     end
     
     //Start of Overlap charge for intrinsic MOSFET
     
     //Begin of include
     //-------------------------------------------*                                     
     //* Overlap charges: Qgod, Qgos, and Qover                                 
     //*-----------------//                                     
     // Some constants to be used here.
     Cox0 = C_fox0;
     Cox0_inv = 1.0 / Cox0 ;
     
     if( COOVLP >= 1 && LOVER > 0.0 && MKS_NOVER > 0.0) begin
       
       Lov = LOVER ;
       cnst0over = cnst0SOI * sqrt(MKS_NOVER / Nsub ) ;
       
       for ( lcover = -1 ; lcover <= +1 ; lcover = lcover + 2 ) begin                                 
         flg_ovloops = ( 1 - lcover ) / 2 ; // 1 in Source overlap calc. //                                   
         flg_ovloopd = ( 1 + lcover ) / 2 ; // 1 in Drain overlap calc.  //                                    
         flg_overs = flg_ovloops * ModeNML + flg_ovloopd * ModeRVS ; // geometrical source //
         flg_overd = flg_ovloops * ModeRVS + flg_ovloopd * ModeNML ; // geometrical drain //
         //-------------------------------------------*                                       
         //* Qover(G/D overlap charge)  
         //*------------------------//                                        
         if(flg_ovloops) Vgbgmt = ModeNML * Vgse + ModeRVS * ( Vgse - Vdse ) ;
         if(flg_ovloopd) Vgbgmt = ModeRVS * Vgse + ModeNML * ( Vgse - Vdse ) ;
         Vxbgmt = 0.0 ;
         
         //---------------------------------------------------*                                       
         //* Clamp -Vxbgmt.                                   
         //*-----------------//                                       
         T0 = - Vxbgmt;                                       
         if( T0 > Vbs_bnd ) begin                                     
           T1 =    T0   - Vbs_bnd;                                    
           T2 =    Vbs_max    - Vbs_bnd;                                      
           `Fn_SUPoly4( TY, T1, T2, T11 )                                     
           T10 = Vbs_bnd + TY ;                                       
         end  else begin                                      
           T10 = T0 ;                                 
           // T11 = 1.0 ;
         end
         
         Vxbgmtcl = - T10 - `Small2 ;                                 
         fac1 = cnst0over * Cox0_inv ;                                        
         fac1p2 = fac1 * fac1 ;                                       
         VgpLD = - Vgbgmt + VFBOVER;                                       
         Pb2over = 2.0 / beta * ln (MKS_NOVER / Nin ) ;
         Vgb_fb_LD =  - Vxbgmtcl ;                                    
         
         //-----------------------------------*                                       
         //* QsuLD: total charge = Accumulation | Depletion+inversion                                 
         //*-----------------//                                       
         if(   VgpLD  < Vgb_fb_LD ) begin                                      
           //---------------------------*                                     
           //* Accumulation                                   
           //*-----------------//                                     
           flg_ovzone = -1 ;                                  
           TY = Cox0 / ( beta * cnst0over );                                   
           Ac41 = 2.0 + 3.0 * `C_SQRT_2 * TY ;                                        
           Ac4 = 8.0 * Ac41 * Ac41 * Ac41 ;                                   
           Ps0_min = Eg - Pb2over ;                                   
           TX = beta * ( VgpLD + Vxbgmtcl ) ;                                 
           Ac31 = 7.0 * `C_SQRT_2 - 9.0 * TY * ( TX - 2.0 ) ;                                 
           Ac3 = Ac31 * Ac31 ;                                        
           if( Ac4 < Ac3 * 1.0e-8 ) begin
             Ac1 = -7.0 * `C_SQRT_2 + Ac31 + 0.5 * Ac4 / Ac31 + 9.0 * TY * ( TX - 2.0 ) ;                                   
           end else begin
             Ac2 = sqrt( Ac4 + Ac3 ) ;                                  
             Ac1 = -7.0 * `C_SQRT_2 + Ac2 + 9.0 * TY * ( TX - 2.0 ) ;                                   
           end
           Acd = pow( Ac1 , `C_1o3 ) ;                                        
           Acn = -4.0 * `C_SQRT_2 - 12.0 * TY + 2.0 * Acd + `C_SQRT_2 * Acd * Acd ;                                   
           Chi = Acn / Acd ;                                  
           Psa = Chi * beta_inv - Vxbgmtcl ;                                  
           T1 = Psa + Vxbgmtcl ;                                      
           T2 = T1 / Ps0_min ;                                        
           Ps0LD = T1 / sqrt( 1.0 + ( T2 * T2 ) ) - Vxbgmtcl ;                                       
           QsuLD = Cox0 * ( VgpLD - Ps0LD ) ;
           QbuLD = QsuLD ;                                    
         end else begin                                       
           
           //---------------------------*                                     
           //* Depletion and inversion                                        
           //*-----------------//                                     
           
           // initial value for a few fixpoint iterations                                     
           //to get Ps0_iniA from simplified Poisson equation: //                                     
           flg_ovzone = 2 ;                                   
           Chi = `znbd3 ;                                     
           Ps0_iniA= Chi/beta - Vxbgmtcl ;                                        
           
           // 1 .. 2 relaxation steps should be sufficient //                                 
           for ( lp_ld = 1; lp_ld <= 2; lp_ld = lp_ld + 1 ) begin                                     
             TX = 1.0e0 + 4.0e0 * ( beta * ( VgpLD + Vxbgmtcl ) - 1.0e0 + exp(-Chi) ) / ( fac1p2 * beta2 ) ;                                 
             if( TX < `epsm10) begin                                  
               TX = `epsm10;                                          
             end                                      
             Ps0_iniA = VgpLD + fac1p2 * beta / 2.0e0 * ( 1.0e0 - sqrt( TX ) ) ;                                      
             Chi = beta * ( Ps0_iniA + Vxbgmtcl ) ;                                   
           end // End of iteration //                                 
           if( Chi < `znbd3 ) begin                                   
             flg_ovzone = 1 ;                                 
             
             //-----------------------------------*                                   
             //* zone-D1                                      
             //* - Ps0_iniA is the analytical solution of QovLD=Qb0 with                                      
             //*   Qb0 being approximated by 3-degree polynomial.                                     
             //*                                      
             //*   new: Inclusion of exp(-Chi) term at right border                                   
             //*-----------------//                                   
             Ta =  1.0/(9.0*`C_SQRT_2) - (5.0+7.0*`c_expm3) / (54.0*sqrt(2.0+`c_expm3));                                    
             Tb = (1.0+`c_expm3) / (2.0*sqrt(2.0+`c_expm3)) - `C_SQRT_2 / 3.0;                                      
             Tc =  1.0/`C_SQRT_2 + 1.0/(beta*fac1);                                   
             Td = - (VgpLD + Vxbgmtcl) / fac1;                                        
             Tq = Tb*Tb*Tb / (27.0*Ta*Ta*Ta) - Tb*Tc/(6.0*Ta*Ta) + Td/(2.0*Ta);                                       
             Tp = (3.0*Ta*Tc-Tb*Tb)/(9.0*Ta*Ta);                                      
             T5 = sqrt(Tq*Tq + Tp*Tp*Tp);                                        
             Tu = pow(-Tq + T5,`C_1o3);                                       
             Tv = -pow(Tq + T5,`C_1o3);                                       
             TX = Tu + Tv - Tb/(3.0*Ta);                                 
             Ps0_iniA = TX * beta_inv - Vxbgmtcl ;                                    
             Chi = beta * ( Ps0_iniA + Vxbgmtcl ) ;                                   
           end
           if( COQOVSM > 0 ) begin                                    
             //-----------------------------------*                                   
             //          * - Ps0_iniB : upper bound.                          
             //          *-----------------//                         
             flg_ovzone = flg_ovzone + 2;                                     
             VgpLD_shift = VgpLD + Vxbgmtcl + 0.1;                                    
             exp_bVbs = exp( beta * - Vxbgmtcl ) + `Small ;                                   
             T0 = Nin / MKS_NOVER;                                     
             cnst1over = T0 * T0;                                     
             gammaChi = cnst1over * exp_bVbs ;                                        
             T0  = beta2 * fac1p2;                                  
             psi = beta*VgpLD_shift;                                  
             Chi_1      = ln (gammaChi*T0 + psi*psi) - ln (cnst1over*T0) + beta*Vxbgmtcl;                                     
             `Fn_SU2( Chi_1, Chi_1, psi, 1.0, T1, T2 )                                        
             
             // 1 fixpoint step for getting more accurate Chi_B //                                    
             psi = psi - Chi_1 ;                                      
             psi = psi + beta*0.1 ;                                   
             Chi_B = ln (gammaChi*T0 + psi*psi) - ln (cnst1over*T0) + beta*Vxbgmtcl;                                  
             Ps0_iniB      = Chi_B/beta - Vxbgmtcl ;                                  
             
             // construction of Ps0LD by taking Ps0_iniB as an upper limit of Ps0_iniA                                        
             //*                                      
             //* Limiting is done for Chi rather than for Ps0LD, to avoid shifting                                    
             //* for Fn_SU2 //                                        
             Chi_A = Chi;                                     
             `Fn_SU2( Chi, Chi_A, Chi_B, `c_ps0ini_2*75.00, T1, T2 ) // org: 50 //                                    
             
           end                                        
           
           // updating Ps0LD //                                       
           Ps0LD = Chi/beta - Vxbgmtcl ;                                      
           T1    = Chi - 1.0 + exp(-Chi);                                     
           if(T1 < `epsm10) begin                                     
             T1 = `epsm10 ;                                  
           end                                        
           QbuLD = cnst0over * sqrt(T1) ;
           
           //-----------------------------------------------------------*                                     
           //* QsuLD : Qovs or Qovd in unit area.                                     
           //* note: QsuLD = Qdep+Qinv.                                       
           //*-----------------//                                     
           QsuLD = Cox0 * ( VgpLD - Ps0LD ) ;                                 
           
           if( COQOVSM == 1 ) begin // take initial values from analytical model //                                   
             
             //---------------------------------------------------*                                   
             //* Calculation of Ps0LD. (beginning of Newton loop)                                     
             //* - Fs0 : Fs0 = 0 is the equation to be solved.                                        
             //* - dPs0 : correction value.                                   
             //*-----------------//                                   
             
             // initial value too close to flat band should not be used //                                    
             exp_bVbs = exp( beta * - Vxbgmtcl ) ;                                    
             T0 = Nin / MKS_NOVER;                                     
             cnst1over = T0 * T0;                                     
             cfs1 = cnst1over * exp_bVbs ;                                    
             flg_conv = 0 ; 
             for ( lp_s0 = 1 ; lp_s0 <= `lp_s0_max_qov + 1 ; lp_s0 = lp_s0 + 1 ) begin                                  
               Chi = beta * ( Ps0LD + Vxbgmtcl ) ;                                    
               if( Chi < `znbd5 ) begin                                       
                 //-------------------------------------------*
                 //* zone-D1/D2. (Ps0LD)                                      
                 //*-----------------//                                       
                 fi = Chi * Chi * Chi                                 
                 * ( `cn_im53 + Chi * ( `cn_im54 + Chi * `cn_im55 ) ) ;                                    
                 fi_dChi = Chi * Chi                                  
                 * ( 3 * `cn_im53 + Chi * ( 4 * `cn_im54 + Chi * 5 * `cn_im55 ) ) ;                                   
                 fs01 = cfs1 * fi * fi ;                                      
                 fs01_dPs0 = cfs1 * beta * 2 * fi * fi_dChi ;                                 
                 
                 fb = Chi * ( `cn_nc51                                        
                 + Chi * ( `cn_nc52                                        
                 + Chi * ( `cn_nc53                                        
                 + Chi * ( `cn_nc54 + Chi * `cn_nc55 ) ) ) ) ;                                     
                 fb_dChi = `cn_nc51                                   
                 + Chi * ( 2 * `cn_nc52                                       
                 + Chi * ( 3 * `cn_nc53                                       
                 + Chi * ( 4 * `cn_nc54 + Chi * 5 * `cn_nc55 ) ) ) ;                                  
                 fs02 = sqrt( fb * fb + fs01 + `Small ) ;                                     
                 fs02_dPs0 = ( beta * fb_dChi * 2 * fb + fs01_dPs0 ) / ( fs02 + fs02 ) ;                                      
               end else begin                                 
                 //-------------------------------------------*                                       
                 //* zone-D3. (Ps0LD)                                 
                 //*-----------------//                                       
                 if( Chi < `large_arg ) begin // avoid exp_Chi to become extremely large //                                   
                   exp_Chi = exp( Chi ) ;                                     
                   fs01 = cfs1 * ( exp_Chi - 1.0e0 ) ;                                        
                   fs01_dPs0 = cfs1 * beta * ( exp_Chi ) ;                                    
                 end else begin                                       
                   exp_bPs0 = exp( beta*Ps0LD ) ;                                     
                   fs01     = cnst1over * ( exp_bPs0 - exp_bVbs ) ;                                   
                   fs01_dPs0 = cnst1over * beta * exp_bPs0 ;                                  
                 end
                 fs02 = sqrt( Chi - 1.0 + fs01 ) ;                                    
                 fs02_dPs0 = ( beta + fs01_dPs0 ) / fs02 * 0.5 ;                                      
                 
               end // end of if( Chi  ... ) block //                                  
               //-----------------------------------------------------------*                                 
               //* Fs0                                        
               //*-----------------//                                 
               Fs0 = VgpLD - Ps0LD - fac1 * fs02 ;                                    
               Fs0_dPs0 = - 1.0e0 - fac1 * fs02_dPs0 ;                                        
               if( flg_conv == 1 ) begin //break
                 lp_s0 = `lp_s0_max_qov+1 ; 
               end else begin
                 dPs0 = - Fs0 / Fs0_dPs0 ;                                      
                 
                 //-------------------------------------------*                                 
                 //* Update Ps0LD .                                     
                 //*-----------------//                                 
                 dPlim = 0.5*`dP_max*(1.0 + `Fn_Max(1.0e0,abs(Ps0LD))) ;                                        
                 if ( abs( dPs0 ) > dPlim ) dPs0 = dPlim * `Fn_Sgn( dPs0 ) ;                                    
                 Ps0LD = Ps0LD + dPs0 ;                                 
                 
                 //-------------------------------------------*                                 
                 //* Check convergence.                                 
                 //*-----------------//                                 
                 if( abs( dPs0 ) <= `ps_conv && abs( Fs0 ) <= `gs_conv ) begin                                  
                   flg_conv = 1 ;                                       
                 end
               end 
             end // end of Ps0LD Newton loop //                                       
             //-------------------------------------------*                                   
             //* Procedure for diverged case.                                 
             //*-----------------//                                   
             if( flg_conv == 0 ) begin                                        
               $write( "*** warning(HiSIM_SOTB): Went Over Iteration Maximum(%M:Ps0LD)\n" ) ;                                   
               $write(" -Vxbgmtcl = %e   Vgbgmt = %e\n" , -Vxbgmtcl , Vgbgmt ) ;                                      
             end
             if( Chi < `znbd5 ) begin                                 
               //-------------------------------------------*                                 
               //* zone-D1/D2. (Ps0LD)                                        
               //*-----------------//                                 
               if ( Chi < `znbd3 ) begin 
                 flg_ovzone = 1;                                   
               end else begin 
                 flg_ovzone = 2; 
               end                                 
               Xi0 = fb * fb + `epsm10 ;                                      
               Xi0p12 = fb + `epsm10 ;                                        
             end else begin
               //-------------------------------------------*                                 
               //* zone-D3. (Ps0LD)                                   
               //*-----------------//                                 
               flg_ovzone = 3 ;                                       
               Xi0 = Chi - 1.0e0 ;                                    
               Xi0p12 = sqrt( Xi0 ) ;                                 
             end // end of if( Chi  ... ) block //                                    
             
             //-----------------------------------------------------------*                                   
             //* QbuLD and QiuLD                                      
             //*-----------------//                                   
             QbuLD = cnst0over * Xi0p12 ;                                     
             T1 = 1.0 / ( fs02 + Xi0p12 ) ;                                   
             QiuLD = cnst0over * fs01 * T1 ;                                  
             
             //-----------------------------------------------------------*                                   
             //* Total overlap charge                                 
             //*-----------------//                                   
             QsuLD = QbuLD + QiuLD;                                   
             
           end // end of COQOVSM branches //                                  
           
         end // end of Vgbgmt region blocks //                                        
         
         // inversion charge = total - depletion //                                   
         QiuLD = QsuLD - QbuLD  ;                                     
         
         // assign final outputs of Qover model //                                    
         // note: Qovs and Qovd are exchanged in reverse mode //                                      
         T4 = weffcv_nf * Lov ;                                 
         if(flg_overs) begin                                        
           Qovs =  T4 * QsuLD ;                                       
           QbsLD = T4 * QbuLD ;                                       
         end
         if(flg_overd) begin                                        
           Qovd =  T4 * QsuLD ;                                       
           QbdLD = T4 * QbuLD ;                                       
         end
         
       end // end of lcover loop //                                   
       
       
       //-----------------------------------*                                   
       //* Additional constant capacitance model                                        
       //*-----------------//                                   
       flg_overgiven = ( ModeRVS * CGSO_GIVEN                                   
                     + ModeNML * CGDO_GIVEN  ) ;                                        
       if( flg_overgiven ) begin                                        
         Cgdoe = ModeRVS * CGSO + ModeNML * CGDO ;                                       
         Cgdoe = Cgdoe * ( - weffcv_nf ) ;                                        
         Qgod = Qgod + - Cgdoe * (Vgs - Vds) ;                                  
       end
       flg_overgiven = ( ModeNML * CGSO_GIVEN                                   
                     + ModeRVS * CGDO_GIVEN ) ;                                 
       if(flg_overgiven) begin                                  
         Cgsoe = ModeNML * CGSO + ModeRVS * CGDO ;                                       
         Cgsoe = Cgsoe * ( - weffcv_nf ) ;                                        
         Qgos = Qgos + - Cgsoe * Vgs ;                                  
       end
       
     end else begin // else case of if( coovlp >= 1 ) //                                        
       if((mode == `HiSIM_NORMAL_MODE && !CGDO_GIVEN) ||                                        
          (mode != `HiSIM_NORMAL_MODE && !CGSO_GIVEN) ) begin
          if (LOVER > 0) begin
             Cgdoe = - Cox0 * LOVER * weffcv_nf ;
          end else begin
             Cgdoe = 0;
          end
       end else begin
         Cgdoe = ModeRVS * CGSO + ModeNML * CGDO ;                                       
         Cgdoe = Cgdoe * ( - weffcv_nf ) ;                                        
       end
       Qgod = - Cgdoe * (Vgs - Vds) ;                                   
       
       if((mode == `HiSIM_NORMAL_MODE && !CGSO_GIVEN) ||                                        
          (mode != `HiSIM_NORMAL_MODE && !CGDO_GIVEN) ) begin                                    
         Cgsoe = - Cox0 * LOVER * weffcv_nf ;                                  
       end else begin
         Cgsoe = ModeNML * CGSO + ModeRVS * CGDO ;                                       
         Cgsoe = Cgsoe * ( - weffcv_nf ) ;                                        
       end
       Qgos = - Cgsoe * Vgs ;                                  
     end // end of if( coovlp >= 1 ) // 
     
     //End of include
     //-----------------------------------------------------------*
     //End of PART-3. (label)
     //----------------//
     // end_of_part_3: ; //
     
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //PART-5: NQS Model.
     //---------------- //
     if(flg_nqs) begin
       if(flg_noqi == 0) begin
         T1 = DLY1 * DLY2 * Lch * Lch ;
         T2 = Mu * VgVt * DLY1 + DLY2 * Lch * Lch + `Small ;
         tau = T1 / T2 ;
       end else begin
         tau = DLY1 + `Small ;
       end
       taub = DLY3 * C_fox / `C_m2cm_p2;
     end
     
     //-----------------------------------------------------------*
     //End of PART-5. (label)
     //-----------------//
     //   end_of_part_5: //
     
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     //PART-6: Noise Calculation. from HiSIM 2.5.1 2010.05.21
     //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//
     
     //-----------------------------------------------------------*
     //* 1/f noise.
     //*-----------------//
     if(COFLICK != 0 && !flg_noqi) begin
       NFalpe = MKS_NFALP ;
       NFtrpe = MKS_NFTRP ;
       Cite = MKS_CIT ;
       T1 = Qn0 / `C_QE ;
       T2 = (C_fox + Qn0 / (Ps0 - Vbs) + Cite) * beta_inv / `C_QE ;
       T3 = -2.0E0 * Qi / `C_QE / Lch / weffcv_nf - T1 ;
       if(T3 != T1) begin
         T4 = 1.0E0 / (T1 + T2) / (T3 + T2) + 2.0E0 * NFalpe * Ey * Mu / (T3 - T1)
            * ln((T3 + T2) /(T1 + T2)) + NFalpe * Ey * Mu * NFalpe * Ey * Mu ;
       end else begin
         T4 = 1.0 / (T1 + T2) / (T3 + T2) + 2.0 * NFalpe * Ey * Mu / (T1 + T2)
            + NFalpe * Ey * Mu * NFalpe * Ey * Mu ;
       end
       Nflic = Ids * Ids * NFtrpe / (Lch * beta * weff_nf) * T4 ;
     end else begin
       Nflic = 0.0 ;
     end
     
     //-----------------------------------------------------------*
     //* thermal noise.
     //*-----------------//
     if(COTHRML != 0 && !flg_noqi) begin
       Eyd = (Psdl - Ps0) / Lch ;
       T12 = Muun * Eyd / (1.0e7 * `C_cm2m);
       // note: bb = 2 (electron) ;1 (hole) //
       if(1.0e0 - `epsm10 <= BB && BB <= 1.0e0 + `epsm10) begin
         T7 = 1.0e0 ;
       end else if(2.0e0 - `epsm10 <= BB && BB <= 2.0e0 + `epsm10) begin
         T7 = T12 ;
       end else begin
         T7 = `Fn_Pow(T12, BB - 1.0e0) ;
       end
       T9 = 1.0e0 + T12 * T7 ;
       T10 = `Fn_Pow(T9, (-1.0e0 / BB - 1.0e0)) ;
       Mud_hoso = Muun * T9 * T10 ;
       Mu_Ave = (Mu + Mud_hoso) / 2.0 ;
       T0 = Alpha * Alpha ;
       Nthrml = weff_nf * C_fox * VgVt * Mu
              * ((1e0 + 3e0 * Alpha + 6e0 * T0) * Mud_hoso * Mud_hoso
              + (3e0 + 4e0 * Alpha + 3e0 * T0) * Mud_hoso * Mu + (6e0 + 3e0 * Alpha + T0) * Mu * Mu)
              / (15e0 * Lch * (1e0 + Alpha) * Mu_Ave * Mu_Ave) ;
     end else begin
       Nthrml = 0e0 ;
     end
     
     //----------------------------------------------------------*
     //* induced gate noise. ( Part 2/3 )
     //*----------------------//
     if(COIGN != 0 && COTHRML != 0 && flg_ign == 1 && !flg_noqi) begin
       sqrtkusaiL = sqrt(kusaiL) ;
       T2 = VgVt + sqrtkusaiL ;
       T3 = kusai00 * kusai00 ;
       T4 = kusaiL * kusaiL ;
       T5 = 42.0e0 * kusai00 * kusaiL ;
       T5 = T5 + 4.0e0 * (T3 + T4) ;
       T5 = T5 + 20.0e0 * sqrtkusaiL * VgVt * (kusai00 + kusaiL) ;
       T10 = T2 * T2 ;
       kusai_ig = T5 / (T10 * T10 * T2) ; // Induced Gate Noise parameter //
       gds0_ign = weff_nf / Lch * Mu * C_fox ;
       gds0_h2 = gds0_ign * VgVt ;
       GAMMA = Nthrml / gds0_h2 ;
       T7 = kusai00 + 4.0e0 * VgVt * sqrtkusaiL + kusaiL ;
       // cross-correlation coefficient(= Sigid/sqrt(Sig*Sid) ) //
       crl_f = `c_sqrt_15 * kusai00L * T7 / (6.0e0 * T2 * sqrt(GAMMA * T2 * VgVt * T5)) ;
     end
     
     //-----------------------------------------------------------*
     //End of PART-6. (label)
     //-----------------//
     //   end_of_part_6: //
     
     //-------------------------------------------*
     //* Add IdsIBPC to Ids.  090110
     //*-----------------//
     Ids = Ids + IdsIBPC ;
     
     //---------------------------------------------------*
     //Constant capacitance.
     //----------------//
     if(CGBO_GIVEN) begin
       Cgbe = - CGBO * Lgate ;
       Qgob = Cgbe * (Vgse -Vbse) ;
     end else begin
       Cgbe = 0.0 ;
       Qgob = 0.0 ;
     end
     
     //---------------------------------------------------*
     //Fringing capacitance.
     //----------------//
     Cf = `C_EOX / (`C_Pi / 2.0e0) * weffcv_nf * log1p(TPOLY / Tfox0) ;
     Qfd = Cf * (Vgse - Vdse) ;
     Qfs = Cf * Vgse ;
     
     //---------------------------------------------------*
     //Add fringing charge/capacitance to overlap.
     //----------------//
     Qgod = Qgod + Qfd ;
     Qgos = Qgos + Qfs ;
     
     //---------------------------------------------------*
     //Assign outputs.
     //----------------//
     
     //---------------------------------------------------*
     //Channel current and conductances.
     //----------------//
     idse = Mfactor * Ids ;
     
     //---------------------------------------------------*
     //Intrinsic charges/capacitances.
     //----------------//
     T1 = -weffcv_nf * Leff ;
     T2 = -0.5 * (Q_s0_dep + Q_sL_dep) ;
     T3 = -0.5 * (Q_b0_dep + Q_bL_dep) ;
     Qfs_box = T1 * `Q_FD_BOX * Vbse ;
     Qfd_box = T1 * `Q_FD_BOX * ( Vbse - Vdse ) ;
     Qs_dep  = T1 * T2 ;
     Qb_dep  = T1 * T3 ;
     
     if(COCINV) begin
       Qsub = 0.0 ; 
       Qidep = Qi ;
     end else begin
       Qidep = Qi + Qs_dep + Qb_dep ;
     end
     Qd = Qidep * Qdrat ;
     
     if(flg_nqs) begin  // for flat handling of NQS: the NQS charges are added //
       qde = 0.0 ;
       qge = 0.0 ;
       qbe = 0.0 ;
       Qb_qs = Mfactor * ( Qsub ) ;
       Qi_qs = Mfactor * ( Qidep ) ;
       
     end else begin             // QS //
       qge = Mfactor * ( -Qsub - Qidep ) ;
       qde = Mfactor * (         Qd + Qfd_box ) ;
       qse = Mfactor * ( Qidep - Qd + Qfs_box ) ;
     end
     
     //---------------------------------------------------*
     //Lateral-field-induced capacitance.
     //----------------//
     if(XQY == 0) begin
       Qy = 0e0 ;
     end else begin
       Pslk = Ec * Leff + Ps0 ;
       if(Pslk > Psdl) begin
         Pslk = Psdl ;
       end
       T1 = Aclm * (Vds + Ps0) + (1.0e0 - Aclm) * Pslk ;
       T10 = sqrt(2.0e0 * `C_ESI / q_Nsub) ;
       T3 = T10 * 1.3 ;
       T2 = `C_ESI * weffcv_nf * T3 ;
       Qy = ((Ps0 + Vds - T1) / XQY - Ec) * T2 ;
     end
     if( XQY1 != 0.0 ) begin
       Qy = Qy + cqyb0 * Vbs ;
     end
     
     //---------------------------------------------------*
     //Add S/D overlap charges/capacitances to intrinsic ones.
     //- NOTE: This function depends on coadov, a control option.
     //----------------//
     if(COADOV == 1) begin
       qge = qge + Mfactor * ( Qgod + Qgos - Qgob - Qy - Qovs - Qovd) ;
       qde = qde + Mfactor * (-Qgod + Qy + QbdLD) ;
       qse = qse + Mfactor * (-Qgos      + QbsLD) ;
     end
     
     //---------------------------------------------------*
     //Substrate current.
     //----------------//
     if(COISUB != 1) begin
       isube = 0.0 ;
     end else begin
       isube = Mfactor * Isub ;
     end
     
     //---------------------------------------------------*
     //Von, Vdsat,
     //----------------//
     vone = Vth ;
     vdsate = Vdsat ;
     
     //---------------------------------------------------*
     //* Gate leak currents.
     //*-----------------//
     igbe = Mfactor * -Igb ;
     if(mode == `HiSIM_NORMAL_MODE) begin
       igde = Mfactor * (GLPART1 * Igate - Igd) ;
     end else begin
       T1 = 1.0 - GLPART1 ;
       igde = Mfactor * (T1 * Igate - Igs) ;
     end
     if(mode == `HiSIM_NORMAL_MODE) begin
       T1 = 1.0 - GLPART1 ;
       igse = Mfactor * (T1 * Igate - Igs) ;
     end else begin
       igse = Mfactor * (GLPART1 * Igate - Igd) ;
       
     end
     igidle = (mode == `HiSIM_NORMAL_MODE) ? Mfactor * Igidl : Mfactor * Igisl ;
     igisle = (mode == `HiSIM_NORMAL_MODE) ? Mfactor * Igisl : Mfactor * Igidl ;
     
     //-----------------------------------------------------------*
     //* Noise.
     //*-----------------//
     noiflick = Mfactor * Nflic ;
     noithrml = Mfactor * Nthrml ;
     
     cgdbd = ddx(qge,V(d)) ; cgdbd = TYPE * cgdbd ;
     cgsbd = ddx(qge,V(s)) ; cgsbd = TYPE * cgsbd ;  
     cgsb  = (mode > 0) ? cgsbd : cgdbd ;
     
     //----------------------------------------------------------*
     //* induced gate noise. ( Part 3/3 )
     //*---------------------- from HiSIM 2.5.1 2010.05.21 //
     if(COIGN != 0 && COTHRML != 0 && flg_ign == 1 && !flg_noqi) begin
       T0 = `C_fox_Small * C_fox * weffcv_nf * Leff ;
       T1 = cgsb / Mfactor ;
       Nign0 = `c_16o135 * `C_QE * beta_inv * T1 * T1 / gds0_ign ;
       if(kusai00L > `epsm10 && Vds > `epsm10) begin
         MuModA = Muun / Mu ;
         MuModB = (Muun / Mud_hoso - MuModA) / Vds ;
         correct_w1 = MuModA + `C_2o3 * MuModB * (kusai00 + VgVt * sqrtkusaiL + kusaiL)
                    / (VgVt + sqrtkusaiL) ;
       end else begin
         correct_w1 = Muun / Mud_hoso ;
       end
       noiigate = Mfactor * Nign0 * kusai_ig * correct_w1 ;
       noicross = crl_f ;
       noiigate = (noiigate < 0.0) ? 0.0 : noiigate ;
       noiigate = ( - T1 > T0 ) ? noiigate : 0.0 ;
       noicross = ( - T1 > T0 ) ? noicross : 0.0 ;
     end else begin
       noiigate = 0.0e0 ;
       noicross = 0.0e0 ;
     end
     
     // *-------------------------------------------------------------
     // * Actually load the device currents 
     // * 
     // *-----------------------------------//
     
     // in case of nqs: construct static contributions to the nqs equations(Iqi_nqs ; Iqb_nqs)       //
     //   and nqs charge contributions to inner drain ; gate and source node(Qd_nqs ; Qg_nqs ; Qs_nqs) //
     if(flg_nqs) begin
       // .. tau ; taub must be > 0 //
       if(tau < 1.0e-18) begin
         tau = 1.0e-18 ;
       end
       if(taub < 1.0e-18) begin
         taub = 1.0e-18 ;
       end
       Iqi_nqs = (Qi_nqs - Qi_qs) / tau ;
       Iqb_nqs = (Qb_nqs - Qb_qs) / taub ;
       Qg_nqs  = -Qi_nqs -Qb_nqs ;
       Qd_nqs  = Qi_nqs * Qdrat ;
       Qs_nqs  = Qi_nqs * (1.0 - Qdrat) ;
     end else begin
       Iqi_nqs = 0.0 ; Iqb_nqs = 0.0 ; 
       Qd_nqs  = 0.0 ;  Qs_nqs = 0.0 ;  Qg_nqs = 0.0 ;
       Qb_nqs  = 0.0 ;
     end
     
     if(mode == 1) begin
       Ids = idse ;
       Isub = isube ;
       Isubs = 0.0 ;
       Qg = qge ;
       Qd = qde ;
       qbe = -(qge + qde + qse ) ;
       Qb = qbe ;
     end else begin
       Ids = -idse ;
       Isubs = isube ;
       Isub = 0.0 ;
       Qg = qge ;
       Qd = qse ;
       qbe = -(qge + qde + qse ) ;
       Qb = qbe ;
       qse = qde ;
       qde = Qd ;
       if(flg_nqs) begin
         T1 = Qd_nqs ;
         Qd_nqs = Qs_nqs ;
         Qs_nqs = T1 ;
       end
     end
       
     //---------------------------------------------------*
     //* Power current.
     //*-----------------//
     if(COSELFHEAT && RTH0 > 0.0) begin
       Rpower = idse * Vds ;     // Nakagawa 2014.10.24
       Cthe = cth ;
       Gth = 1.0 / rth ; 
     end else begin
       Rpower = 0.0 ;
       Cthe = 0.0 ;
       Gth = 0.0 ;
     end
     
     //---------------------------------------------------*
     // Igd, Igs, Igb, Igidl
     //*-----------------//
     Igd = igde ;
     Igs = igse ;
     Igb = igbe ;
     Igidl = igidle ;
     Igisl = igisle ;
     
     //--print Op points--------*/
     idse    =  Ids  ;
     isuba   =  TYPE * (Isub + Isubs) ;
     
     ggds    =  ddx(idse,V(d)) ;  ggds  = TYPE * ggds  ;
     ggdss   =  ddx(idse,V(s)) ;  ggdss = TYPE * ggdss ;
     
     if(mode != `HiSIM_NORMAL_MODE) begin
       ggds    = ggdss ;
     end
     
     ggm     =  ddx(idse,V(gp)) ;   ggm  = TYPE * ggm   ;
     ggmbs   =  ddx(idse,V(bp)) ;  ggmbs = TYPE * ggmbs ;
     ggmt    =  ddx(idse,Temp(t)) ; 
     
     cggbd   =  ddx(qge,V(gp)) ; cggbd = TYPE * cggbd ;
     cgdbd   =  ddx(qge,V(d)) ;  cgdbd = TYPE * cgdbd ;
     cgsbd   =  ddx(qge,V(s)) ;  cgsbd = TYPE * cgsbd ;
     cgbbd   =  ddx(qge,V(bp)) ; cgbbd = TYPE * cgbbd ;
     
     cdgbd   =  ddx(qde,V(gp)) ; cdgbd = TYPE * cdgbd ;
     cddbd   =  ddx(qde,V(d)) ;  cddbd = TYPE * cddbd ;
     cdsbd   =  ddx(qde,V(s)) ;  cdsbd = TYPE * cdsbd ;
     cdbbd   =  ddx(qde,V(bp)) ; cdbbd = TYPE * cdbbd ;
     
     cbgbd   =  ddx(qbe,V(gp)) ; cbgbd = TYPE * cbgbd ;
     cbdbd   =  ddx(qbe,V(d)) ;  cbdbd = TYPE * cbdbd ;
     cbsbd   =  ddx(qbe,V(s)) ;  cbsbd = TYPE * cbsbd ;
     cbbbd   =  ddx(qbe,V(bp)) ; cbbbd = TYPE * cbbbd ;
     
     csgbd   =  ddx(qse,V(gp)) ; csgbd = TYPE * csgbd ;
     csdbd   =  ddx(qse,V(d)) ;  csdbd = TYPE * csdbd ;
     cssbd   =  ddx(qse,V(s)) ;  cssbd = TYPE * cssbd ;
     csbbd   =  ddx(qse,V(bp)) ; csbbd = TYPE * csbbd ;
     
     
     begin : Print_INFO
       real ggbbs , ggbds , ggbgs ;

       ggbgs   =  ddx(isuba,V(gp)) ; 
       ggbds   =  ddx(isuba,V(d)) ; 
       ggbbs   =  ddx(isuba,V(bp)) ; 

       // print all outputs ------------VV //
       if( INFO >= 8 ) begin
         $write( "vone,vdsate = %18.10e %18.10e \n" , vone, vdsate ) ;
         $write( "Ids       = %18.10e \n" , idse ) ;
         $write( "gds       = %18.10e \n" , ggds ) ;
         $write( "gm        = %18.10e \n" , ggm  ) ;
         $write( "gmbs      = %18.10e \n" , ggmbs) ;
         $write( "gmt       = %18.10e \n" , ggmt) ;
         $write( "Qg        = %18.10e \n" , qge ) ;
         $write( "Qd        = %18.10e \n" , qde ) ;
         $write( "Qs        = %18.10e \n" , qse  ) ;
         $write( "Qfd,Cf    = %18.10e %18.10e \n" , Qfd, Cf ) ;
         $write( "Qfs,Cf    = %18.10e %18.10e \n" , Qfs, Cf ) ;
         $write( "cggb      = %18.10e \n" , cggbd ) ;
         $write( "cgsb      = %18.10e \n" , cgsbd ) ;
         $write( "cgdb      = %18.10e \n" , cgdbd ) ;
         $write( "cgbb      = %18.10e \n" , cgbbd ) ;
         $write( "cbgb      = %18.10e \n" , cbgbd ) ;
         $write( "cbsb      = %18.10e \n" , cbsbd ) ;
         $write( "cbdb      = %18.10e \n" , cbdbd ) ;
         $write( "cbbb      = %18.10e \n" , cbbbd ) ;
         $write( "cdgb      = %18.10e \n" , cdgbd ) ;
         $write( "cdsb      = %18.10e \n" , cdsbd ) ;
         $write( "cddb      = %18.10e \n" , cddbd ) ;
         $write( "cdbb      = %18.10e \n" , cdbbd ) ;
         $write( "Isub      = %18.10e \n" , isuba ) ;
         $write( "Igidl     = %18.10e \n" , Igidl ) ;
         $write( "Igisl     = %18.10e \n" , Igisl ) ;
         $write( "gbgs      = %18.10e \n" , ggbgs ) ;
         $write( "gbds      = %18.10e \n" , ggbds ) ;
         $write( "gbbs      = %18.10e \n" , ggbbs ) ;
       end
       // print all outputs ------------AA //

     end // Print_INFO

     
     // Noise coeff. calculation
     whi_noise = 4.0 * `C_KB* TTEMP * `Kwhite ; 

     // Drain , Substrate ,  GIDL and GISL Currents
     I(BRds)  <+  TYPE * Ids ;
     I(BRds)  <+  TYPE * (Igidl + Isub ) ;
     I(BRsd)  <+  TYPE * (Igisl + Isubs) ;

     // Gate Leakage Currents
     I(BRgps)  <+  TYPE * Igs ;
     I(BRgpd)  <+  TYPE * Igd ;
     I(BRgpbp) <+  TYPE * Igb ;

     // Inner Capacitance Currents
     I(BRgps) <+  TYPE * ddt(Qg + Qg_nqs) ;
     I(BRds)  <+  TYPE * ddt(Qd + Qd_nqs) ;
     I(BRbps) <+  TYPE * ddt(Qb + Qb_nqs) ;
     
     // Noise Currents
     // 1/F Noise
     I(BRds) <+ flicker_noise(noiflick * `Kflic , FALPH  , "iflick");
     // Induced Gate Noise
     sid    = whi_noise * noithrml;
     ci     = noicross;
     sigrat = (sid > 0.0 && noiigate > 0.0) ? sqrt(noiigate/sid) : 0.0 ;
     I(n)     <+ 1*V(n) ;
     I(n)     <+ white_noise(sid) ;
     I(BRds)  <+ white_noise((1.0-ci*ci)*sid) ;
     I(BRds)  <+ ci*V(n) ;
     I(BRgps) <+ ddt(V(n)*sigrat*(1-Qdrat)) ;
     I(BRgpd) <+ ddt(V(n)*sigrat*Qdrat) ;
     // Shot Noise
     `define C_QE2     2.0 * `C_QE      // 
     I(BRgpd)  <+ white_noise(`C_QE2 * Igd , "iigd") ;
     I(BRgps)  <+ white_noise(`C_QE2 * Igs , "iigs") ;
     I(BRgpbp) <+ white_noise(`C_QE2 * Igb , "iigb") ;
     
     // Gate Resistance Currents
     if( CORG ) begin
       I(BRggp) <+ grg * V(BRggp) ;
     end else begin
       V(BRggp) <+ 0.0 ;
     end
     
     // Collapsing Internal Substrate Node
     V(BRebp ) <+  0 ;
     
     // Thermal Node Currents 
     if(COSELFHEAT && RTH0 > 0.0) begin
       Pwr(t) <+ -Rpower + ddt(Cthe * Temp(t)) + Temp(t) * Gth ;
     end else begin
       Temp(t) <+ 0.0 ; 
     end
     
     // QHS Node Currents
     if(COHIST && COISUB && COFBE) begin
       I(nqs_qhs) <+ Iqh_nqs + ddt( `NQS_CAP * V(nqs_qhs) ) ;
     end else begin
       V(nqs_qhs) <+ 0.0 ;
     end
     
     // NQS Node Currents 
     if(CONQS) begin
       I(nqs_qi) <+ Iqi_nqs + ddt( `NQS_CAP * V(nqs_qi) ) ;
       I(nqs_qb) <+ Iqb_nqs + ddt( `NQS_CAP * V(nqs_qb) ) ;
     end else begin
       V(nqs_qi) <+ 0.0 ;
       V(nqs_qb) <+ 0.0 ;
     end
//
   end 
//================ End of executable code.=================//
endmodule
