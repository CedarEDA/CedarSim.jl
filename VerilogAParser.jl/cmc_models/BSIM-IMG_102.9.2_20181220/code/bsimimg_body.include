// ****************************************************************************
// *  BSIM-IMG 102.9.2 released by Pragya Kushwaha on 12/20/2018              *
// *  BSIM Independent Multi-Gate Model (Verilog-A)                           *
// ****************************************************************************

// ****************************************************************************
// *  Copyright Â© 2018 University of California                               *
// *                                                                          *
// *  Project director: Prof. Chenming Hu                                     *
// *                                                                          *
// *  Current developers: Pragya Kushwaha (Postdoc, UC Berkeley)              *
// *                      Harshit Agarwal (Postdoc, UC Berkeley)              *
// *                      Avirup Dasgupta (Postdoc, UC Berkeley)              *
// *                      Yen-Kai Lin     (Ph.D., UC Berkeley)                *
// *                      Chetan K. Dabhi (Ph.D., IIT Kanpur)                 *
// ****************************************************************************

/*
Licensed under Educational Community License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain a copy of the license at
http://opensource.org/licenses/ECL-2.0
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations
under the License.

BSIM-IMG model is supported by the members of Silicon Integration Initiative's Compact Model Coalition. A link to the most recent version of this
standard can be found at: http://www.si2.org/cmc 
*/
// Clamped exponential function
analog function real lexp;
    input x;
    real x;

    begin
        if (x > `EXPL_THRESHOLD) begin
            lexp = `MAX_EXPL * (1.0 + x - `EXPL_THRESHOLD);
        end else if (x < -`EXPL_THRESHOLD) begin
            lexp = `MIN_EXPL;
        end else begin
            lexp = exp(x);
        end
    end
endfunction

// Clamped log function
analog function real lln;
    input x;
    real x;

    begin
        lln = (x > `N_MINLOG) ? ln(x) : `LN_N_MINLOG;
    end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
    input x, c;
    real x, c;

    begin
        hypsmooth = 0.5 * (x + sqrt(x * x + 4.0 * c * c));
    end
endfunction

// Hyperbolic smooth max function
analog function real hypmax;
    input x, xmin, c;
    real x, xmin, c;

    begin
        hypmax = xmin + 0.5 * (x - xmin - c + sqrt((x - xmin - c) * (x - xmin - c) - 4.0 * xmin * c));
    end
endfunction

// Smooth function to fix minimum value of a variable
analog function real smoothminx;
    input x, x0, deltax;
    real x, x0, deltax;

    begin
        smoothminx = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax));
    end
endfunction

// Smoothing function for (min of x, x0 with deltax)
analog function real minx;
    input x, x0, deltax;
    real x, x0, deltax;

    begin
        minx = 0.5 * (x + x0 - sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax));
    end
endfunction



// *************************
// *  Instance Parameters  *
// *************************

// Note: Some instance parameters are also model parameters. Please refer to the technical note for details.
`IPRco( L              ,30e-9          ,"m"           ,1e-9        ,inf         ,"Designed Gate Length" )
`IPRco( W              ,1e-6           ,"m"           ,1e-9        ,inf         ,"Designed Gate Width" )
`IPIco( NF             ,1              ,""            ,1           ,inf         ,"Number of fingers" )
`IPRcz( AS             ,0.0            ,"m^2"                                   ,"Source area" )
`IPRcz( AD             ,0.0            ,"m^2"                                   ,"Drain area" )
`IPRcz( PS             ,0.0            ,"m"                                     ,"Source perimeter" )
`IPRcz( PD             ,0.0            ,"m"                                     ,"Drain perimeter" )
`IPRcz( NRS            ,0.0            ,""                                      ,"Number of source diffusion squares" )
`IPRcz( NRD            ,0.0            ,""                                      ,"Number of drain diffusion squares" )

// Variability Handles
`IPRnb( XL             ,0.0            ,"m"                                     ,"L offset for channel length due to mask/etch effect" )
`IPRnb( DTEMP          ,0.0            ,"Celsius"                               ,"Variability in Device Temperature" )
`IPRnb( DELVTRAND      ,0.0            ,"V"                                     ,"Variability in Vth" )
`IPRoz( U0MULT         ,1.0            ,""                                      ,"Variability in carrier mobility" )

// **********************
// *  Model Parameters  *
// **********************
`MPIty( TYPE           ,`ntype         ,""                                      ,"NMOS = 1, PMOS = -1" )
`MPIty( WELLTYPE       ,-TYPE          ,""                                      ,"Well (substrate) type" )
`MPIcc( CHARGEMOD      ,0              ,""            ,0           ,1           ,"0: Computationally efficient charge density model, 1: Accurate inversion charge density model")
`MPIcc( RDSMOD         ,0              ,""            ,0           ,2           ,"0: Bias-dependent S/D resistances internal and bias-independent S/D resistances external, 1: Both bias-dependent and independent of S/D resistances external, 2: Both bias-dependent and independent of S/D resistances internal" )
`MPIcc( GIDLMOD        ,0              ,""            ,0           ,1           ,"0: Turn off GIDL/GISL current, 1: Turn on GIDL/GISL current" )
`MPIcc( IGCMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd, 1: Turn on Igc, Igs and Igd" )
`MPIcc( IGBMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igb" )
`MPIcc( SHMOD          ,0              ,""            ,0           ,1           ,"0: No self-heating" )
`MPIcc( RGATEMOD       ,0              ,""            ,0           ,1           ,"Gate resistance model selector" )
`MPIcc( NQSMOD         ,0              ,""            ,0           ,1           ,"0: Turn off NQS model, 1: NQS gate resistance (with gi node)" )
`MPIcc( NFMOD          ,0              ,""            ,0           ,1           ,"0: W taken as total width like BSIM4, 1: W taken as single finger width  " )
`MPRnb( XW             ,0.0            ,"m"                                     ,"W offset for channel width due to mask/etch effect" )
`MPRnb( LINT           ,0.0            ,"m"                                     ,"Delta L for IV" )
`MPRnb( LL             ,0.0            ,"m^(1+LLN)"                             ,"" )
`MPRnb( LW             ,0.0            ,"m^(1+LWN)"                             ,"" )
`MPRnb( LWL            ,0.0            ,"m^(LWN+LLN+1)"                         ,"" )
`MPRnb( LLN            ,1.0            ,""                                      ,"" )
`MPRnb( LWN            ,1.0            ,""                                      ,"" )
`MPRnb( WINT           ,0.0            ,"m"                                     ,"Delta W for IV" )
`MPRnb( WL             ,0.0            ,"m^(1+WLN)"                             ,"" )
`MPRnb( WW             ,0.0            ,"m^(1+WWN)"                             ,"" )
`MPRnb( WWL            ,0.0            ,"m^(WLN+WWN+1)"                         ,"" )
`MPRnb( WLN            ,1.0            ,""                                      ,"" )
`MPRnb( WWN            ,1.0            ,""                                      ,"" )
`MPRnb( DLC            ,0.0            ,"m"                                     ,"Delta L for CV" )
`MPRnb( LLC            ,0.0            ,"m"                                     ,"" )
`MPRnb( LWC            ,0.0            ,"m"                                     ,"" )
`MPRnb( LWLC           ,0.0            ,"m"                                     ,"" )
`MPRnb( DWC            ,0.0            ,"m"                                     ,"Delta W for CV" )
`MPRnb( WLC            ,0.0            ,"m"                                     ,"" )
`MPRnb( WWC            ,0.0            ,"m"                                     ,"" )
`MPRnb( WWLC           ,0.0            ,"m"                                     ,"" )
`MPRco( EOT1           ,1.0e-9         ,"m"           ,0.1e-9      ,inf         ,"Equivalent front gate dielectric thickness relative to SiO2" )
`MPRco( EOT2           ,10e-9          ,"m"           ,0.1e-9      ,inf         ,"Equivalent back  gate dielectric thickness relative to SiO2" )
`MPRco( EOT1P          ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"Equivalent physical front gate dielectric thickness relative to SiO2" )
`MPRnb( DTOX1          ,0.0            ,"m"                                     ,"Difference between effective dielectric thickness and physical thickness" )
`MPRco( TSI            ,8.0e-9         ,"m"           ,1e-9        ,inf         ,"Body thickness" )
`MPRcc( NBODY          ,1e22           ,"m^-3"        ,1e18        ,5e24        ,"Channel (body) doping" )
`MPRcc( NSD            ,2e26           ,"m^-3"        ,2e25        ,1e27        ,"Source/drain active doping concentration" )
`MPRcz( NBG            ,5.0e23         ,"m^-3"                                  ,"Well/substrate (or also called back-gate) doping, zero for metal" )
`MPRcz( EASUB          ,4.05           ,"eV"                                    ,"Electron affinity of well/substrate" )
`MPRoz( NI0SUB         ,1.1e16         ,"m^-3"                                  ,"Intrinsic carrier constant at 300.15K" )
`MPRoz( BG0SUB         ,1.12           ,"eV"                                    ,"Band gap of well/substrate at 300.15K" )
`MPRoz( NC0SUB         ,2.86e25        ,""                                      ,"Conduction band density of states" )
`MPRoz( PHIG1          ,4.61           ,"eV"                                    ,"Front Gate Workfunction" )
`MPRoz( PHIG2          ,((WELLTYPE == `ptype) ? (EASUB + BG0SUB) : EASUB),"eV"  ,"Back gate workfunction, will be modified according to NBG later in the code" )
`MPRoz( EPSRSUB        ,11.9           ,""                                      ,"Relative dielectric constant of the channel material" )
`MPRoz( EPSROX1        ,3.9            ,""                                      ,"Relative dielectric constant of the front gate dielectric" )

 // Short Channel Effects
`MPRnb( ASCL           ,0.0            ,""                                      ,"Parameter for back-gate dependent scale length" )
`MPRnb( BSCL           ,0.0            ,"V^-1"                                  ,"Parameter for back-gate dependent scale length" )
`MPRnb( CIT            ,0.0            ,"F/(m^2)"                               ,"Parameter for interface trap" )
`MPRnb( CDSC           ,0.14           ,"F/(m^2)"                               ,"Coupling capacitance between S/D and channel" )
`MPRnb( CDSCD          ,0.14           ,"F/(m^2*V)"                             ,"Drain-bias sensitivity of CDSC" )
`MPRnb( CBGCBG0        ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG0P       ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG         ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of CDSC" )
`MPRnb( CBGCBGP        ,0.0            ,"F/(m^2*V^2)"                           ,"Nonlinear backgate-bias sensitivity of SS" )
`MPRnb( CBGCBGD        ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of CDSCD" )
`MPRnb( DVT0           ,19.20          ,""                                      ,"SCE coefficient" )
`MPRnb( DVT1           ,0.45           ,""                                      ,"SCE exponent coefficient" )
`MPRnb( PHIN           ,0.045          ,"V"                                     ,"Nonuniform vertical doping effect on surface potential" )
`MPRnb( ETA0           ,2.00           ,""                                      ,"DIBL coefficient 1" )
`MPRnb( ETA1           ,0.00           ,""                                      ,"DIBL coefficient for low gate overdrive" )
`MPRnb( DSUB           ,0.375          ,""                                      ,"DIBL coefficient 2 (exponent coefficient)" )
`MPRnb( DVTP0          ,0              ,""                                      ,"Coefficient for Drain-Induced Vth Shift (DITS)" )
`MPRnb( DVTP1          ,0              ,""                                      ,"DITS exponent coefficient" )
`MPRnb( ADVTP0         ,0.0            ,""                                      ,"Pre-exponential Coefficient for DITS" )
`MPRex( BDVTP0         ,100.0e-9       ,""            ,0.0                      ,"Exponential coefficient for DITS" )
`MPRnb( ADVTP1         ,0.0            ,""                                      ,"Pre-exponential coefficient for DVTP1" )
`MPRex( BDVTP1         ,100.0e-9       ,""            ,0.0                      ,"Exponential coefficient for DVTP1" )
`MPRnb( DVTP2          ,0.0            ,""                                      ,"DITS Model Parameter" )
`MPRnb( ETAB           ,0.00           ,""                                      ,"DIBL coefficient - Back Gate dependence" )
`MPRnb( K1RSCE         ,-0.32          ,""                                      ,"Vt Roll-off at moderate Lg" )
`MPRnb( LPE0           ,8.2e-9         ,"m"                                     ,"Equivalent length of pocket region at zero bias" )
`MPRnb( DSC0           ,0.0            ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" )
`MPRnb( DSC1           ,1.00e-9        ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" )

// Lateral non-uniform doping effect (IV-CV Vth shift)
`MPRnb( K0             ,0.0            ,"V"                                     ,"Lateral NUD voltage parameter" )
`MPRnb( K01            ,0.0            ,"V/K"                                   ,"Temperature dependence of lateral NUD voltage parameter" )
`MPRnb( K0SI           ,1.0            ,""                                      ,"Correction factor for strong inversion, used in Mnud, after binning should be from (0:inf)" )
`MPRnb( K0SI1          ,0.0            ,"K^-1"                                  ,"Temperature dependence of K0SI" )

// Quantum Mechanical Effects
`MPRnb( QMTCENCV       ,0.0            ,""                                      ,"Prefactor + switch for QM Width and Toxeff correction for CV" )
`MPRnb( ETAQM          ,0.54           ,""                                      ,"Bulk charge coefficient for Tcen" )
`MPRoz( QM0            ,1.00e-3        ,""                                      ,"Knee-Point for Tcen in inversion (Charge normalized to Cox)" )
`MPRnb( PQM            ,0.66           ,""                                      ,"Slope of normalized Tcen in inversion" )
`MPRco( TOXP           ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"physical oxide thickness" )

// Velocity Saturation Model
`MPRnb( VSAT           ,85000          ,"m/s"                                   ,"Saturation Velocity" )
`MPRnb( AVSAT          ,0.0            ,"m/s"                                   ,"" )
`MPRex( BVSAT          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( VSAT1          ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter" )
`MPRnb( AVSAT1         ,AVSAT          ,"m/s"                                   ,"" )
`MPRex( BVSAT1         ,BVSAT          ,"m"           ,0.0                      ,"" )
`MPRnb( VSATCV         ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter for CV" )
`MPRnb( AVSATCV        ,AVSAT          ,"m/s"                                   ,"" )
`MPRex( BVSATCV        ,BVSAT          ,"m"           ,0.0                      ,"" )
`MPRnb( DELTAVSAT      ,1.0            ,"m/s"                                   ,"Velocity saturation parameter" )
`MPRnb( KSATIV         ,1.0            ,""                                      ,"Parameter for strong inversion regime for long channel Vdsat" )
`MPRnb( KSUBIV         ,1.0            ,""                                      ,"Parameter for weak inversion regime for long channel Vdsat" )
`MPRnb( MEXP           ,4.0            ,""                                      ,"Smoothing function factor for Vdsat" )
`MPRnb( AMEXP          ,0.0            ,""                                      ,"" )
`MPRnb( BMEXP          ,1.0            ,""                                      ,"" )
`MPRnb( PTWG           ,0.0            ,"V^-2"                                  ,"Correction factor for velocity saturation" )
`MPRnb( APTWG          ,0.0            ,"V^-2"                                  ,"" )
`MPRex( BPTWG          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( AT             ,-1.56e-3       ,""                                      ,"Saturation Velocity Temperature Coefficient" )
`MPRnb( ATL            ,0.0            ,""                                      ,"Length scaling for AT" )
`MPRnb( TMEXP          ,0.0            ,""                                      ,"" )
`MPRnb( PTWGT          ,0.004          ,""                                      ,"" )
`MPRnb( PTWGB          ,0.0            ,"V^-3"                                  ,"" )
`MPRnb( PTWGB2         ,0.0            ,"V^-3"                                  ,"" )
`MPRnb( APTWGB         ,0.0            ,"V^-3"                                  ,"" )
`MPRex( BPTWGB         ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( APTWGB2        ,0.0            ,"V^-3"                                  ,"" )
`MPRex( BPTWGB2        ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( VSATB          ,0.0            ,"V^-1"                                  ,"" )
`MPRnb( ATB            ,0.0            ,""                                      ,"Back bias sensitivity parameter for saturation velocity temperature coefficient" )
`MPRnb( ATBL           ,0.0            ,""                                      ,"Length scaling for ATB" )
`MPRnb( AVSATB         ,0.0            ,"V^-1"                                  ,"" )
`MPRex( BVSATB         ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRco( DVSATCLAMP     ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dvsat" )

// Mobility Model
`MPRex( U0             ,0.03           ,"m^2/(V*s)"   ,0.0                      ,"Low Field Mobility" )
`MPRnb( ETAMOB         ,2.0            ,""                                      ,"" )
`MPRnb( UP             ,0.0            ,"(um)^LPA"                              ,"" )
`MPRnb( LPA            ,1.0            ,""                                      ,"" )
`MPRnb( UA             ,0.3            ,"(MV/cm)^(-EU)"                         ,"" )
`MPRnb( AUA            ,0.0            ,"(MV/cm)^(-EU)"                         ,"" )
`MPRex( BUA            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( EU             ,2.5            ,"cm/MV"                                 ,"" )
`MPRnb( AEU            ,0.0            ,"cm/MV"                                 ,"" )
`MPRex( BEU            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UC             ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" )
`MPRnb( AUC            ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" )
`MPRex( BUC            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UD             ,0.0            ,""                                      ,"" )
`MPRnb( AUD            ,0.0            ,""                                      ,"" )
`MPRex( BUD            ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRnb( UDB            ,0.0            ,"V^-1"                                  ,"" )
`MPRnb( AUDB           ,0.0            ,"V^-1"                                  ,"" )
`MPRex( BUDB           ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRco( DMOBCLAMP      ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dmob" )
`MPRnb( UCS            ,1.0            ,""                                      ,"" )
`MPRnb( UTE            ,0.0            ,""                                      ,"" )
`MPRnb( UTL            ,-1.5e-3        ,""                                      ,"" )
`MPRnb( UA1            ,1.032e-3       ,""                                      ,"" )
`MPRnb( UC1            ,0.0            ,""                                      ,"" )
`MPRnb( UD1            ,0.0            ,""                                      ,"" )
`MPRnb( UCSTE          ,-4.775e-3      ,""                                      ,"" )
`MPRcc( CHARGEWF       ,0.0            ,""            ,-1.0        ,1.0         ,"Average Channel Charge Weighting Factor, +1 :source-side, 0: middle, -1: drain-side" )

// Access Resistance Model
`MPRcz( RDSWMIN        ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 0 S/D extension resistance per unit width at high Vgs" )
`MPRcz( RDSW           ,100.0          ,"ohm*um^WR"                             ,"RDSMOD = 0 zero bias S/D extension resistance per unit width" )
`MPRnb( ARDSW          ,0.0            ,"ohm*um^WR"                             ,"" )
`MPRex( BRDSW          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRcz( RSWMIN         ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 1 source extension resistance per unit width at high Vgs" )
`MPRcz( RSW            ,50.0           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias source extension resistance per unit width" )
`MPRnb( ARSW           ,0.0            ,"ohm*um^W"                              ,"Pre-exponential coefficient for RSW" )
`MPRex( BRSW           ,100.0e-9       ,"m"           ,0.0                      ,"Exponential coefficient for RSW" )
`MPRcz( RDWMIN         ,RSWMIN         ,"ohm*um^WR"                             ,"RDSMOD = 1 drain extension resistance per unit width at high Vgs" )
`MPRcz( RDW            ,RSW            ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias drain extension resistance per unit width" )
`MPRnb( ARDW           ,ARSW           ,"ohm*um^WR"                             ,"" )
`MPRex( BRDW           ,BRSW           ,"m"           ,0.0                      ,"" )
`MPRnb( PRWG           ,0              ,"V^-1"                                  ,"Gate bias dependence of source/drain extension resistance" )
`MPRnb( PRWB           ,0              ,"V^-1"                                  ,"" )
`MPRnb( WR             ,1.0            ,"V^-1"                                  ,"W dependence parameter of S/D extension resistance" )
`MPRnb( PRT            ,0.001          ,"K^-1"                                  ,"Series Resistance Temperature coefficient" )

// DIBL Model
`MPRnb( PDIBL1         ,1.30           ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( PDIBL2         ,2.0e-4         ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( DROUT          ,1.06           ,""                                      ,"L dependence of DIBL effect on Rout" )
`MPRnb( PVAG           ,1.0            ,""                                      ,"Vgs dependence on early voltage" )

// Channel Length Modulation Effect
`MPRnb( PCLM           ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter" )
`MPRnb( APCLM          ,0.0            ,""                                      ,"" )
`MPRex( BPCLM          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( PCLMG          ,0.0            ,""                                      ,"Gate bias dependent parameter for channel Length Modulation (CLM)" )
`MPRnb( PCLMCV         ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter for C-V" )

// Geometry dependent Source/Drain Resistance RGEOMOD=0
`MPRcz( RSHS           ,0.0            ,"ohm"                                   ,"Source-side sheet resistance" )
`MPRcz( RSHD           ,RSHS           ,"ohm"                                   ,"Drain-side sheet resistance" )

// Gate Tunneling Current, from gate to channel, Igc
`MPRnb( AIGBINV        ,1.11e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in inversion" )
`MPRnb( BIGBINV        ,9.49e-4        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in inversion" )
`MPRnb( CIGBINV        ,6.00e-3        ,"V^-1"                                  ,"Parameter for Igb in inversion" )
`MPRnb( EIGBINV        ,1.1            ,"V"                                     ,"Parameter for Igb in inversion" )
`MPRnb( NIGBINV        ,3.0            ,""                                      ,"Parameter for Igb in inversion" )
`MPRnb( AIGBACC        ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in accumulation" )
`MPRnb( BIGBACC        ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in accumulation" )
`MPRnb( CIGBACC        ,7.5e-2         ,"V^-1"                                  ,"Parameter for Igb in accumulation" )
`MPRnb( NIGBACC        ,1.0            ,""                                      ,"Parameter for Igb in accumulation" )
`MPRnb( AIGC           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igc in inversion" )
`MPRnb( BIGC           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igc in inversion" )
`MPRnb( CIGC           ,0.075          ,"V^-1"                                  ,"Parameter for Igc in inversion" )
`MPRnb( PIGCD          ,1.0            ,""                                      ,"Parameter for Igc partition" )
`MPRnb( DIGC           ,1.0            ,""                                      ,"Parameter for Igc in inversion" )

// Gate Tunneling Current, from gate to S/D, Igs and Igd
`MPRnb( AIGS           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igs, Igd" )
`MPRnb( BIGS           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igs, Igd" )
`MPRnb( CIGS           ,0.075          ,"V^-1"                                  ,"Parameter for Igs, Igd" )
`MPRcz( DLCIGS         ,0              ,""                                      ,"Delta L for Igs model" )
`MPRcz( DLCIGD         ,DLCIGS         ,""                                      ,"Delta L for Igd model" )
`MPRnb( AIGD           ,AIGS           ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igd in inversion" )
`MPRnb( BIGD           ,BIGS           ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igd in inversion" )
`MPRnb( CIGD           ,CIGS           ,"V^-1"                                  ,"Parameter for Igs, Igd" )
`MPRoz( TOXREF         ,1.2e-9         ,"m"                                     ,"Target tox value" )
`MPRnb( NTOX           ,1.0            ,""                                      ,"Exponent for Tox ratio" )
`MPRnb( POXEDGE        ,1.0            ,""                                      ,"Factor for the gate edge Tox" )
`MPRnb( DIGS           ,1.0            ,""                                      ,"Parameter for Igs, Igd" )
`MPRnb( DIGD           ,DIGS           ,""                                      ,"Parameter for Igs, Igd" )

// Gate-induced source/drain leakage
`MPRnb( AGIDL          ,6.055e-12      ,"mho"                                   ,"Pre-exponential coefficient for GIDL" )
`MPRnb( BGIDL          ,0.3e9          ,"V/m"                                   ,"Exponential coefficient for GIDL" )
`MPRnb( EGIDL          ,0.2            ,"V"                                     ,"Band bending parameter for GIDL" )
`MPRnb( PGIDL          ,1.0            ,""                                      ,"Parameter for body-bias effect on GIDL" )
`MPRnb( VBGIDL         ,1.0            ,""                                      ,"Back gate correction factor for GIDL" )
`MPRnb( VBEGIDL        ,0.5            ,"V"                                     ,"Back band bending parameter for GIDL" )
`MPRnb( AGISL          ,AGIDL          ,"mho"                                   ,"Pre-exponential coefficient for GISL" )
`MPRnb( BGISL          ,BGIDL          ,"V/m"                                   ,"Exponential coefficient for GISL" )
`MPRnb( EGISL          ,EGIDL          ,"V"                                     ,"Band bending parameter for GISL" )
`MPRnb( PGISL          ,PGIDL          ,""                                      ,"Parameter for body-bias effect on GISL" )
`MPRnb( VBGISL         ,VBGIDL         ,""                                      ,"Back gate correction factor for GISL" )
`MPRnb( VBEGISL        ,VBEGIDL        ,"V"                                     ,"Back band bending parameter for GISL" )

// Impact Ionization Current
`MPRnb( ALPHA0         ,0.0            ,"m/V"                                   ,"First parameter of Iii" )
`MPRnb( ALPHA1         ,0.0            ,"V^-1"                                  ,"L scaling parameter of Iii" )
`MPRnb( BETA0          ,0.0            ,"V^-1"                                  ,"Vds dependent parameter of Iii" )

// Overlap and Fringing Capacitances
`MPRnb( LOVS           ,0.0            ,"m"                                     ,"Overlap length from FG to S" )
`MPRnb( LOVD           ,LOVS           ,"m"                                     ,"Overlap length from FG to D" )
`MPRcz( CFS            ,0.0            ,"F/m"                                   ,"Outer fringing capacitance at the source side" )
`MPRcz( CFD            ,CFS            ,"F/m"                                   ,"Outer fringing capacitance at the drain side" )
`MPRcz( CGSL           ,0.0            ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped source region" )
`MPRcz( CGDL           ,CGSL           ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped drain region" )
`MPRco( CKAPPAS        ,0.6            ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the source side" )
`MPRco( CKAPPAD        ,CKAPPAS        ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the drain side" )
`MPRnb( CSDBGSW        ,0.0            ,"F/m"                                   ,"Source/drain sidewall fringing capacitance per unit length" )
`MPRnb( PCOVBS0        ,0.0            ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the source side" )
`MPRnb( PCOVBS1        ,0.0            ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the source side" )
`MPRnb( PCOVBD0        ,PCOVBS0        ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the drain side" )
`MPRnb( PCOVBD1        ,PCOVBS1        ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the drain side" )

// Back gate biasing effect, gamma = d_Vth / d_Vbg
// P-well
`MPRnb( KBG0PW         ,1.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG1PW         ,0.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG2PW         ,-1.0           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( DBGPW          ,0.12           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( BPFACTORPW     ,0.0            ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1PW       ,0.0            ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2PW       ,1.0            ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// N-well
`MPRnb( KBG0NW         ,KBG0PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG1NW         ,KBG1PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG2NW         ,KBG2PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( DBGNW          ,DBGPW          ,""                                      ,"Length dependence of body factor" )
`MPRnb( BPFACTORNW     ,BPFACTORPW     ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1NW       ,VKNEE1PW       ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2NW       ,VKNEE2PW       ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// Flicker Noise
`MPRoc( EF             ,1.0            ,""            ,0.0         ,2.0         ,"Flicker noise frequency exponent" )
`MPRnb( EM             ,4.1e7          ,"V/m"                                   ,"Flicker noise parameter" )
`MPRnb( NOIA           ,6.25e39        ,"(eV^-1)*(s^(1-EF))*(m^-3)"             ,"Flicker noise parameter" )
`MPRnb( NOIB           ,3.125e24       ,"(eV^-1)*(s^(1-EF))*(m^-1)"             ,"Flicker noise parameter" )
`MPRnb( NOIC           ,8.75e7         ,"(eV^-1)*(s^(1-EF))*(m)"                ,"Flicker noise parameter" )
`MPRnb( LINTNOI        ,0.0            ,"m"                                     ,"Lint offset for flicker noise calculation" )

// Thermal Noise
`MPRcz( NTNOI          ,1.0            ,""                                      ,"Thermal noise parameter" )

// Temperature Effects
`MPRco( TNOM           ,27.0           ,"Celsius"     ,-273.15     ,inf         ,"Temperature at which the model is extracted" )
`MPRnb( TMAXC          ,400.0          ,"Celsius"                               ,"Maximum Device Temperature" )
`MPRnb( TBGASUB        ,7.02e-4        ,"eV/K"                                  ,"Bandgap Temperature Coefficient" )
`MPRnb( TBGBSUB        ,1108.0         ,"K"                                     ,"Bandgap Temperature Coefficient" )
`MPRnb( KT1            ,0.0            ,"V"                                     ,"Vth Temperature Coefficient" )
`MPRnb( KT1L           ,0.0            ,"V*m"                                   ,"Vth Temperature L Coefficient" )
`MPRnb( KT2            ,0.0            ,""                                      ,"Vth Temperature Vbg Coefficient" )
`MPRnb( KT2L           ,0.0            ,"m"                                     ,"Vbg Temperature L Coefficient" )
`MPRnb( IIT            ,-0.5           ,""                                      ,"Impact Ionization Temperature Dependence" )
`MPRnb( TGIDL          ,-0.003         ,"K^-1"                                  ,"GIDL Temperature Dependence" )
`MPRnb( TGISL          ,TGIDL          ,"K^-1"                                  ,"GISL Temperature Dependence" )
`MPRnb( IGT            ,2.5            ,""                                      ,"Gate Current Temperature Dependence" )
`MPRnb( TETA0          ,0.0            ,"K^-1"                                  ,"Temperature Dependence for DIBL effects" )

// Self Heating
`MPRcz( RTH0           ,0.01           ,"ohm*m*K/W"                             ,"Thermal resistance" )
`MPRcz( CTH0           ,1.0e-5         ,"W*s/m/K"                               ,"Thermal capacitance" )
`MPRcz( WTH0           ,0.0            ,"m"                                     ,"Width dependence coefficient for Rth and Cth" )

`MPRnb( XGW        ,0.0            ,"m"                                     ,"Distance from gate contact center to device edge" )
`MPRoo( XGL        ,0.0            ,"m"           ,-inf        ,L + XL      ,"Variation in Ldrawn" )
`MPIcc( NGCON      ,1              ,""            ,1           ,2           ,"Number of gate contacts" )
`MPRcz( RSHG       ,0.1            ,"ohm"                                   ,"Gate sheet resistance" )

// For NQSMOD = 1, Set XRCRG1 = 0 to turn off NQS gate resistance
`MPRnb( XRCRG1     ,12.0           ,""                                      ,"Parameter for Rg in NQSMOD = 1" )
`MPRnb( XRCRG2     ,1.0            ,""                                      ,"Parameter for Rg in NQSMOD = 1" )

// Binning Parameters
`include "bsimimg_binning.include"

// ***************
// *  Variables  *
// ***************

// Common Variables
real Lnew, LeffCV, Leff, Weff, WeffCV, Wnew, L_LLN, W_LWN, LW_LLN_LWN, dLIV, L_WLN, W_WWN, LW_WLN_WWN, dWIV, dLCV, dWCV;
real epssi, cox1, cox1P, cox2, csi, epsratio;
real vfgs, vbgs, vbgd, vbgx, vds, sigvds, vbgxpos;
real vgs_noswap, vds_noswap, vgd_noswap, vbgs_noswap, vbgd_noswap;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
real qia, qia2, qba, dqi;
real phib, phisub, deltaphi1, deltaphi2;
real Eg, Vtm;
real beta;
real wf, wr;
real Nc;
real qb0;
real dvth_nbody;
real tmp, QMTCENCV_i, Tcen0, Tcen, coxeff;
real ETAQM_i, QM0_i, PQM_i;

// Terminal Voltage Conditioning Variables
real vgfb1, vgfb2, vgfb1eff, vgfb2eff;
real vdsx, symmetry_factor;

// Short Channel Effects
real scl, sclm, sclf, teff, temp;
real vbi, nVtm, dvth_dibl, dvth_vtroll, dvth_rsce, dvth_dsc, dvth_all, phist;
real Theta_SCE, Theta_RSCE, Theta_DIBL;

// DITS Model parameters
real Theta_DITS, DVTP0_i, DVTP1_i;

// Lateral Non-uniform Doping Effect
real Mnud;

// Temperature Effects
real Tnom, TRatio, delTemp;
real PhiRef, PhiSD, ni;
real dvth_temp, dvth_temp0;
real BETA0_t, BGIDL_t, BGISL_t, igtemp, ETA0_t;

`bsimimg_sp_global_variables

// Drain Saturation Voltage
real qis, qid, qbs, Dmobs, Vdseff;

real eta_mu, eta_mu_cv, Eeffm, Eeffm_cv, Dmob, Dmob_cv, u0, ueff;
real UA_t, UC_t, UCS_t, UD_t, U0_t, Eeffs, EeffFactor;
real Dr, WeffWRFactor;
real RSourceGeo, RDrainGeo;
real RDSWMIN_i, RDWMIN_i, RSWMIN_i;
real UDB_i;


real Rdrain, Rsource;
real gspr, gdpr;


real rdstemp, Rdsi, Rdss;
real DIBLfactor, PVAGfactor, diffVds, VaDIBL, Vgst2Vtm, Moc, Mclm, MclmCV;
real Dvsat, Vdsat, inv_MEXP;
real VSAT_t, VSATB_t, VSAT1_t, VSATCV_t, MEXP_t, Esat, EsatL, EsatCV, EsatCVL, Esat1, Esat1L;
real K0_t, K0SI_t;
real WVCox, Ta, Tb, Tc;
real Xsat;
real PTWG_t;

// Gate Current
real Vaux_Igbinv, igbinv, igsd_mult, igsd_mult0, igbs, igbd;
real Voxacc, Vaux_Igbacc, vfbzb, igbacc;
real igcs, igcd, igc0, Vdseffx, T1_exp;
real igisl, igidl, vfbsd, vfbsd_bg, igs, igd, vfgs_eff, vfgd_eff;
real Aechvb, Bechvb, Toxratio, Toxratioedge;
real vgbg;

// Impact Ionization current
real Iii;

// IV Variables
integer devsign, welsign;
real ids, ids0, ids0_ov_dqi;

// CV Variables
real qs, qd, qd1, qd2, qfg, qbg;
real IMGTOXP;
real qsi, qdi,qfgi, qbgi;

// Parasitic Capacitance
real qfgs_parasitic, qfgd_parasitic, qfgs_ov, qfgs_of, qfgd_ov, qfgd_of;
real vfgs_ov, vfgd_ov;
real vgd_ov_noswap, vgs_ov_noswap;
real csbox, cdbox, Qsbg, Qdbg;

// Back-gate biasing effects
real kvbg, dvth_vbg, gamma0, vsubdep0, vsubdep, vknee1, vknee2, bpfactor;

// Flicker Noise
real LINTNOI_i;
real litl, Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real qinv;
real Gtnoi, sid;
real Nt;

// Self Heating
real gth, cth;
real DevTemp, TMAXK;

// Gate resistances

real Grgeltd;

// NQS gate resistance

real gcrg, XRCRG1_i, XRCRG2_i;
real IdsovVds;


// Binning
real Inv_L, Inv_W, Inv_WL;

real RDSW_i, RDW_i, RSW_i;
real PRWG_i, PRWB_i, WR_i;
real PHIG1_i, PHIG2_i;
real NSD_i, NBODY_i;
real CIT_i, CDSC_i, CDSCD_i, CBGCBG_i;
real BPFACTORPW_i, VKNEE1PW_i, VKNEE2PW_i, DBGPW_i, KBG0PW_i, KBG1PW_i, KBG2PW_i;
real BPFACTORNW_i, VKNEE1NW_i, VKNEE2NW_i, DBGNW_i, KBG0NW_i, KBG1NW_i, KBG2NW_i;
real DSC0_i, DSC1_i, ASCL_i, BSCL_i;
real DVT0_i, DVT1_i, PHIN_i;
real ETA0_i, ETA1_i, ETAB_i, DSUB_i, K1RSCE_i, LPE0_i;
real K0_i, K01_i, K0SI_i, K0SI1_i, MEXP_i;
real PTWG_i, PTWGB_i, PTWGB2_i, PTWGT_i;
real U0_i, UA_i, UC_i, UD_i, UCS_i, EU_i, UTL_i, UTE_i, UA1_i, UD1_i, UCSTE_i, ETAMOB_i;
real AT_i, ATB_i, PRT_i, IIT_i, TGIDL_i, TGISL_i, IGT_i;
real PCLM_i, PCLMCV_i, DROUT_i, PDIBL1_i, PDIBL2_i, PVAG_i,  ALPHA0_i, ALPHA1_i, BETA0_i;
real AIGC_i, BIGC_i, CIGC_i, PIGCD_i, DIGC_i;
real AGISL_i, BGISL_i, EGISL_i, PGISL_i, AGIDL_i, BGIDL_i, EGIDL_i, PGIDL_i;
real AIGS_i, BIGS_i, CIGS_i, DIGS_i, AIGD_i, BIGD_i, CIGD_i, DIGD_i;
real VBGIDL_i, VBEGIDL_i, VBGISL_i, VBEGISL_i;
real POXEDGE_i, NTOX_i, LOVS_i, LOVD_i, CFS_i, CFD_i;
real VSAT_i, VSATB_i, VSAT1_i, VSATCV_i;
real KSATIV_i, KSUBIV_i, UP_i;
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;

// Threshold operating-point
real A0, k1, qth, qsq1, qsqrt1, qcoth1, Vfb, Vthop;

// Output variables
`OPP( ID,          "A",                  "Drain current" )
`OPP( IFG,         "A",                  "Front gate current" )
`OPP( IS,          "A",                  "Source current" )
`OPP( III,         "A",                  "Impact ionization current" )
`OPP( IGIDL,       "A",                  "Gate induced drain leakage current" )
`OPP( IGISL,       "A",                  "Gate induced source leakage current" )
`OPP( IDS,         "A",                  "Channel current" )
`OPP( VDSSAT,      "V",                  "Drain-source saturation voltage" )
`OPP( GM,          "A/V",                "Transconductance" )
`OPP( GDS,         "A/V",                "Output conductance" )
`OPP( GMBS,        "A/V",                "Body transconductance" )
`OPP( VFGS,        "V",                  "Front gate-source voltage" )
`OPP( VFGD,        "V",                  "Front gate-drain voltage" )
`OPP( VDS,         "V",                  "Drain-source voltage" )
`OPP( VSBG,        "V",                  "Source-back gate voltage" )
`OPP( VDBG,        "V",                  "Drain-back gate voltage" )
`OPP( QFG,         "C",                  "Total front-gate charge" )
`OPP( QBG,         "C",                  "Total back-gate charge" )
`OPP( QD,          "C",                  "Total drain charge" )
`OPP( QS,          "C",                  "Total source charge" )
`OPP( QFGI,        "C",                  "Intrinsic front gate charge" )
`OPP( QBGI,        "C",                  "Intrinsic back gate charge" )
`OPP( QDI,         "C",                  "Intrinsic drain charge" )
`OPP( QSI,         "C",                  "Intrinsic source charge" )
`OPP( CFGFG,       "F",                  "Total front-gate capacitance" )
`OPP( CFGS,        "F",                  "Total FG-to-S capacitance" )
`OPP( CFGD,        "F",                  "Total FG-to-D capacitance" )
`OPP( CFGBG,       "F",                  "Total FG-to-BG capacitance" )
`OPP( CDFG,        "F",                  "Total D-to-FG capacitance" )
`OPP( CDS,         "F",                  "Total D-to-S capacitance" )
`OPP( CDD,         "F",                  "Total drain capacitance" )
`OPP( CDBG,        "F",                  "Total D-to-BG capacitance" )
`OPP( CSFG,        "F",                  "Total S-to-FG capacitance" )
`OPP( CSS,         "F",                  "Total source capacitance" )
`OPP( CSD,         "F",                  "Total S-to-D capacitance" )
`OPP( CSBG,        "F",                  "Total S-to-BG capacitance" )
`OPP( CBGFG,       "F",                  "Total BG-to-FG capacitance" )
`OPP( CBGS,        "F",                  "Total BG-to-S capacitance" )
`OPP( CBGD,        "F",                  "Total BG-to-D capacitance" )
`OPP( CBGBG,       "F",                  "Total back-gate capacitance" )
`OPP( CFGFGI,      "F",                  "Intrinsic front-gate capacitance" )
`OPP( CFGSI,       "F",                  "Intrinsic FG-to-S capacitance" )
`OPP( CFGDI,       "F",                  "Intrinsic FG-to-D capacitance" )
`OPP( CFGBGI,      "F",                  "Intrinsic FG-to-BG capacitance" )
`OPP( CSFGI,       "F",                  "Intrinsic S-to-FG capacitance" )
`OPP( CSSI,        "F",                  "Intrinsic source capacitance" )
`OPP( CSDI,        "F",                  "Intrinsic S-to-D capacitance" )
`OPP( CSBGI,       "F",                  "Intrinsic S-to-BG capacitance" )
`OPP( CDFGI,       "F",                  "Intrinsic D-to-FG capacitance" )
`OPP( CDSI,        "F",                  "Intrinsic D-to-S capacitance" )
`OPP( CDDI,        "F",                  "Intrinsic drain capacitance" )
`OPP( CDBGI,       "F",                  "Intrinsic D-to-BG capacitance" )
`OPP( CBGFGI,      "F",                  "Intrinsic BG-to-FG capacitance" )
`OPP( CBGSI,       "F",                  "Intrinsic BG-to-S capacitance" )
`OPP( CBGDI,       "F",                  "Intrinsic BG-to-D capacitance" )
`OPP( CBGBGI,      "F",                  "Intrinsic back-gate capacitance" )
`OPP( VTH,         "V",                  "Threshold voltage" )
`OPP( T_TOTAL_K,   "Kelvin",             "Device temperature in Kelvin" )
`OPP( T_TOTAL_C,   "Celsius",            "Device temperature in Celsius" )
`OPP( T_DELTA_SH,  "Kelvin or Celsius",  "Delta temperature by self-heating" )

analog begin

// *************************************
// *  Geometry dependent calculations  *
// *************************************

// Variable initialization

    Rdrain  = 0.0;
    Rsource = 0.0;
    gspr    = 0.0;
    gdpr    = 0.0;
    gcrg    = 0.0;
    Grgeltd = 0.0;

    if ($port_connected(t) == 1) begin
        if (SHMOD == 0 || RTH0 == 0.0) begin
            $strobe("The optional 5th terminal is present but not active because SHMOD = 0 or RTH0 = 0.0");
        end
    end


    if (TYPE == `ntype) begin
        devsign = 1;
    end else begin
        devsign = -1;
    end

    if (WELLTYPE == `ntype) begin
        welsign = 1;
    end else begin
        welsign = -1;
    end

    // Constants
    epssi = EPSRSUB * `EPS0;

    // W calculation for different NFMOD options
    if (NFMOD == 0) begin
        Wnew = W / NF;
    end else begin
        Wnew = W;
    end

    // Leff and Weff for IV and CV
    Lnew       = L + XL;
    Wnew       = Wnew + XW;
    L_LLN      = pow(Lnew, -LLN);
    W_LWN      = pow(Wnew, -LWN);
    LW_LLN_LWN = L_LLN * W_LWN;
    dLIV       = LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;

    L_WLN      = pow(Lnew, -WLN);
    W_WWN      = pow(Wnew, -WWN);
    LW_WLN_WWN = L_WLN * W_WWN;
    dWIV       = WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;

    Leff = Lnew - 2.0 * dLIV;

    if (Leff <= 0.0) begin
        $strobe("Fatal: Effective channel length = %e for %M is non-positive", Leff);
        $finish(0);
    end else if (Leff <= 1.0e-9) begin
        $strobe("Warning: Effective channel length = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);
    end

    Weff = Wnew - 2.0 * dWIV;

    if (Weff <= 0.0) begin
        $strobe("Fatal: Effective channel Width = %e for  %M is non-positive", Weff);
        $finish(0);
    end else if (Weff <= 1.0e-9) begin
        $strobe("Warning: Effective channel width = %e for  %M is <= 1.0e-9. Recommended Weff >= 1e-8", Leff);
    end

    // Leff and Weff for CV
    dLCV   = DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
    dWCV   = DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
    LeffCV = Lnew - 2.0 * dLCV;

    if (LeffCV <= 0.0) begin
        $strobe("Fatal: Effective channel length for CV = %e for %M is non-positive", LeffCV);
        $finish(0);
    end else if (LeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel length for CV = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", LeffCV);
    end

    WeffCV = Wnew - 2.0 * dWCV;

    if (WeffCV <= 0.0) begin
        $strobe("Fatal: Effective channel width for CV = %e for %M is non-positive", WeffCV);
        $finish(0);
    end else if (WeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel width for CV = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", WeffCV);
    end

    // Binning
    Inv_L  = 1.0e-6 / Leff;
    Inv_W  = 1.0e-6 / Weff;
    Inv_WL = Inv_L * Inv_W;

    // Binning calculations
    RDSW_i   = RDSW + LRDSW * Inv_L + WRDSW * Inv_W + PRDSW * Inv_WL;
    RDW_i    = RDW + LRDW * Inv_L + WRDW * Inv_W + PRDW * Inv_WL;
    RSW_i    = RSW + LRSW * Inv_L + WRSW * Inv_W + PRSW * Inv_WL;
    PRWG_i   = PRWG + LPRWG * Inv_L + WPRWG * Inv_W + PPRWG * Inv_WL;
    PRWB_i   = PRWB + LPRWB * Inv_L + WPRWB * Inv_W + PPRWB * Inv_WL;
    WR_i     = WR + LWR * Inv_L + WWR * Inv_W + PWR * Inv_WL;
    PHIG1_i  = PHIG1 + LPHIG1 * Inv_L + WPHIG1 * Inv_W + PPHIG1 * Inv_WL;
    PHIG2_i  = PHIG2 + LPHIG2 * Inv_L + WPHIG2 * Inv_W + PPHIG2 * Inv_WL;
    NSD_i    = NSD + LNSD * Inv_L + WNSD * Inv_W + PNSD * Inv_WL;
    NBODY_i  = NBODY + LNBODY * Inv_L + WNBODY * Inv_W + PNBODY * Inv_WL;
    CIT_i    = CIT + LCIT * Inv_L + WCIT * Inv_W + PCIT * Inv_WL;
    CDSC_i   = CDSC + LCDSC * Inv_L + WCDSC * Inv_W + PCDSC * Inv_WL;
    CDSCD_i  = CDSCD + LCDSCD * Inv_L + WCDSCD * Inv_W + PCDSCD * Inv_WL;
    CBGCBG_i = CBGCBG + LCBGCBG * Inv_L + WCBGCBG * Inv_W + PCBGCBG * Inv_WL;

    BPFACTORPW_i = BPFACTORPW + LBPFACTORPW * Inv_L + WBPFACTORPW * Inv_W + PBPFACTORPW * Inv_WL;

    if (BPFACTORPW_i < 0.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is negative. Set to 0.0.", BPFACTORPW_i);
        BPFACTORPW_i = 0.0;
    end else if (BPFACTORPW_i > 1.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORPW_i);
        BPFACTORPW_i = 1.0;
    end

    VKNEE1PW_i   = VKNEE1PW + LVKNEE1PW * Inv_L + WVKNEE1PW * Inv_W + PVKNEE1PW * Inv_WL;
    VKNEE2PW_i   = VKNEE2PW + LVKNEE2PW * Inv_L + WVKNEE2PW * Inv_W + PVKNEE2PW * Inv_WL;
    DBGPW_i      = DBGPW + LDBGPW * Inv_L + WDBGPW * Inv_W + PDBGPW * Inv_WL;
    KBG0PW_i     = KBG0PW + LKBG0PW * Inv_L + WKBG0PW * Inv_W + PKBG0PW * Inv_WL;
    KBG1PW_i     = KBG1PW + LKBG1PW * Inv_L + WKBG1PW * Inv_W + PKBG1PW * Inv_WL;
    KBG2PW_i     = KBG2PW + LKBG2PW * Inv_L + WKBG2PW * Inv_W + PKBG2PW * Inv_WL;
    BPFACTORNW_i = BPFACTORNW + LBPFACTORNW * Inv_L + WBPFACTORNW * Inv_W + PBPFACTORNW * Inv_WL;

    if (BPFACTORNW_i < 0.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is negative. Set to 0.0.", BPFACTORNW_i);
        BPFACTORNW_i = 0.0;
    end else if (BPFACTORNW_i > 1.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORNW_i);
        BPFACTORNW_i = 1.0;
    end

    VKNEE1NW_i = VKNEE1NW + LVKNEE1NW * Inv_L + WVKNEE1NW * Inv_W + PVKNEE1NW * Inv_WL;
    VKNEE2NW_i = VKNEE2NW + LVKNEE2NW * Inv_L + WVKNEE2NW * Inv_W + PVKNEE2NW * Inv_WL;
    DBGNW_i    = DBGNW + LDBGNW * Inv_L + WDBGNW * Inv_W + PDBGNW * Inv_WL;
    KBG0NW_i   = KBG0NW + LKBG0NW * Inv_L + WKBG0NW * Inv_W + PKBG0NW * Inv_WL;
    KBG1NW_i   = KBG1NW + LKBG1NW * Inv_L + WKBG1NW * Inv_W + PKBG1NW * Inv_WL;
    KBG2NW_i   = KBG2NW + LKBG2NW * Inv_L + WKBG2NW * Inv_W + PKBG2NW * Inv_WL;
    DVT0_i     = DVT0 + LDVT0 * Inv_L + WDVT0 * Inv_W + PDVT0 * Inv_WL;
    DVT1_i     = DVT1 + LDVT1 * Inv_L + WDVT1 * Inv_W + PDVT1 * Inv_WL;
    PHIN_i     = PHIN + LPHIN * Inv_L + WPHIN * Inv_W + PPHIN * Inv_WL;
    ETA0_i     = ETA0 + LETA0 * Inv_L + WETA0 * Inv_W + PETA0 * Inv_WL;
    ETA1_i     = ETA1 + LETA1 * Inv_L + WETA1 * Inv_W + PETA1 * Inv_WL;
    ETAB_i     = ETAB + LETAB * Inv_L + WETAB * Inv_W + PETAB * Inv_WL;
    DSUB_i     = DSUB + LDSUB * Inv_L + WDSUB * Inv_W + PDSUB * Inv_WL;
    DSC0_i     = DSC0 + LDSC0 * Inv_L + WDSC0* Inv_W + PDSC0 * Inv_WL;
    DSC1_i     = DSC1 + LDSC1 * Inv_L + WDSC1* Inv_W + PDSC1 * Inv_WL;
    ASCL_i     = ASCL + LASCL * Inv_L + WASCL * Inv_W + PASCL * Inv_WL;
    BSCL_i     = BSCL + LBSCL * Inv_L + WBSCL * Inv_W + PBSCL * Inv_WL;
    K1RSCE_i   = K1RSCE + LK1RSCE * Inv_L + WK1RSCE * Inv_W + PK1RSCE * Inv_WL;
    LPE0_i     = LPE0 + LLPE0 * Inv_L + WLPE0 * Inv_W + PLPE0 * Inv_WL;
    MEXP_i     = MEXP + LMEXP * Inv_L + WMEXP * Inv_W + PMEXP * Inv_WL;
    K0_i       = K0 + LK0 * Inv_L + WK0 * Inv_W + PK0 * Inv_WL;
    K01_i      = K01 + LK01 * Inv_L + WK01 * Inv_W + PK01 * Inv_WL;
    K0SI_i     = K0SI + LK0SI * Inv_L + WK0SI * Inv_W + PK0SI * Inv_WL;
    K0SI1_i    = K0SI1 + LK0SI1 * Inv_L + WK0SI1 * Inv_W + PK0SI1 * Inv_WL;
    PTWG_i     = PTWG + LPTWG * Inv_L + WPTWG * Inv_W + PPTWG * Inv_WL;
    PTWGB_i    = PTWGB + LPTWGB * Inv_L + WPTWGB * Inv_W + PPTWGB * Inv_WL;
    PTWGB2_i   = PTWGB2 + LPTWGB2 * Inv_L + WPTWGB2 * Inv_W + PPTWGB2 * Inv_WL;
    PTWGT_i    = PTWGT + LPTWGT * Inv_L + WPTWGT * Inv_W + PPTWGT * Inv_WL;
    U0_i       = U0 + LU0 * Inv_L + WU0 * Inv_W + PU0 * Inv_WL;
    UA_i       = UA + LUA * Inv_L + WUA * Inv_W + PUA * Inv_WL;
    UC_i       = UC + LUC * Inv_L + WUC * Inv_W + PUC * Inv_WL;
    UD_i       = UD + LUD * Inv_L + WUD * Inv_W + PUD * Inv_WL;
    UCS_i      = UCS + LUCS * Inv_L + WUCS * Inv_W + PUCS * Inv_WL;
    EU_i       = EU + LEU * Inv_L + WEU * Inv_W + PEU * Inv_WL;
    UTL_i      = UTL + LUTL * Inv_L + WUTL * Inv_W + PUTL * Inv_WL;
    UTE_i      = UTE + LUTE * Inv_L + WUTE * Inv_W + PUTE * Inv_WL;
    UA1_i      = UA1 + LUA1 * Inv_L + WUA1 * Inv_W + PUA1 * Inv_WL;
    UD1_i      = UD1 + LUD1 * Inv_L + WUD1 * Inv_W + PUD1 * Inv_WL;
    UCSTE_i    = UCSTE + LUCSTE * Inv_L + WUCSTE * Inv_W + PUCSTE * Inv_WL;
    ETAMOB_i   = ETAMOB + LETAMOB * Inv_L + WETAMOB * Inv_W + PETAMOB * Inv_WL;
    AT_i       = AT + LAT * Inv_L + WAT * Inv_W + PAT * Inv_WL;
    ATB_i      = ATB + LATB * Inv_L + WATB * Inv_W + PATB * Inv_WL;
    PRT_i      = PRT + LPRT * Inv_L + WPRT * Inv_W + PPRT * Inv_WL;
    IIT_i      = IIT + LIIT * Inv_L + WIIT * Inv_W + PIIT * Inv_WL;
    TGIDL_i    = TGIDL + LTGIDL * Inv_L + WTGIDL * Inv_W + PTGIDL * Inv_WL;
    TGISL_i    = TGISL + LTGISL * Inv_L + WTGISL * Inv_W + PTGISL * Inv_WL;
    IGT_i      = IGT + LIGT * Inv_L + WIGT * Inv_W + PIGT * Inv_WL;
    PCLM_i     = PCLM + LPCLM * Inv_L + WPCLM * Inv_W + PPCLM * Inv_WL;
    PCLMCV_i   = PCLMCV + LPCLMCV * Inv_L + WPCLMCV * Inv_W + PPCLMCV * Inv_WL;
    DROUT_i    = DROUT + LDROUT * Inv_L + WDROUT * Inv_W + PDROUT * Inv_WL;
    PDIBL1_i   = PDIBL1 + LPDIBL1 * Inv_L + WPDIBL1 * Inv_W + PPDIBL1 * Inv_WL;
    PDIBL2_i   = PDIBL2 + LPDIBL2 * Inv_L + WPDIBL2 * Inv_W + PPDIBL2 * Inv_WL;
    PVAG_i     = PVAG + LPVAG * Inv_L + WPVAG * Inv_W + PPVAG * Inv_WL;
    ALPHA0_i   = ALPHA0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_WL;
    ALPHA1_i   = ALPHA1 + LALPHA1 * Inv_L + WALPHA1 * Inv_W + PALPHA1 * Inv_WL;
    BETA0_i    = BETA0 + LBETA0 * Inv_L + WBETA0 * Inv_W + PBETA0 * Inv_WL;
    AIGBINV_i  = AIGBINV + Inv_L * LAIGBINV + Inv_W * WAIGBINV + Inv_WL * PAIGBINV;
    BIGBINV_i  = BIGBINV + Inv_L * LBIGBINV + Inv_W * WBIGBINV + Inv_WL * PBIGBINV;
    CIGBINV_i  = CIGBINV + Inv_L * LCIGBINV + Inv_W * WCIGBINV + Inv_WL * PCIGBINV;
    EIGBINV_i  = EIGBINV + Inv_L * LEIGBINV + Inv_W * WEIGBINV + Inv_WL * PEIGBINV;
    NIGBINV_i  = NIGBINV + Inv_L * LNIGBINV + Inv_W * WNIGBINV + Inv_WL * PNIGBINV;
    AIGBACC_i  = AIGBACC + Inv_L * LAIGBACC + Inv_W * WAIGBACC + Inv_WL * PAIGBACC;
    BIGBACC_i  = BIGBACC + Inv_L * LBIGBACC + Inv_W * WBIGBACC + Inv_WL * PBIGBACC;
    CIGBACC_i  = CIGBACC + Inv_L * LCIGBACC + Inv_W * WCIGBACC + Inv_WL * PCIGBACC;
    NIGBACC_i  = NIGBACC + Inv_L * LNIGBACC + Inv_W * WNIGBACC + Inv_WL * PNIGBACC;
    AIGC_i     = AIGC + LAIGC * Inv_L + WAIGC * Inv_W + PAIGC * Inv_WL;
    BIGC_i     = BIGC + LBIGC * Inv_L + WBIGC * Inv_W + PBIGC * Inv_WL;
    CIGC_i     = CIGC + LCIGC * Inv_L + WCIGC * Inv_W + PCIGC * Inv_WL;
    DIGC_i     = DIGC + LDIGC * Inv_L + WDIGC * Inv_W + PDIGC * Inv_WL;
    PIGCD_i    = PIGCD + LPIGCD * Inv_L + WPIGCD * Inv_W + PPIGCD * Inv_WL;
    PGIDL_i    = PGIDL + LPGIDL * Inv_L + WPGIDL * Inv_W + PPGIDL * Inv_WL;
    AGISL_i    = AGISL + LAGISL * Inv_L + WAGISL * Inv_W + PAGISL * Inv_WL;
    BGISL_i    = BGISL + LBGISL * Inv_L + WBGISL * Inv_W + PBGISL * Inv_WL;
    EGISL_i    = EGISL + LEGISL * Inv_L + WEGISL * Inv_W + PEGISL * Inv_WL;
    PGISL_i    = PGISL + LPGISL * Inv_L + WPGISL * Inv_W + PPGISL * Inv_WL;
    AGIDL_i    = AGIDL + LAGIDL * Inv_L + WAGIDL * Inv_W + PAGIDL * Inv_WL;
    BGIDL_i    = BGIDL + LBGIDL * Inv_L + WBGIDL * Inv_W + PBGIDL * Inv_WL;
    EGIDL_i    = EGIDL + LEGIDL * Inv_L + WEGIDL * Inv_W + PEGIDL * Inv_WL;
    VBGIDL_i   = VBGIDL + LVBGIDL * Inv_L + WVBGIDL * Inv_W + PVBGIDL * Inv_WL;
    VBEGIDL_i  = VBEGIDL + LVBEGIDL * Inv_L + WVBEGIDL * Inv_W + PVBEGIDL * Inv_WL;
    VBGISL_i   = VBGISL + LVBGISL * Inv_L + WVBGISL * Inv_W + PVBGISL * Inv_WL;
    VBEGISL_i  = VBEGISL + LVBEGISL * Inv_L + WVBEGISL * Inv_W + PVBEGISL * Inv_WL;
    AIGS_i     = AIGS + LAIGS * Inv_L + WAIGS * Inv_W + PAIGS * Inv_WL;
    BIGS_i     = BIGS + LBIGS * Inv_L + WBIGS * Inv_W + PBIGS * Inv_WL;
    CIGS_i     = CIGS + LCIGS * Inv_L + WCIGS * Inv_W + PCIGS * Inv_WL;
    DIGS_i     = DIGS + LDIGS * Inv_L + WDIGS * Inv_W + PDIGS * Inv_WL;
    DIGD_i     = DIGD + LDIGD * Inv_L + WDIGD * Inv_W + PDIGD * Inv_WL;
    AIGD_i     = AIGD + LAIGD * Inv_L + WAIGD * Inv_W + PAIGD * Inv_WL;
    BIGD_i     = BIGD + LBIGD * Inv_L + WBIGD * Inv_W + PBIGD * Inv_WL;
    CIGD_i     = CIGD + LCIGD * Inv_L + WCIGD * Inv_W + PCIGD * Inv_WL;
    NTOX_i     = NTOX + LNTOX * Inv_L + WNTOX * Inv_W + PNTOX * Inv_WL;
    POXEDGE_i  = POXEDGE + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_WL;
    LOVS_i     = LOVS + LLOVS * Inv_L + WLOVS * Inv_W + PLOVS * Inv_WL;
    LOVD_i     = LOVD + LLOVD * Inv_L + WLOVD * Inv_W + PLOVD * Inv_WL;
    CFS_i      = CFS + LCFS * Inv_L + WCFS * Inv_W + PCFS * Inv_WL;
    CFD_i      = CFD + LCFD * Inv_L + WCFD * Inv_W + PCFD * Inv_WL;
    VSAT_i     = VSAT + LVSAT * Inv_L + WVSAT * Inv_W + PVSAT * Inv_WL;
    VSATB_i    = VSATB + LVSATB * Inv_L + WVSATB * Inv_W + PVSATB * Inv_WL;
    VSAT1_i    = VSAT1 + LVSAT1 * Inv_L + WVSAT1 * Inv_W + PVSAT1 * Inv_WL;
    VSATCV_i   = VSATCV + LVSATCV * Inv_L + WVSATCV * Inv_W + PVSATCV * Inv_WL;
    KSATIV_i   = KSATIV + LKSATIV * Inv_L + WKSATIV * Inv_W + PKSATIV * Inv_WL;
    KSUBIV_i   = KSUBIV + LKSUBIV * Inv_L + WKSUBIV * Inv_W + PKSUBIV * Inv_WL;
    UP_i       = UP + LUP * Inv_L + WUP * Inv_W + PUP * Inv_WL;
    QMTCENCV_i = QMTCENCV + LQMTCENCV * Inv_L + WQMTCENCV * Inv_W + PQMTCENCV * Inv_WL;
    ETAQM_i    = ETAQM + LETAQM * Inv_L + WETAQM * Inv_W + PETAQM * Inv_WL; 
    QM0_i      = QM0 + LQM0 * Inv_L + WQM0 * Inv_W + PQM0 * Inv_WL; 
    PQM_i      = PQM + LPQM * Inv_L + WPQM * Inv_W + PPQM * Inv_WL;

    if (NQSMOD == 1 && XRCRG1 != 0.0) begin
        XRCRG1_i = XRCRG1 + LXRCRG1 * Inv_L + WXRCRG1 * Inv_W + PXRCRG1 * Inv_WL;
        XRCRG2_i = XRCRG2 + LXRCRG2 * Inv_L + WXRCRG2 * Inv_W + PXRCRG2 * Inv_WL;
    end else begin
        XRCRG1_i = 0.0;
        XRCRG2_i = 0.0;
    end


    cox1     = 3.9 * `EPS0 / EOT1;
    cox1P    = 3.9 * `EPS0 / EOT1P;
    cox2     = 3.9 * `EPS0 / EOT2;
    csi      = epssi / TSI;
    epsratio = EPSRSUB / 3.9;

    // Physical Oxide Thickness
    if (!$param_given(EOT1P)) begin
        IMGTOXP = (EOT1 * EPSROX1 / 3.9) - DTOX1;
    end else begin
        IMGTOXP = EOT1P;
    end

    // Geometrical scaling
    if (LPA > 0.0) begin
        U0_i = U0_i * (1.0 - UP_i * pow(Leff, -LPA));
    end else begin
        U0_i = U0_i * (1.0 - UP_i);
    end
    UA_i  = UA_i + AUA * lexp(-Leff / BUA);
    UC_i  = UC_i + AUC * lexp(-Leff / BUC);
    UDB_i = UDB + AUDB * lexp(-Leff / BUDB);
    UD_i  = UD_i + AUD * lexp(-Leff / BUD);
    EU_i  = EU_i + AEU * lexp(-Leff / BEU);


    if (RDSMOD == 1) begin
        RSW_i = RSW_i + ARSW * lexp(-Leff / BRSW);
        RDW_i = RDW_i + ARDW * lexp(-Leff / BRDW);
    end else begin
    RDSW_i = RDSW_i + ARDSW * lexp(-Leff / BRDSW);
    end


    PCLM_i   = PCLM_i + APCLM * lexp(-Leff / BPCLM);
    MEXP_i   = MEXP_i + AMEXP * pow(Leff * 1.0e6, -BMEXP);
    PTWG_i   = PTWG_i + APTWG * lexp(-Leff / BPTWG);
    PTWGB_i  = PTWGB_i + APTWGB * lexp(-Leff / BPTWGB);
    PTWGB2_i = PTWGB2_i + APTWGB2 * lexp(-Leff / BPTWGB2);
    VSAT_i   = VSAT_i + AVSAT * lexp(-Leff / BVSAT);
    VSATB_i  = VSATB_i + AVSATB * lexp(-Leff / BVSATB);
    VSAT1_i  = VSAT1_i + AVSAT1 * lexp(-Leff / BVSAT1);
    VSATCV_i = VSATCV_i + AVSATCV * lexp(-Leff / BVSATCV);

    // Scaling for DITS Parameters
    DVTP0_i = DVTP0 + ADVTP0 * lexp(-Leff / BDVTP0);
    DVTP1_i = DVTP1 + ADVTP1 * lexp(-Leff / BDVTP1);

    // ************************
    // *  Parameter Checking  *
    // ************************
    begin: ParameterCheck

        if (U0_i < 0.0) begin
            $strobe("Warning: U0_i = %e is negative, setting it to default value", U0_i);
            U0_i = 0.03;
        end

        if (UA_i < 0.0) begin
            $strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i);
            UA_i = 0.0;
        end

        if (EU_i < 0.0) begin
            $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i);
            EU_i = 0.0;
        end

        if (UD_i < 0.0) begin
            $strobe("Warning: UD_i = %e is negative, setting it to 0.", UD_i);
            UD_i = 0.0;
        end

        if (UCS_i < 0.0) begin
            $strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i);
            UCS_i = 0.0;
        end

        if (VSATB_i < 0.0) begin
            $strobe("Warning: VSATB_i = %e is negative, setting it to 0.", VSATB_i);
            VSATB_i = 0.0;
        end

        if (DVT1_i <= 0.0) begin
            $strobe("Fatal: DVT1_i = %e is not positive.", DVT1_i);
            $finish(0);
        end

        if (DSUB_i <= 0.0) begin
            $strobe("Fatal: DSUB_i = %e is not positive.", DSUB_i);
            $finish(0);
        end

        RDSWMIN_i = RDSWMIN;

        if (RDSWMIN_i < 0.0) begin
            $strobe("Warning: RDSWMIN = %e is negative. Set to zero", RDSWMIN_i);
            RDSWMIN_i = 0.0;
        end

        if (RDSW_i < 0.0) begin
            $strobe("Warning: RDSW_i = %e is negative. Set to zero", RDSW_i);
            RDSW_i = 0.0;
        end

        RSWMIN_i = RSWMIN;

        if (RSWMIN_i < 0.0) begin
            $strobe("Warning: RSWMIN = %e is negative. Set to zero", RSWMIN_i);
            RSWMIN_i = 0.0;
        end

        if (RSW_i < 0.0) begin
            $strobe("Warning: RSW_i = %e is negative. Set to zero", RSW_i);
            RSW_i = 0.0;
        end

        RDWMIN_i = RDWMIN;

        if (RDWMIN_i < 0.0) begin
            $strobe("Warning: RDWMIN = %e is negative. Set to zero", RDWMIN_i);
            RDWMIN_i = 0.0;
        end

        if (RDW_i < 0.0) begin
            $strobe("Warning: RDW_i = %e is negative. Set to zero", RDW_i);
            RDW_i = 0.0;
        end

        if (PRWG_i < 0.0) begin
            $strobe("Warning: PRWG_i = %e is negative. Set to zero", PRWG_i);
            PRWG_i = 0.0;
        end

        if (PDIBL1_i < 0.0) begin
            $strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i);
        end

        if (PDIBL2_i < 0.0) begin
            $strobe("Warning: PDIBL2_i = %e is negative.", PDIBL2_i);
        end

        if (DROUT_i <= 0.0) begin
            $strobe("Fatal: DROUT_i = %e is non-positive.", DROUT_i);
            $finish(0);
        end

        if (MEXP_i < 2.0) begin
            $strobe("Warning: MEXP_i = %e < 2.0.  Setting MEXP_i = 2.", MEXP_i);
            MEXP_i = 2.0;
        end
    end

    // Short Channel Effects
    Theta_RSCE = sqrt(1.0 + LPE0_i / Leff) - 1.0;
    teff       = TSI + epsratio * (EOT1 + EOT2);

    // Variable to be used in drain saturation voltage
    inv_MEXP = 1.0 / MEXP_i;

    // Source/drain to substrate parasitic capacitances
    csbox = cox2 * AS;
    cdbox = cox2 * AD;
    T0    = CSDBGSW * lln(1.0 + TSI / EOT2);
    csbox = csbox + T0 * max(PS - W, 0.0);
    cdbox = cdbox + T0 * max(PD - W, 0.0);

    // For better convergence
    csbox = max(csbox, 0.01e-18);
    cdbox = max(cdbox, 0.01e-18);

    // Mobility Degradation
    eta_mu    = 0.5 * ETAMOB_i;
    eta_mu_cv = 0.5;

    if (TYPE != `ntype) begin
        eta_mu    = 1.0 / 3.0 * ETAMOB_i;
        eta_mu_cv = 1.0 / 3.0;
    end

    EeffFactor   = 1.0e-8 / (epsratio * EOT1);
    WeffWRFactor = 1.0 / (pow(Weff * 1.0e6, WR_i) * NF);
    litl         = sqrt(epsratio * EOT1* TSI);

    if (LINTNOI >= Leff / 2.0) begin
        $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
        LINTNOI_i = 0.0;
    end else begin
        LINTNOI_i = LINTNOI;
    end

    // Self-heating Model
    if((SHMOD != 0) && (RTH0 > 0.0)) begin
        gth = (WTH0 + Weff * NF) / RTH0;
        cth = CTH0 * (WTH0 + Weff * NF);
    end else begin
        // set gth to some value to prevent a singular G matrix
        gth = 1.0;
        cth = 0.0;
    end

    // Geometry dependent Source/Drain Resistance
    RSourceGeo = RSHS * NRS;
    RDrainGeo  = RSHD * NRD;

    // Clamping of Source/Drain Resistances
    if (RSourceGeo <= 1.0e-3) begin
        RSourceGeo = 1.0e-3;
    end

    if (RDrainGeo <= 1.0e-3) begin
        RDrainGeo = 1.0e-3;
    end

    if (RDSMOD == 1) begin

        if (RSWMIN_i <= 0.0) begin
            RSWMIN_i = 0.0;
        end

        if (RDWMIN_i <= 0.0) begin
            RDWMIN_i = 0.0;
        end

        if (RSW_i <= 0.0) begin
            RSW_i = 0.0;
        end

        if (RDW_i <= 0.0) begin
            RDW_i = 0.0;
        end

    end else begin

        if (RDSWMIN_i <= 0.0) begin
            RDSWMIN_i = 0.0;
        end

        if (RDSW_i <= 0.0) begin
            RDSW_i = 0.0;
        end

    end

    // Tnom
    if (TNOM <= 0.0) begin
        $strobe("Warning: TNOM = %e is not positive. Set to 300.15 K.", TNOM);
        Tnom = `REFTEMP;
    end else begin
        Tnom = TNOM + `P_CELSIUS0;
    end

    // Gate current
    if (TYPE == `ntype) begin
        Aechvb = 4.97232e-7;
    end else begin
        Aechvb = 3.42537e-7;
    end

    if (TYPE == `ntype) begin
        Bechvb = 7.45669e11;
    end else begin
        Bechvb = 1.16645e12;
    end

    T0           = TOXP * TOXP;
    T1           = TOXP * POXEDGE_i;
    T2           = T1 * T1;
    Toxratio     = lexp(NTOX_i * lln(TOXREF / TOXP)) / T0;
    Toxratioedge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
    igsd_mult0   = Weff * Aechvb * Toxratioedge;

// Gate process resistance

    Grgeltd = RSHG * (XGW + Weff / 3.0 / NGCON) / (NGCON * NF * (Lnew - XGL));

    if (Grgeltd > 0.001) begin
        Grgeltd = 1.0 / Grgeltd;
    end else begin
        Grgeltd = 1.0e3;
        if (RGATEMOD != 0) begin
            $strobe("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
        end
    end


    // ****************************************
    // *  Temperature Dependent Calculations  *
    // ****************************************

    if (SHMOD != 0 && RTH0 > 0.0) begin
        DevTemp = $temperature + Temp(rth_branch) + DTEMP;
    end else begin
        DevTemp = $temperature + DTEMP;
    end

       TMAXK  = TMAXC + `P_CELSIUS0; // TMAX in Kelvin

    if (DevTemp > TMAXK) begin
        $strobe("Warning: DevTemp = %e is more than TMAXK. Set to TMAXK.", DevTemp);
    end

        DevTemp  = minx(DevTemp, TMAXK,  1.0e-2); //Limiting maximum temperature

    begin: IMGTempDepCalc

        TRatio  = DevTemp / Tnom;
        delTemp = DevTemp - Tnom;

        // Temperature Dependent Physical Quantities
        Vtm    = `KboQ * DevTemp;
        Eg     = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
        T1     = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
        ni     = NI0SUB * T1 * lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
        Nc     = NC0SUB * T1;
        vbi    = Vtm * lln(NSD_i * NBODY_i / (ni * ni));
        phib   = Vtm * lln(NBODY_i / ni);
        phisub = (0.5 * Eg - hypsmooth(0.5 * Eg - Vtm * lln(NBG / ni), 1.0e-4));

        // Front- and Back-Gate Workfunctions
        if (NBG != 0.0 && !$param_given(PHIG2)) begin
            if (WELLTYPE == `ptype) begin
                PHIG2_i = PHIG2_i - 0.5 * BG0SUB + phisub;
            end else begin
                PHIG2_i = PHIG2_i + 0.5 * BG0SUB - phisub;
            end
        end

        PhiRef    = (TYPE == `ntype) ? EASUB : EASUB + Eg;
        deltaphi1 = devsign * (PHIG1_i - PhiRef);
        deltaphi2 = devsign * (PHIG2_i - PhiRef);

        PhiSD    = EASUB + Eg / 2.0 - devsign * min(Eg / 2.0, Vtm * lln(NSD_i / ni));
        vfbsd    = devsign * (PHIG1_i - PhiSD);
        vfbsd_bg = devsign * (PHIG2_i - PhiSD);

        // Temperature Effects
        U0_t  = U0_i * pow(TRatio, UTE_i) * (1.0 + hypsmooth(0.9 + UTL_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        u0    = U0_t;
        UC_t  = UC_i * hypsmooth(1.0 + UC1 * delTemp - 1.0e-6, 1.0e-3);
        UA_t  = UA_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
        UD_t  = UD_i * pow(TRatio, UD1_i);
        UCS_t = UCS_i * pow(TRatio, UCSTE_i);

        rdstemp = hypsmooth(1.0 + PRT_i * delTemp - 1.0e-6, 1.0e-3);
        AT_i    = AT_i * (1.0 +  Inv_L * ATL);
        VSAT_t  = VSAT_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (VSAT_t < 1000) begin
            $strobe("Warning: VSAT(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT_t);
            VSAT_t = 1000;
        end

        VSAT1_t = VSAT1_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (VSAT1_t < 1000) begin
            $strobe("Warning: VSAT1(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1_t);
            VSAT1_t = 1000;
        end

        VSATCV_t = VSATCV_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (VSATCV_t < 1000) begin
            $strobe("Warning: VSATCV(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSATCV_t);
            VSATCV_t = 1000;
        end

        ETA0_t     = ETA0_i * (1.0 + hypmax(TETA0 * delTemp, -0.9, 1.0e-4));
        ATB_i      = ATB_i *(1.0 + Inv_L * ATBL);
        VSATB_t    = VSATB_i * (1.0 + hypsmooth(0.9 - ATB_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        MEXP_t     = hypsmooth(MEXP_i * (1.0 + TMEXP * delTemp) - 2.0, 1.0e-3) + 2.0;
        K0_t       = K0_i + K01_i * delTemp;
        K0SI_t     = K0SI_i + hypmax(K0SI1_i * delTemp, -K0SI_i, 1.0e-6);
        PTWG_t     = PTWG_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
        dvth_temp0 = (KT1 + KT1L / Leff) * (TRatio - 1.0);
        BETA0_t    = BETA0_i * pow(TRatio, IIT_i);
        BGIDL_t    = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
        BGISL_t    = BGISL_i * hypsmooth(1.0 + TGISL_i * delTemp - 1.0e-6, 1.0e-3);
        igtemp     = lexp(IGT_i * lln(TRatio));
        igsd_mult  = igsd_mult0 * igtemp;
    end

    // *********************************
    // *  Bias Dependent Calculations  *
    // *********************************

    // Load Terminal Voltages
    vgs_noswap  = devsign * V(gi, si);
    vds_noswap  = devsign * V(di, si);
    vgd_noswap  = devsign * V(gi, di);
    vbgs_noswap = devsign * V(bg, si);
    vbgd_noswap = devsign * V(bg, di);
    vgbg        = devsign * V(gi, bg);

    // Source-drain Interchange
    sigvds = 1.0;

    if (vds_noswap < 0.0) begin
        sigvds = -1.0;
        vfgs   = vgd_noswap;
        vds    = -vds_noswap;
        vbgs   = vbgd_noswap;
        vbgd   = vbgs_noswap;
    end else begin
        vfgs   = vgs_noswap;
        vds    = vds_noswap;
        vbgs   = vbgs_noswap;
        vbgd   = vbgd_noswap;
    end


    vgd_ov_noswap = devsign * V(ge, di);
    vgs_ov_noswap = devsign * V(ge, si);


    // Terminal Voltage Conditioning
    vdsx  = sqrt(vds * vds + 0.0004) - 0.02;
    symmetry_factor = 0.5 * (vdsx - vds);
    vbgx  = vbgs + symmetry_factor;
    vgfb1 = vfgs - deltaphi1;
    vgfb2 = vbgs - deltaphi2;

    // Back-gate bias dependence
    sclf = sqrt(epsratio * TSI * EOT1);
    sclm = sqrt(TSI * (epsratio * EOT1 + 0.375 * TSI));
    T0   = (vgfb1 * (EOT2 * epsratio) + vgfb2 * (EOT1 * epsratio + TSI)) / teff + symmetry_factor;
    T1   = atan(ASCL_i + BSCL_i * T0) / `M_PI + 0.5;
    scl  = sclm + T1 * (sclf - sclm);

    tmp = DVT1_i * Leff / scl + 1.0e-6;

    if (tmp < 40.0) begin
        Theta_SCE = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_SCE = lexp(-tmp);
    end

    tmp = DSUB_i * Leff / scl + 1.0e-6;

    if (tmp < 40.0) begin
        Theta_DIBL = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_DIBL = lexp(-tmp);
    end

    if (tmp < 40.0) begin
        Theta_DITS = 1.0 / max((1.0 + DVTP2 * (cosh(tmp) - 2.0)), 1.0e-6);
    end else begin
        Theta_DITS = lexp(-tmp) / max((lexp(-tmp) + DVTP2), 1.0e-6);
    end

    tmp = DROUT_i * Leff / scl + 1.0e-6;

    if (tmp < 40.0) begin
        DIBLfactor = 0.5 * PDIBL1_i / (cosh(tmp) - 1.0) +PDIBL2_i;
    end else begin
        DIBLfactor = PDIBL1_i * lexp(-tmp) + PDIBL2_i;
    end

    // Back gate biasing effect
    if (WELLTYPE == `ptype) begin
        temp = DBGPW_i * Leff / scl;

        if (temp > 40.0) begin
            T0 = lexp(temp) / 2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end

        T1       = KBG0PW_i - 0.5 * KBG1PW_i / T0;
        T2       = KBG2PW_i;
        vknee1   = VKNEE1PW_i;
        vknee2   = VKNEE2PW_i;
        bpfactor = BPFACTORPW_i;
    end else begin
        temp = DBGNW_i * Leff / scl;

        if (temp > 40.0) begin
            T0 = lexp(temp) / 2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end

        T1       = KBG0NW_i - 0.5 * KBG1NW_i / T0;
        T2       = KBG2NW_i;
        vknee1   = VKNEE1NW_i;
        vknee2   = VKNEE2NW_i;
        bpfactor = BPFACTORNW_i;
    end

    T0   = T1 - T2;
    kvbg = T2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.0001));

    // Back-gate (substrate) depletion effect
    vsubdep0 = `q * NBG * epssi / (2.0 * cox2 * cox2);

    if (NBG != 0.0) begin
        T0 = sqrt(1.0 + hypsmooth(welsign * (devsign * vbgx - vknee1), 1.0e-2) / vsubdep0) - 1.0;
    end else begin
        T0 = 0.0;
    end

    vsubdep  = vsubdep0 * T0 * T0;
    vsubdep  = -hypmax(-vsubdep, -vknee2, 1.0e-2);
    vgfb2eff = `VGFB2N - symmetry_factor;
    gamma0   = -cox2 * csi / ((cox2 + csi) * cox1);
    dvth_vbg = gamma0 * kvbg * (vgfb2 - (devsign * welsign * bpfactor * vsubdep) - vgfb2eff);

    // SCE, DIBL, RSCE, and SS degradation effects Ref: BSIM4 Model
    vbgxpos     = hypsmooth(vbgx, 1.0e-3);
    phist       = 0.4 + phib + PHIN_i;
    if (phist <0) begin
        dvth_rsce = 0;
    end else begin
        dvth_rsce   = K1RSCE_i * Theta_RSCE * sqrt(phist);
    end
    dvth_vtroll = -DVT0_i * Theta_SCE * (vbi - phist);
    dvth_dibl   = -(ETA0_t + ETAB_i * vbgx) * Theta_DIBL * (vdsx + ETA1_i * sqrt(vdsx + 0.01)) + (DVTP0_i * Theta_DITS * pow((vdsx + 0.01), DVTP1_i));
    dvth_dsc    = -DSC0_i / (Leff + DSC1_i) * vdsx;
    T1          = csi * cox2 / (csi + cox2);
    T2          = (CDSCD_i + CBGCBGD * vbgxpos) * vdsx;
    T3          = CBGCBG0 * vbgx + CBGCBG0P * vbgx * vbgx + Theta_SCE * (CDSC_i + CBGCBG_i * vbgx + CBGCBGP * vbgx * vbgx + T2);
    nVtm        = Vtm * (cox1 + T1 + CIT_i + T3) / (cox1 + T1);

    // Threshold voltage shift because of body doping; Consistent with Noguchi et al., EDL 2001
    dvth_nbody  = `q * NBODY_i * TSI / cox1 * (1.0 - 0.5 * TSI / (TSI + epsratio * EOT2));
    T0          = (KT2 + KT2L / Leff) * vbgx;
    dvth_temp   = dvth_temp0 + T0 * (TRatio - 1.0);
    dvth_all    = dvth_vtroll + dvth_dibl + dvth_rsce + dvth_dsc + dvth_nbody + dvth_temp + dvth_vbg;
    vgfb1eff    = vgfb1 - dvth_all + DELVTRAND;

    // Threshold voltage operating point
    A0     = (2.0 * `q * ni * TSI * TSI) / (epssi * Vtm);
    k1     = cox1 / csi;
    qth    = 1.0;
    qsq1   = k1 * k1 * qth * qth - A0 * lexp(phib * 2.0);
    qsqrt1 = sqrt(qsq1);
    qcoth1 = (1.0 - qsqrt1 / 8.0) / (0.5 - qsqrt1 / 24.0);
    T1     = (1.0 + lln(k1 * k1 * qth * qth + k1 * qth * qcoth1) - lln(A0)) * Vtm;
    Vfb    = PHIG1_i - (EASUB + Eg / 2.0);
    Vthop  = Vfb + devsign * (T1 + dvth_all + DELVTRAND);

    // *******************************************
    // *  Common Surface Potential Calculations  *
    // *******************************************

    `bsimimg_sp_common(vgfb2eff, nVtm, Nc, epssi, epsratio, EOT1, EOT2, TSI, spA)

    // *********************************************************
    // *  Source End Surface Potential and Charge Calculation  *
    // *********************************************************

    `bsimimg_sp(sp_source, vgfb1eff, vgfb2eff, 0.0, EOT1, EOT2, TSI, nVtm, spA, spc, spb, kappa, invnVtm, gsp, b2sp, epsratio, ebs, phifs, phibs, qtots, CHARGEMOD)

    // ******************************
    // *  Drain Saturation Voltage  *
    // ******************************

    qis   = qtots / cox1;
    qbs   = `q * NBODY_i * TSI / cox1;
    T2    = eta_mu * qis + qbs + ebs * epssi / cox1;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffs = EeffFactor * T3;

    begin: source_mobility_calc
        real T2, T3;
        qb0   = 1.0e-2 / cox1;
        T2    = pow(0.5 * (1.0 + abs(qis / qb0)), UCS_t);
        T3    = (UA_t + vbgs * UC_t) * pow(abs(Eeffs), EU_i) + UD_t / T2;
        Dmobs = 1.0 + T3;
        Dmobs = smoothminx(Dmobs, 1.0, DMOBCLAMP);
        Dmobs = Dmobs / U0MULT;
    end

    if (RDSMOD == 1) begin
        Rdss = 0.0;
    end else if (RDSMOD == 0) begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF * rdstemp;
    end else begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RSourceGeo + RDrainGeo + RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF * rdstemp;
    end

    Esat  = 2.0 * VSAT_t / u0 * Dmobs;
    EsatL = Esat * Leff;
    T6    = KSATIV_i * (qis + 2.0 * Vtm * KSUBIV_i);

    if (Rdss == 0.0) begin
        Vdsat = EsatL * T6 / (EsatL + T6);
    end else begin
        WVCox = Weff * VSAT_t * cox1;
        T0    = WVCox * Rdss;
        Ta    = 2.0 * T0;
        Tb    = T6 + EsatL + 3.0 * T6 * T0;
        Tc    = T6 * (EsatL + 2.0 * T6 * T0);
        Vdsat = (Tb - sqrt(Tb * Tb - 2.0 * Ta * Tc)) / Ta;
    end

    Vdsat  = hypsmooth(Vdsat - 1.0e-3, 1.0e-5) + 1.0e-3;
    T7     = pow(vds / Vdsat, MEXP_t);
    T8     = pow(1.0 + T7, inv_MEXP);
    Vdseff = vds / T8;

    if (Vdseff > vds) begin
        Vdseff = vds;
    end

    // ********************************************************
    // *  Drain End Surface Potential and Charge Calculation  *
    // ********************************************************

    `bsimimg_sp(sp_drain, vgfb1eff, vgfb2eff, Vdseff, EOT1, EOT2, TSI, nVtm, spA, spc, spb, kappa, invnVtm, gsp, b2sp, epsratio, ebd, phifd, phibd, qtotd, CHARGEMOD)

    // **********************************
    // *  Average Potential and Charge  *
    // **********************************

    qid = qtotd / cox1;
    qia = 0.5 * (qis + qid);
    dqi = qis - qid;
    qba = `q * NBODY_i * TSI / cox1;
    eba = 0.5 * (ebs + ebd);

    T0 = pow(Vdseff, 2.0) / 6.25e-4;

    if (CHARGEWF != 0.0) begin
        qia2 = 0.5 * (qis + qid) + CHARGEWF * (1.0 - lexp(-T0)) * 0.5 * dqi;
    end else begin
        qia2 = 0.5 * (qis + qid);
    end

    // Multiplication factor for I-V
    beta = u0 * cox1 * Weff / Leff;

    // **************************
    // *  Mobility Degradation  *
    // **************************

    // Eeff is clamped to 0 to avoid numerical problems
    // Average electric field in the inversion layer (in the unit of MV/cm)
    T2    = eta_mu * qia2 + qba + eba * epssi / cox1;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffm = EeffFactor * T3;

    begin: average_mobility_calc
        real T2, T3;
        T2   = pow(0.5 * (1.0 + abs(qia / qb0)), UCS_t);
        T3   = (UA_t + vbgx * UC_t) * pow(abs(Eeffm), EU_i) + (UD_t + vbgx * UDB_i) / T2;
        Dmob = 1.0 + T3;
        Dmob = smoothminx(Dmob, 1.0, DMOBCLAMP);
        Dmob = Dmob / U0MULT;
        ueff = u0 / Dmob;
    end

    // Mobility Degradation for C-V
    Eeffm_cv = EeffFactor * (qba + eta_mu_cv * qia);
    T3       = UA_t * pow(abs(Eeffm_cv), EU_i);
    Dmob_cv  = 1.0 + T3;
    Dmob_cv  = smoothminx(Dmob_cv, 1.0, DMOBCLAMP);
    Dmob_cv  = Dmob_cv / U0MULT;

    // Velocity Saturation
    Esat1  = 2.0 * VSAT1_t / ueff;
    Esat1L = Esat1 * Leff;

    T0     = 0.8 + VSATB_t * vbgx;
    Xsat   = 0.2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.01));
    T0     = dqi / Esat1L * Xsat;
    Dvsat  = (1.0 + sqrt(DELTAVSAT + T0 * T0)) / (1.0 + sqrt(DELTAVSAT));
    Dvsat  = Dvsat + 0.5 * (PTWG_t - PTWGB_i * vbgxpos - PTWGB2_i * vbgx) * qia * dqi * dqi;
    Dvsat  = smoothminx(Dvsat, 1.0, DVSATCLAMP);

    EsatCV  = 2.0 * VSATCV_t * Dmob_cv / u0;
    EsatCVL = EsatCV * LeffCV;

    // Output Conductance
    if (PVAG_i > 0.0) begin
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
    end else begin
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end

    diffVds  = vds - Vdseff;
    Vgst2Vtm = qia + 2.0 * Vtm;

    if (DIBLfactor > 0.0) begin
        T1     = Vgst2Vtm;
        T3     = T1 / (Vdsat + T1);
        VaDIBL = T1 / DIBLfactor * T3 * PVAGfactor;
        Moc    = 1.0 + diffVds / VaDIBL;
    end else begin
        Moc = 1.0;
    end

    if (PCLM_i > 0.0) begin

        if (PCLMG < 0.0) begin
            T1 = 1.0 / (1.0 / PCLM_i - PCLMG * qia);
        end else begin
            T1 = PCLM_i * (1.0 + PCLMG * qia);
        end

        Mclm = 1.0 + T1 * lln(1.0 + (vds - Vdseff) / T1 / (Vdsat + EsatL));

    end else begin
        Mclm = 1.0;
    end

    Moc = Moc * Mclm;

    // Channel Length Modulation factor for C-V
    if (PCLMCV_i > 0.0) begin
        MclmCV = 1.0 + PCLMCV_i * lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL));
    end else begin
        MclmCV = 1.0;
    end

    // Lateral Non-uniform doping effect (IV-CV Vth shift) factor
    if (K0_t != 0.0) begin
        T1   = K0_t / (K0SI_t * qia + 2.0 * nVtm);
        Mnud = lexp(-T1);
    end else begin
        Mnud = 1.0;
    end

    // I-V Equation
    ids0        = 0.5 * (qis + qid) * (phifd - phifs) + (qis - qid) * Vtm;
    ids0_ov_dqi = 0.5 * (qis + qid) + Vtm;

    // S/D series resistance
    begin: rdsblock
        real T1, T4;
        real vgs_eff, vgd_eff;
        real T2, T3;
        // RDSMOD = 1: Both bias-dependent and independent of S/D resistances are external
        if (RDSMOD == 1) begin
            Rdsi    = 0.0;
            Dr      = 1.0;
            T2      = vgs_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgs_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgs_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgs_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rsource = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T0) * WeffWRFactor);
            T2      = vgd_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgd_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgd_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgd_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdrain  = rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T0) * WeffWRFactor);
        end else begin
        // RDSMOD = 0: Bias-dependent S/D resistances are internal and bias-independent S/D resistances are external
            T4      = 1.0 + PRWG_i * qia;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * (vbgd + vbgs) * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi    = rdstemp * (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor;
            Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dmob * Dvsat) * Rdsi;
            Rdrain  = RDrainGeo;
            Rsource = RSourceGeo;
        // RDSMOD = 2: Both bias-dependent and independent of S/D resistances are internal
        if (RDSMOD == 2) begin
            T4      = 1.0 + PRWG_i * qia;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * (vbgd + vbgs) * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi    = rdstemp * (RSourceGeo + RDrainGeo + RDSWMIN_i + RDSW_i * T0) * WeffWRFactor;
            Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dmob * Dvsat) * Rdsi;
            Rdrain  = 0.0;
            Rsource = 0.0;
        end
    end

    end

    ids = beta * ids0 * Moc * Mnud / (Dmob * Dvsat * Dr);
    ids = NF * ids;

    // C-V Equation
    T0  = cox2 / cox1 * csi / (cox2 + csi);
    T1  = (1.0 + T0) / 2.0;
    T2  = vgfb1eff + T0 * vgfb2eff + Vtm * (1.0 + T0);
    T3  = phifs + phifd;
    T4  = phifd - phifs;
    T5  = vgfb1eff - T3 / 2.0;
    T6  = T1 * T4 / (6.0 * (T2 - T1 * T3));
    qfg = T5 + T6 * T4 + dvth_vbg;
    qd1 = T5 / 2.0 + T6 * T4 / 10.0 - (T6 / T1) / 10.0 * (5.0 * T2 - 4.0 * T1 * phifd - 6.0 * T1 * phifs) * (T2 - 2.0 * T1 * phifd) / (T2 - T1 * T3);

    T0 = cox1 / cox2 * csi / (cox1 + csi);
    T1 = (1.0 + T0) / 2.0;
    T2 = vgfb2eff + T0 * vgfb1eff + Vtm * (1.0 + T0);
    T3 = phibs + phibd;
    T4 = phibd - phibs;
    T5 = vgfb2eff - T3 / 2.0;
    T6 = T1 * T4 / (6.0 * (T2 - T1 * T3));

    // Note: q's are normalized to cox1, not cox2.
    qbg = cox2 / cox1 * (T5 + T6 * T4 - dvth_vbg * (cox1 / cox2));
    qd2 = cox2 / cox1 * (T5 / 2.0 + T6 * T4 / 10.0 - (T6 / T1) / 10.0 * (5.0 * T2 - 4.0 * T1 * phibd - 6.0 * T1 * phibs) * (T2 - 2.0 * T1 * phibd) / (T2 - T1 * T3));
    qd  = qd1 + qd2;

    // Quantum Mechanical Effects
    if (QMTCENCV_i > 0.0) begin
        T4     = (qia + ETAQM_i * qba) / QM0_i;
        T5     = 1.0 + pow(T4, PQM_i);
        Tcen0  = TSI;
        Tcen   = Tcen0 / T5;
        coxeff = 3.9 * `EPS0 / (IMGTOXP * 3.9 / EPSROX1 + Tcen * QMTCENCV_i / epsratio);
    end else begin
        coxeff = cox1P;
    end

    T0  = coxeff * WeffCV * LeffCV / MclmCV;
    qfg = qfg * T0;
    qbg = qbg * T0;
    qd  = -qd * T0;
    qs  = -qfg - qbg - qd;

    // Parasitic Capacitances
    // Note: the back gate capacitance is assumed to be negligible due to the thick oxide.
    qfgs_ov = WeffCV * LOVS_i * cox1 * V(ge, si);
    qfgd_ov = WeffCV * LOVD_i * cox1 * V(ge, di);

    // Bias-dependent overlap capacitances
    T0      = vgs_ov_noswap - vfbsd + `DELTA_1 + (vbgs_noswap - vfbsd_bg - PCOVBS0) * PCOVBS1;
    vfgs_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    qfgs_ov = qfgs_ov + devsign * WeffCV * CGSL * (vgs_ov_noswap - vfbsd - vfgs_ov - 0.5 * CKAPPAS * (sqrt(1.0 - 4.0 * vfgs_ov / CKAPPAS)- 1.0));
    T0      = vgd_ov_noswap - vfbsd + `DELTA_1 + (vbgd_noswap - vfbsd_bg - PCOVBD0) * PCOVBD1;
    vfgd_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    qfgd_ov = qfgd_ov + devsign * WeffCV * CGDL * (vgd_ov_noswap - vfbsd - vfgd_ov - 0.5 * CKAPPAD * (sqrt(1.0 - 4.0 * vfgd_ov / CKAPPAD)- 1.0));

    // Outer fringe capacitances
    qfgs_of = WeffCV * CFS_i * V(ge, si);
    qfgd_of = WeffCV * CFD_i * V(ge, di);

    qfgs_parasitic = qfgs_ov + qfgs_of;
    qfgd_parasitic = qfgd_ov + qfgd_of;

    Qsbg = devsign * csbox * V(si, bg);
    Qdbg = devsign * cdbox * V(di, bg);

    // Impact Ionization Current
    T0 = (ALPHA0_i + ALPHA1_i * Leff) / Leff;

    if (T0 <= 0.0 || BETA0_t <= 0.0) begin
        Iii = 0.0;
    end else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
        T1  = -BETA0_t / diffVds;
        Iii = T0 * diffVds * ids * lexp(T1);
    end else begin
        Iii = T0 * diffVds * ids * `MIN_EXPL;
    end

    // Gate Current
    igbinv = 0.0;
    igbacc = 0.0;
    igcs   = 0.0;
    igcd   = 0.0;
    igs    = 0.0;
    igd    = 0.0;

    // Igb
    if (IGBMOD != 0) begin
        // Igbinv
        T1          = (qia - EIGBINV_i) / NIGBINV_i / Vtm;
        Vaux_Igbinv = NIGBINV_i * Vtm * lln(1.0 + lexp(T1));
        T2          = AIGBINV_i - BIGBINV_i * qia;
        T3          = 1.0 + CIGBINV_i * qia;
        T4          = -9.82222e11 * TOXP * T2 * T3;
        T5          = lexp(T4);
        T6          = 3.75956e-7;
        igbinv      = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbinv * T5;
        igbinv      = igbinv * igtemp;

        // Igbacc
        vfbzb       = deltaphi1 - Eg / 2.0 - phib;
        T0          = vfbzb - vgbg;
        T1          = T0 / NIGBACC_i / Vtm;
        Vaux_Igbacc = NIGBACC_i * Vtm * lln(1.0 + lexp(T1));

        if (vfbzb <= 0.0) begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) - 0.08 * vfbzb));
        end else begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) + 0.08 * vfbzb));
        end

        T2     = AIGBACC_i - BIGBACC_i * Voxacc;
        T3     = 1.0 + CIGBACC_i * Voxacc;
        T4     = -7.45669e11 * TOXP * T2 * T3;
        T5     = lexp(T4);
        T6     = 4.97232e-7;
        igbacc = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbacc * T5;
        igbacc = igbacc * igtemp;
    end

    // Gate to Body Tunneling current empirical partition
    T0   = tanh(0.6 * vds_noswap / Vtm);
    wf   = 0.5 + 0.5 * T0;
    wr   = 1.0 - wf;
    igbs = (igbinv + igbacc) * wf;
    igbd = (igbinv + igbacc) * wr;

    if (IGCMOD != 0) begin
        // Igcinv
        T1   = AIGC_i - BIGC_i * (vgfb1 - DIGC_i * phifs);
        T2   = 1.0 + CIGC_i * (vgfb1 - DIGC_i * phifs);
        T3   = -Bechvb * TOXP * T1 * T2;
        T4   = qia * lexp(T3);
        T5   = vgbg + 0.5 * vdsx + 0.5 * (vbgs_noswap + vbgd_noswap);
        igc0 = Weff * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;

        // Gate-current partitioning
        Vdseffx = sqrt(Vdseff * Vdseff + 0.01) - 0.1;
        T1      = PIGCD_i * Vdseffx;
        T1_exp  = lexp(-T1);
        T3      = T1 + T1_exp - 1.0 + 1.0e-4;
        T4      = 1.0 - (T1 + 1.0) * T1_exp + 1.0e-4;
        T5      = T1 * T1 + 2.0e-4;
        igcd    = igc0 * T4 / T5;
        igcs    = igc0 * T3 / T5;

        // Igs
        T0       = vgs_noswap - vfbsd + DIGS_i * gamma0 * (vbgs - vfbsd_bg);
        vfgs_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGS_i - BIGS_i * vfgs_eff;
        T2       = 1.0 + CIGS_i * vfgs_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
            igs = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end else begin
            igd = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end

        // Igd
        T0       = vgd_noswap - vfbsd + DIGD_i * gamma0 * (vbgs - vfbsd_bg);
        vfgd_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGD_i - BIGD_i * vfgd_eff;
        T2       = 1.0 + CIGD_i * vfgd_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
            igd = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end else begin
            igs = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end
    end

    // GIDL/GISL Currents
    igisl = 0.0;
    igidl = 0.0;

    if (GIDLMOD != 0) begin

        T0 = epsratio * EOT1;

        // GIDL
        if (AGIDL_i <= 0.0 || BGIDL_t <= 0.0) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgd_noswap - EGIDL_i + vfbsd + VBGIDL_i * gamma0 * (vbgs - vfbsd_bg - VBEGIDL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGIDL_t / (T1 + 1.0e-3);
            T3 = lexp(PGIDL_i * lln(T1));
            T6 = vds_noswap * AGIDL_i * Weff * T3 * lexp(-T2);
        end

        if (sigvds > 0.0) begin
            igidl = T6;
        end else begin
            igisl = T6;
        end

        // GISL
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgs_noswap - EGISL_i + vfbsd + VBGISL_i * gamma0 * (vbgs - vfbsd_bg - VBEGISL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGISL_t / (T1 + 1.0e-3);
            T3 = lexp(PGISL_i * lln(T1));
            T6 = -vds_noswap * AGISL_i * Weff * T3 * lexp(-T2);
        end

        if (sigvds > 0.0) begin
            igisl = T6;
        end else begin
            igidl = T6;
        end
    end

    // Thermal noise and flicker noise
    Esatnoi = 2.0 * VSAT_t / ueff;

    // Flicker Noise, Ref: BSIM4 by K. K. Hung et al. TED 1990
    if (NOIA > 0.0 || NOIB > 0.0 || NOIC > 0.0) begin

        Leffnoi   = Leff - 2.0 * LINTNOI_i;
        Leffnoisq = Leffnoi * Leffnoi;

        if (EM <= 0.0) begin
            DelClm = 0.0;
        end else begin
            T0     = (diffVds / litl + EM) / Esatnoi;
            DelClm = litl * lln(T0);

            if (DelClm < 0.0) begin
                DelClm = 0.0;
            end
        end

        T1 = `q * `q * `q * Vtm * abs(ids) * ueff;
        T2 = 1.0e10 * coxeff * Leffnoisq;
        N0 = coxeff * qis / `q;
        Nl = coxeff * qid / `q;

        Nstar = Vtm / `q * (coxeff + CIT_i);
        T3    = NOIA * lln((N0 + Nstar) / (Nl + Nstar));
        T4    = NOIB * (N0 - Nl);
        T5    = 0.5 * NOIC * (N0 * N0 - Nl * Nl);
        T6    = `q * Vtm * ids * ids;

        T7  = 1.0e10 * Leffnoisq * Weff * NF;
        T8  = NOIA + NOIB * Nl + NOIC * Nl * Nl;
        T9  = (Nl + Nstar) * (Nl + Nstar);
        Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

        T10 = NOIA * `q * Vtm;
        T11 = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
        Swi = T10 / T11 * ids * ids;

        T1  = Swi + Ssi;

        if (T1 > 0.0) begin
            FNPowerAt1Hz = (Ssi * Swi) / T1;
        end else begin
            FNPowerAt1Hz = 0.0;
        end

    end else begin
        FNPowerAt1Hz = 0.0;
    end

    // Intrinsic Charges
    qfgi = devsign * NF * qfg;
    qbgi = NF * qbg;

    if (sigvds > 0.0) begin
        qsi = NF * qs;
        qdi = NF * qd;
        qs  = NF * (qs - qfgs_parasitic) + Qsbg;
        qd  = NF * (qd - qfgd_parasitic) + Qdbg;
    end else begin
        qsi = NF * qd;
        qdi = NF * qs;
        T0  = NF * (qd - qfgs_parasitic) + Qsbg;
        qd  = NF * (qs - qfgd_parasitic) + Qdbg;
        qs  = T0;
    end

    qfg = qfgi + NF * (qfgs_parasitic + qfgd_parasitic);
    qbg = NF * qbg - Qsbg - Qdbg;

    qfgs_parasitic = NF * qfgs_parasitic;
    qfgd_parasitic = NF * qfgd_parasitic;

    // Thermal noise
    // Charge-based model (BSIM4: TNOIMOD = 0)
    qinv  = -(qsi + qdi);
    T0    = ueff * qinv;
    T1    = T0 * Rdsi + Leff * Leff;
    Gtnoi = (T0 / T1) * NTNOI;
    Nt    = 4.0 * Vtm * `q;
    sid   = Nt * Gtnoi;

    // NQS gate resistance Ref: BSIM4

    if (NQSMOD == 1 && XRCRG1_i != 0.0) begin
        T0       = ueff * cox1 * Weff / Leff;
        IdsovVds = beta * qia * Moc / (Dmob * Dvsat * Dr);
        gcrg     = NF * XRCRG1_i * (IdsovVds + XRCRG2_i * Vtm * T0);
    end else begin
        gcrg     = 0;
    end


    // Loading variables
    igidl = NF * igidl;
    igisl = NF * igisl;
    igcd  = NF * igcd;
    igcs  = NF * igcs;
    igs   = NF * igs;
    igd   = NF * igd;

    if (sigvds > 0.0) begin
        I(di, si) <+ devsign * ids + ($simparam("gmin",1e-12) * V(di, si));
        I(di, si) <+ devsign * (igidl + Iii);
        I(si, di) <+ devsign * igisl;
        I(gi, si) <+ devsign * (igcs + igs);
        I(gi, di) <+ devsign * (igcd + igd);
    end else begin
        I(si, di) <+ devsign * ids + ($simparam("gmin",1e-12) * V(si, di));
        I(si, di) <+ devsign * (igidl + Iii);
        I(di, si) <+ devsign * igisl;
        I(gi, di) <+ devsign * (igcs + igs);
        I(gi, si) <+ devsign * (igcd + igd);
    end

    I(gi, si)  <+ devsign * igbs;
    I(gi, di)  <+ devsign * igbd;
    I(di, si)  <+ devsign * ddt(qdi);
    I(gi, si)  <+ ddt(qfgi);
    I(bg, si)  <+ devsign * ddt(qbgi);
    I(ge, si)  <+ ddt(qfgs_parasitic);
    I(ge, di)  <+ ddt(qfgd_parasitic);

    I(si, bg)  <+ ddt(Qsbg) * devsign;
    I(di, bg)  <+ ddt(Qdbg) * devsign;


    if (RDSMOD == 2) begin
        V(d, di) <+ 0.0;
        V(s, si) <+ 0.0;
    end else begin
        gdpr = 1.0 / Rdrain;
        gspr = 1.0 / Rsource;
        I(d, di) <+ white_noise(Nt * gdpr, "Rd");
        I(s, si) <+ white_noise(Nt * gspr, "Rs");
    end


// NQSMOD1 Gate Resistance Model

    if (NQSMOD == 1 && XRCRG1_i != 0.0)
        I(ge, gi) <+ V(ge, gi) * gcrg;
    else
        V(ge, gi) <+ 0.0;


    if (RGATEMOD == 0) begin
        V(fg, ge) <+ 0.0;
    end else begin: Rgate
        real Ggate, Gnoise;
        Ggate  = Grgeltd;
        Gnoise = Grgeltd;
        I(fg, ge) <+ V(fg, ge) * Ggate;
        I(fg, ge) <+ white_noise(Nt * Gnoise, "Rg");
    end


    // Flicker Noise
    I(di,si) <+ flicker_noise(FNPowerAt1Hz, EF, "flicker");

    // Channel thermal noise and induced gate noise stamping
    // Implementation of correlated noise follows C. C. McAndrew, WCM 2005
    I(di, si) <+ white_noise(sid, "Id");

    // Gate current shot noise
    if (IGCMOD != 0) begin
        if (sigvds > 0.0) begin
            I(gi, si) <+ white_noise(2.0 * `q * abs(igcs + igs), "Igs");
            I(gi, di) <+ white_noise(2.0 * `q * abs(igcd + igd), "Igd");
        end else begin
            I(gi, di) <+ white_noise(2.0 * `q * abs(igcs + igs), "Igd");
            I(gi, si) <+ white_noise(2.0 * `q * abs(igcd + igd), "Igs");
        end
    end

    if (IGBMOD != 0) begin
        I(gi, si) <+ white_noise(2.0 * `q * abs(igbs), "Igb");
        I(gi, di) <+ white_noise(2.0 * `q * abs(igbd), "Igb");
    end

   // Stamping external S/D Resistance
    if (RDSMOD == 2) begin
      V(d, di) <+ 0.0;
      V(s, si) <+ 0.0;
   end else begin
      I(d, di) <+ V(d, di) / Rdrain;
      I(s, si) <+ V(s, si) / Rsource;
   end


    // Self-heating
    if (SHMOD != 0 && RTH0 > 0.0) begin
        if (RDSMOD != 2) begin
            Pwr(ith_branch) <+ -(devsign * sigvds * V(di, si) * ids + V(d, di) * V(d, di) / Rdrain + V(s, si) * V(s, si) / Rsource);
        end else begin
            Pwr(ith_branch) <+ -(devsign * sigvds * V(di, si) * ids);
        end
        Pwr(rth_branch) <+ Temp(rth_branch) * gth;
        Pwr(rth_branch) <+ ddt(Temp(rth_branch) * cth);
    end else begin
        Temp(t) <+ 0.0;
    end

    // Operation-point info
    IDS = devsign * sigvds * ids;

    // Drain-source saturation voltage
    VDSSAT = Vdsat;

    // Threshold voltage
    VTH = Vthop;

    // Transconductance
    GM = ddx(IDS, V(gi));

    // Output conductance
    GDS = ddx(IDS, V(di));

    // Body transconductance
    GMBS = ddx(IDS, V(bg));

    if (sigvds > 0.0) begin
        VFGS = V(fg, s);
        VFGD = V(fg, d);
        VDS  = V(d, s);
        VSBG = V(s, bg);
        VDBG = V(d, bg);
    end else begin
        VFGS = V(fg, d);
        VFGD = V(fg, s);
        VDS  = V(s, d);
        VSBG = V(d, bg);
        VDBG = V(s, bg);
    end

    // Total Source/Drain Currents (Physical)
    if (sigvds > 0.0) begin
        ID = IDS - devsign * (igd + igcd + igbd) + devsign * (Iii + igidl - igisl);
        IS = -IDS - devsign * (igs + igcs + igbs) + devsign* (igisl - igidl);
    end else begin
        ID = -IDS - devsign * (igs + igcs + igbd) + devsign * (igisl - igidl);
        IS = IDS - devsign * (igd + igcd + igbs) + devsign * (Iii + igidl - igisl);
    end

    // Total Gate Current
    IFG = devsign * (igs + igd + igcs + igcd + igbs + igbd);

    // Impact Ionization Current
    III = devsign * Iii;

    if (sigvds > 0.0) begin
        IGIDL = devsign * igidl;
        IGISL = devsign * igisl;
    end else begin
        IGIDL = devsign * igisl;
        IGISL = devsign * igidl;
    end

    // Intrinsic Charges
    QFGI = qfgi;
    QBGI = devsign * qbgi;
    QDI  = devsign * qdi;
    QSI  = devsign * qsi;

    // Total Charges
    QFG = qfg;
    QBG = devsign * qbg;
    QD  = devsign * qd;
    QS  = devsign * qs;

    // Intrinsic Capacitances
    CFGFGI = ddx(QFGI, V(gi));
    CFGSI  = -ddx(QFGI, V(si));
    CFGDI  = -ddx(QFGI, V(di));
    CFGBGI = -ddx(QFGI, V(bg));

    CSFGI  = -ddx(QSI, V(gi));
    CSSI   = ddx(QSI, V(si));
    CSDI   = -ddx(QSI, V(di));
    CSBGI  = -ddx(QSI, V(bg));

    CDFGI  = -ddx(QDI, V(gi));
    CDSI   = -ddx(QDI, V(si));
    CDDI   = ddx(QDI, V(di));
    CDBGI  = -ddx(QDI, V(bg));

    CBGFGI = -ddx(QBGI, V(gi));
    CBGSI  = -ddx(QBGI, V(si));
    CBGDI  = -ddx(QBGI, V(di));
    CBGBGI = ddx(QBGI, V(bg));

    // Total Capacitances
    CFGFG  = CFGFGI + ddx(devsign * (qfgs_parasitic + qfgd_parasitic), V(ge));
    CFGS   = -ddx(QFG, V(si));
    CFGD   = -ddx(QFG, V(di));
    CFGBG  = -ddx(QFG, V(bg));

    CSFG   = CSFGI + ddx(devsign * qfgs_parasitic, V(ge));
    CSS    = ddx(QS, V(si));
    CSD    = -ddx(QS, V(di));
    CSBG   = -ddx(QS, V(bg));

    CDFG   = CDFGI + ddx(devsign * qfgd_parasitic, V(ge));
    CDS    = -ddx(QD, V(si));
    CDD    = ddx(QD, V(di));
    CDBG   = -ddx(QD, V(bg));

    CBGFG  = -ddx(QBG, V(gi));
    CBGS   = -ddx(QBG, V(si));
    CBGD   = -ddx(QBG, V(di));
    CBGBG  = ddx(QBG, V(bg));

    // Output for self-heating temperature
    T_TOTAL_K  = DevTemp;
    T_TOTAL_C  = DevTemp - `P_CELSIUS0;
    T_DELTA_SH = Temp(t);

end
