<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementing devices · CedarSim</title><meta name="title" content="Implementing devices · CedarSim"/><meta property="og:title" content="Implementing devices · CedarSim"/><meta property="twitter:title" content="Implementing devices · CedarSim"/><meta name="description" content="Documentation for CedarSim."/><meta property="og:description" content="Documentation for CedarSim."/><meta property="twitter:description" content="Documentation for CedarSim."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CedarSim</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../circuits/">Circuit representation</a></li><li class="is-active"><a class="tocitem" href>Implementing devices</a><ul class="internal"><li><a class="tocitem" href="#Basic-concepts"><span>Basic concepts</span></a></li><li class="toplevel"><a class="tocitem" href="#A-basic-resistor"><span>A basic resistor</span></a></li><li class="toplevel"><a class="tocitem" href="#Using-custom-devices-from-a-SPICE-circuit"><span>Using custom devices from a SPICE circuit</span></a></li><li class="toplevel"><a class="tocitem" href="#Using-DAECompiler-intrinsics"><span>Using DAECompiler intrinsics</span></a></li><li class="toplevel"><a class="tocitem" href="#The-implementation-of-branch!"><span>The implementation of <code>branch!</code></span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementing devices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementing devices</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CedarEDA/CedarSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CedarEDA/CedarSim.jl/blob/main/docs/src/devices.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementing-devices"><a class="docs-heading-anchor" href="#Implementing-devices">Implementing devices</a><a id="Implementing-devices-1"></a><a class="docs-heading-anchor-permalink" href="#Implementing-devices" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This documentation describes CedarSim internals. At the moment, this is not supported as a stable API, but is intended to help users understand how Cedar works and to aid in experimentation. For end-users needing custom devices, Verilog-A is the recommended model representation.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Device equations may be specified in a subset of valid Julia. However, this subset is currently not precisely specified and no tooling is currently available to verify whether or not a device implementation complies with the supported subset.</p></div></div><h2 id="Basic-concepts"><a class="docs-heading-anchor" href="#Basic-concepts">Basic concepts</a><a id="Basic-concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-concepts" title="Permalink"></a></h2><p>In the previous chapter, we saw how circuits can be represented as julia functions. However, the circuits we defined were still composed of the basic primitive SPICE devices. In this chapter, we will explore the implementation of these devices and how to implement new kinds of devices or model representations. The basic idea is to implement the mathematical equations for a particular device in terms of the primitives provided by DAECompiler. See the DAECompiler docs for a detailed description of these intrinsic.</p><p>To begin, we will study some illustrative and simplified device implementations, gradually building up some additional features and complexity.</p><h1 id="A-basic-resistor"><a class="docs-heading-anchor" href="#A-basic-resistor">A basic resistor</a><a id="A-basic-resistor-1"></a><a class="docs-heading-anchor-permalink" href="#A-basic-resistor" title="Permalink"></a></h1><p>To begin with, consider a resistor:</p><pre><code class="nohighlight hljs">struct MyResistor
    resistance::Float64
end

(R::MyResistor)(A, B) = branch!((V, I)-&gt;V - I*R.resistance, A, B)</code></pre><p>Here, we use the CedarSim <code>branch!</code> helper, which is used to introduce a branch between two nodes and is very helpful for implementing two terminal devices. <code>branch!</code> provides the voltage difference across, as well as the current through the branch to the provided callback. This callback in turn, should implement (and return) the relation that must hold between voltage and current for this device. In the case of a resistor, this is simply <code>V = I*R</code> or as expressed here <code>0 = V - I*R</code>. This is a fully functional implementation of a resitor. CedarSim and DAECompiler will figure out everything else.</p><h1 id="Using-custom-devices-from-a-SPICE-circuit"><a class="docs-heading-anchor" href="#Using-custom-devices-from-a-SPICE-circuit">Using custom devices from a SPICE circuit</a><a id="Using-custom-devices-from-a-SPICE-circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Using-custom-devices-from-a-SPICE-circuit" title="Permalink"></a></h1><p>Now that we have a custom device, how do we use it? The first option is to simply use it directly in a julia-defined circuit as we saw in the previous chapter:</p><pre><code class="nohighlight hljs">using CedarSim.DeviceShorthands
using CedarEDA.SIFactors: k, μ

circuit() = (MyResistor(1k) ∥ C(1μ))(net(), gnd())</code></pre><p>This is equivalent to the RC example we saw at the end of the previous chapter. However, as written, the variable representing the current through the resistor is unnamed and can thus not be referenced symbolically. To fix this, and allow our custom device to participate in the <code>&quot;R1&quot;(MyResistor(1k))</code> syntax for providing device names, we need to slightly tweak our device definition to subtype <code>CircuitElement</code> (which provides the string overload) and thread through the debug scope (which is used to give the branch a symbolic name):</p><pre><code class="nohighlight hljs">using CedarSim.DeviceUtils
struct MyResistor &lt;: CircuitElement
    resistance::Float64
end

(R::MyResistor)(A, B; dscope=:R) = branch!((V, I)-&gt;V - I*R.resistance, dscope, A, B)</code></pre><p>With this definition, even without providing a name, we can query the current through the resistor as <code>sys.R1</code>. The <code>:R</code> default we provided to <code>dscope</code> means that all devices of this type will default to names starting with <code>R</code> - the names are stable for a particular circuit definition, but can change arbitrarily when the circuit is modified, so providing explicit names is recommended. See the circuit definition docs for further details.</p><p>With this set, we are now also ready to use this device from SPICE. The simplest way to do so is to use the string interpolation syntax:</p><pre><code class="language-julia hljs">using CedarSim.DeviceShorthands
function circuit()
    sp&quot;&quot;&quot;
    * A simple RC circuit with a custom resistor device
    R1 1 0 $(MyResistor(1k))
    C1 1 0 1u
    &quot;&quot;&quot;e
end</code></pre><p>custom devices may be used in model position for any SPICE device type. No extra parameters should be passed on the SPICE instantiation line, as parameters are provided directly to the julia constructor.</p><h1 id="Using-DAECompiler-intrinsics"><a class="docs-heading-anchor" href="#Using-DAECompiler-intrinsics">Using DAECompiler intrinsics</a><a id="Using-DAECompiler-intrinsics-1"></a><a class="docs-heading-anchor-permalink" href="#Using-DAECompiler-intrinsics" title="Permalink"></a></h1><p>So far, we&#39;ve seen how to use the <code>branch!</code> abstraction provided by CedarSim. This is sufficient for many linear and non-linear devices whose constituent equations are simply a function of the branch voltage and current. However, if the device has additional internal state, you may need to introduce additional variables directly using the DAECompiler API. In this example, we shall consider a resistor with self-heating thermal effects. In particular, we will model:</p><ul><li>The current through the resistor increasing the temperature</li><li>Radiative and other thermal losses to the environment</li><li>Thermal effects on the resistance of the resistor</li></ul><p>Note that in general, one may want to instead build a generic thermal resistor with a thermal port that can be connected for a full multi-physics simulation, but that is outside the scope of this tutorial.</p><pre><code class="nohighlight hljs">struct ThermalResistor
    &quot;Nominal resistance of the resistor at room temperature (20 °C)&quot;
    R₀::Float64
    &quot;Thermal capacitance of the resistor in J/K&quot;
    Cth::Float64
    &quot;Temperature coefficient of the resistor in Ω/K&quot;
    TR::Float64
    &quot;Thermal loss coefficient to the environment in 1/s&quot;
    k::Float64
end

function (this::ThermalResistor)(A, B, dscope=defaultscope(:TR))
    branch!(dscope, A, B) do V, I
        # Introduce a new variable to hold the current temperature of the resistor
        (; T) = variables(dscope)
        # Instantaneous resistance
        R = this.R₀ + (T - 293.15) * this.TR
        # Instantaneous power dissipation
        P = R * I^2
        # Self-heating and radiative losses
        equation!(ddt(T) - this.Cth * P + this.k * (T - var&quot;$temperature&quot;()))
        # Ohm&#39;s law
        return V - I * R
    end
end</code></pre><p>A couple of aspects here deserve explanation. First, we used <code>CedarSim.defaultscope</code> to create a scope for our variables. The higher-level CedarSim <code>branch!</code> can take either a scope or a raw symbol (in which case it will call <code>defaultscope</code> internally). However, for raw DAECompiler APIs, we need a reference to the scope that <code>branch!</code> would have otherwise created implicitly, so we explicitly call <code>defaultscope</code> here.</p><p>With this in hand, we used the <code>variables</code> helper from DAECompiler to introduce a variable for our resistor temperature. We could have also used a lower level <code>variable(dscope(:T))</code> call here, but <code>variables</code> conveniently allows us to avoid writing the variable name twice (as <code>nets</code> would in CedarSim).</p><p>Next we used DAECompiler&#39;s <code>ddt</code> to write the equation for the derivative of our temperature.</p><p>Lastly, we used CedarSim&#39;s <code>var&quot;$temperature&quot;</code> to access the declared ambient temperature of the simulation.</p><p>Note that we could have also used <code>V*I</code> for the power disscipation and calculated the resistance last. Such a rearrangement is semantically equivalent and in fact DAECompiler will happily rearrange such equations according to its heuristics.</p><h1 id="The-implementation-of-branch!"><a class="docs-heading-anchor" href="#The-implementation-of-branch!">The implementation of <code>branch!</code></a><a id="The-implementation-of-branch!-1"></a><a class="docs-heading-anchor-permalink" href="#The-implementation-of-branch!" title="Permalink"></a></h1><p>Finally, we&#39;re ready to see how <code>branch!</code> itself is implemented. For two terminal devices, it is recommended to just use <code>branch!</code> directly, but for devices with more terminals, it can be useful to work directly with the underlying nets.</p><p>First, here is the implementation of <code>branch!</code>:</p><pre><code class="nohighlight hljs">function branch!(scope::AbstractScope, net₊::AbstractNet, net₋::AbstractNet)
    # Branch current - semantically flows from net₊ to net₋
    I = variable(scope(:I))
    kcl!(net₊, -I)
    kcl!(net₋,  I)
    V = net₊.V - net₋.V
    observed!(ForwardDiff.value(SimTag, V), scope(:V))
    (V, I)
end</code></pre><p>Here we used another CedarSim abstraction, <code>kcl!</code> to add the current contributions into the KCL for each for the two nets. Using the abstraction is recommended in case of any future changes to the implementation of <code>Net</code>. However, for completeness, here is (a slightly simplified version of) the current implementation:</p><pre><code class="nohighlight hljs">struct Net{T} &lt;: AbstractNet
    V::T
    kcl!::equation
    function Net(name::AbstractScope)
        V = variable(name)
        kcl! = equation(name)
        return new(V, kcl!)
    end
end
kcl!(net::AbstractNet, current) = net.kcl!(current)</code></pre><p>Here we are simply making use of the capability of DAECompiler to split the contributions to an equation across multiple invocations to that equation (in particular, this use case was motivating for that feature).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../circuits/">« Circuit representation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 30 April 2024 11:07">Tuesday 30 April 2024</span>. Using Julia version 1.12.0-DEV.416.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
