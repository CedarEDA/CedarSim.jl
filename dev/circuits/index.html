<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Circuit representation · CedarSim</title><meta name="title" content="Circuit representation · CedarSim"/><meta property="og:title" content="Circuit representation · CedarSim"/><meta property="twitter:title" content="Circuit representation · CedarSim"/><meta name="description" content="Documentation for CedarSim."/><meta property="og:description" content="Documentation for CedarSim."/><meta property="twitter:description" content="Documentation for CedarSim."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CedarSim</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Circuit representation</a><ul class="internal"><li><a class="tocitem" href="#CedarSim-as-a-compiler"><span>CedarSim as a compiler</span></a></li><li class="toplevel"><a class="tocitem" href="#Basic-circuits"><span>Basic circuits</span></a></li><li><a class="tocitem" href="#Names"><span>Names</span></a></li><li><a class="tocitem" href="#Some-additional-conveniences"><span>Some additional conveniences</span></a></li><li><a class="tocitem" href="#Subcircuits"><span>Subcircuits</span></a></li></ul></li><li><a class="tocitem" href="../devices/">Implementing devices</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Circuit representation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Circuit representation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CedarEDA/CedarSim.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CedarEDA/CedarSim.jl/blob/main/docs/src/circuits.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Circuit-representation"><a class="docs-heading-anchor" href="#Circuit-representation">Circuit representation</a><a id="Circuit-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Circuit-representation" title="Permalink"></a></h1><h2 id="CedarSim-as-a-compiler"><a class="docs-heading-anchor" href="#CedarSim-as-a-compiler">CedarSim as a compiler</a><a id="CedarSim-as-a-compiler-1"></a><a class="docs-heading-anchor-permalink" href="#CedarSim-as-a-compiler" title="Permalink"></a></h2><p>The core functionality provided by CedarSim is to compile various circuit-specfific input formats into an executable representation that is then passed on to the backend for further processing. For simulation, this backend is generally <a href="https://help.juliahub.com/daecompiler/stable/">DAECompiler</a>, but other backends are possible for other analysis tasks. CedarSim is designed to, as much as is feasible, re-use and integrate with the capabilities of the Julia compiler. As such, CedarSim uses Julia code as its executable representation. As a result, you may, and it is occasionally helpful, to think about CedarSim as a custom frontend for the Julia language that parses Julia code that happens to be written in languages that are not Julia.</p><h1 id="Basic-circuits"><a class="docs-heading-anchor" href="#Basic-circuits">Basic circuits</a><a id="Basic-circuits-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-circuits" title="Permalink"></a></h1><p>CedarSim is ordinarily driven by Spectre or SPICE netlists. However, it is possible to construct the executable representation manually. It is perhaps easiest to see this with an example:</p><pre><code class="language-julia hljs">using CedarSim

# Create a 1kΩ resistor device template
const R1k = CedarSim.SimpleResistor(1000.)

# Cretae a 1μF capacitor device template
const C1μ = CedarSim.SimpleCapacitor(1e-6)

# Create a Gnd device template
const G = CedarSim.Gnd()

function my_rc_circuit()
    # Create two nets
    A = net()
    B = net()

    # Wire up the circuit
    R1k(A, B)
    C1μ(A, B)
    G(B)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_rc_circuit (generic function with 1 method)</code></pre><p>Running this &quot;circuit&quot; as a julia function returns <code>nothing</code>, but doing so can be useful as a sanity check that there are no typos in the definition:</p><pre><code class="language- hljs">my_rc_circuit()</code></pre><p>This function fully represents a circuit and may be used in all APIs that expect circuits:</p><pre><code class="language- hljs">using OrdinaryDiffEq, UnicodePlots

sys = CircuitIRODESystem(my_rc_circuit)

sol = solve(ODEProblem(sys, [1.0], (0., 1e-2)), Rosenbrock23(; autodiff=false))

lineplot(sol.t, sol[sys.C1.V])</code></pre><p>!!! warning This method of plotting is useful for quick validation, but not recommended. In particular, we are ignoring the solver&#39;s internal interpolation, instead substituting the plotting library&#39;s linear interpolation. For proper plots, please use the higher-level plotting APIs in CedarEDA.</p><h2 id="Names"><a class="docs-heading-anchor" href="#Names">Names</a><a id="Names-1"></a><a class="docs-heading-anchor-permalink" href="#Names" title="Permalink"></a></h2><p>In the above example, we were able to access the capacitor using the name <code>C1</code> even though no name was specified. When no name is specified, the backend will assign unique names after all other names have been resolved. This process is deterministic for a particular function/environment (library versions, etc.), but of course small changes to the circuit can completely change the auto-generated names.</p><p>To ensure stable names, names may be assigned explicitly using the <code>Named</code> wrapper:</p><pre><code class="language-julia hljs">function my_named_rc_circuit()
    # Create two nets
    A = net()
    B = net()

    # Wire up the circuit
    Named(R1k, &quot;R&quot;)(A, B)
    Named(C1μ, &quot;MyCapacitor&quot;)(A, B)
    G(B)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_named_rc_circuit (generic function with 1 method)</code></pre><p>With these names set, we can now access the capacitor states <code>sys.MyCapacitor</code>. For basic devices and subcircuits (everything that is <code>::CircuitElement</code>), there is also a shorthand overload that omits <code>Named</code> (but is otherwise exactly equivalent):</p><pre><code class="language-julia hljs">function my_named_rc_circuit2()
    # Create two nets
    A = net()
    B = net()

    # Wire up the circuit
    &quot;R&quot;(R1k)(A, B)
    &quot;MyCapacitor&quot;(C1μ)(A, B)
    G(B)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">my_named_rc_circuit2 (generic function with 1 method)</code></pre><h2 id="Some-additional-conveniences"><a class="docs-heading-anchor" href="#Some-additional-conveniences">Some additional conveniences</a><a id="Some-additional-conveniences-1"></a><a class="docs-heading-anchor-permalink" href="#Some-additional-conveniences" title="Permalink"></a></h2><p>In the above, we have named our devices, but the nets remain yet unnamed. There are several options for naming nets:</p><ol><li>The name of a net may be passed as the first argument to <code>net</code></li><li>They may be named using device syntax</li><li>The <code>nets</code> helper can be used to automatically name a net and assign it to the corresponding variable.</li></ol><p>In other words, these three are all equivalent:</p><pre><code class="language-julia hljs">A = net(:A)
# A = &quot;A&quot;(net)() # XXX
(;A) = nets()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">nets((A = CedarSim.Net{Float64}(14.0, DAECompiler.Intrinsics.equation(), 1.0),))</code></pre><p>There are some addditional convenience available.</p><h3 id="Gnd-special-case"><a class="docs-heading-anchor" href="#Gnd-special-case">Gnd special case</a><a id="Gnd-special-case-1"></a><a class="docs-heading-anchor-permalink" href="#Gnd-special-case" title="Permalink"></a></h3><p>CedarSim exports the function:</p><pre><code class="language-julia hljs">gnd() = (g = net(); Gnd()(g); g)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">gnd (generic function with 1 method)</code></pre><p>which can be used as a covenient shorthand to obtain ground for situations where it&#39;s more convenient to think of ground as a net rather than a device.</p><h3 id="CedarSim.DeviceShorthands"><a class="docs-heading-anchor" href="#CedarSim.DeviceShorthands"><code>CedarSim.DeviceShorthands</code></a><a id="CedarSim.DeviceShorthands-1"></a><a class="docs-heading-anchor-permalink" href="#CedarSim.DeviceShorthands" title="Permalink"></a></h3><p>The <code>DeviceShorthands</code> submodule exports short aliases for the basic SPICE devices using function names that (in general) match their SPICE prefix. These can be convenient for quickly writing netlists. For example, resistors and capacitors are available using the <code>DeviceShorthands.R</code> and <code>DeviceShorthands.C</code> functions respectively.</p><h3 id="Parallel-and-series-composition-operators"><a class="docs-heading-anchor" href="#Parallel-and-series-composition-operators">Parallel and series composition operators</a><a id="Parallel-and-series-composition-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-and-series-composition-operators" title="Permalink"></a></h3><p>The operators <code>∥</code> and <code>⋯</code> (typed using <code>\parallel</code> and <code>\cdots</code>; also availbel using the ASCII names <code>parallel</code> and <code>series</code>) may be used for parallel and sequential composition respectively.</p><p>For example, our running RC circuit example, could have been simply written as:</p><pre><code class="language- hljs">using CedarSim.DeviceShorthands

using CedarEDA.SIFactors: k, μ

RC() = (R(1k) ∥ C(1μ))(net(), gnd())</code></pre><h2 id="Subcircuits"><a class="docs-heading-anchor" href="#Subcircuits">Subcircuits</a><a id="Subcircuits-1"></a><a class="docs-heading-anchor-permalink" href="#Subcircuits" title="Permalink"></a></h2><p>Regular function composition does not by default introduce subcircuits. For example, the function:</p><pre><code class="language- hljs">RC2() = (RC(); RC())</code></pre><p>described a circuit with four top level devices (<code>sys.R1</code>, <code>sys.R2</code>, <code>sys.C1</code>, <code>sys.C2</code>). To instead create a hierachichal circuit, <code>CedarSim</code> provides the <code>SubCircuit</code> device.</p><pre><code class="language- hljs">RC2_sub() = (SubCircuit(RC)(); SubCircuit(RC)();)</code></pre><p>The names of the four devices are now <code>sys.X1.R1</code>, <code>sys.X1.C1</code>, <code>sys.X2.R1</code>, <code>sys.X2.C1</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The use of subcircuits is a convenience for the user to allow hierarchical specification of device names. The compiler takes advantage of hierachy whether or not the <code>SubCircuit</code> device is used.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../devices/">Implementing devices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 30 April 2024 11:07">Tuesday 30 April 2024</span>. Using Julia version 1.12.0-DEV.416.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
