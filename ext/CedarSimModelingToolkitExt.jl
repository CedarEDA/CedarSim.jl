module CedarSimModelingToolkitExt
using CedarSim
using ModelingToolkit
using CedarSim: AbstractNet, defaultscope, kcl!
using DAECompiler
using DAECompiler.Intrinsics


function is_pin(sys::ODESystem)  # MSL.Electrical.Pin, or functionally equivelent
    # there is no way to actually check if it is literally a MSL.Electrical.Pin
    # but it doesn't matter as having the following properties means it is exactly the same
    propertynames(sys) == [:v, :i] &&
    ModelingToolkit.get_connection_type(sys.v) == ModelingToolkit.Equality &&
    ModelingToolkit.get_connection_type(sys.i) == ModelingToolkit.Flow
end
is_pin(_) = false

macro CedarSim.declare_MSLConnector(mtk_model, pin_ports...)
    checks = Expr[]
    declare = Expr(:macrocall, var"@declare_MTKConnector", __source__, mtk_model)
    for pin in pin_ports
        push!(checks, :($is_pin($pin) || throw(ArgumentError(string($(Meta.quot(pin))) *" is not a Pin."))))
        push!(declare.args, :($pin.v), :($pin.i))
    end
    return esc(quote
        $(checks...)
        $declare
    end)
end

# This is a generic default that automatically maps from CedarSim.AbstractsNets to the normal generated MTKConnector
# it will only work correctly if that MTKConnector was generated by `declare_MSLConnector` or if it follows same ordering for pins to variables as that does
# if it doesn't it won't work, but you can provide your own more specic mapping anyway
#== 
# This is the generalization of:
function (this!::ThreeConn)(A, B, C; dscope=:defaultscope(:M))
    (; A_i, B_i, C_i) = variables(dscope)
    equation!(A_i + B_i + C_i)
    kcl!(A, A_i)
    kcl!(B, B_i)
    kcl!(C, C_i)
    this!(A.V, A_i, B.V, B_i, C.V, C_i)
end
==#
@generated function (this!::MTKConnector)(nets::AbstractNet...; dscope=defaultscope(:M))
    body = quote
        device_kcl! = equation()
    end
    final_call = :(this!(;dscope))
    for ii in eachindex(nets)
        current_var = gensym(Symbol(:outer_port_i, ii))
        push!(body.args, :($current_var = variable($(Scope)(dscope, $(Meta.quot(current_var))))))
        push!(body.args, :(device_kcl!($current_var)))
        push!(final_call.args, :(nets[$ii].V), current_var)
    end
    push!(body.args, final_call)
    return body
end


end  # module